----- Inhalt von: ArtikelBestellungDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import Objekte.ArtikelBestellung;

public class ArtikelBestellungDAO extends BaseDAO<ArtikelBestellung> {

    public ArtikelBestellungDAO(Connection connection) {
        super(connection);
    }

    @Override
    public void insert(ArtikelBestellung artikelBestellung) throws SQLException {
        String sql = "INSERT INTO ArtikelBestellung (BestellungID, ArtikelID, Menge, Aufaddiert) VALUES (?, ?, ?, ?)";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, artikelBestellung.getBestellungID());
            ps.setInt(2, artikelBestellung.getArtikelID());
            ps.setInt(3, artikelBestellung.getMenge());
            ps.setDouble(4, artikelBestellung.getAufaddiert());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public ArtikelBestellung findById(int id) throws SQLException {
        throw new UnsupportedOperationException(
            "ArtikelBestellung hat keinen einzelnen Primary Key. Nutze findByBestellungIdAndArtikelId()!"
        );
    }

    public ArtikelBestellung findByBestellungIdAndArtikelId(int bestellungID, int artikelID) throws SQLException {
        String sql = "SELECT BestellungID, ArtikelID, Menge, Aufaddiert FROM ArtikelBestellung " +
                     "WHERE BestellungID = ? AND ArtikelID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, bestellungID);
            ps.setInt(2, artikelID);
            rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToArtikelBestellung(rs);
            }
        } finally {
            closeResources(rs, ps);
        }
        return null;
    }

    @Override
    public void update(ArtikelBestellung artikelBestellung) throws SQLException {
        String sql = "UPDATE ArtikelBestellung SET Menge = ?, Aufaddiert = ? WHERE BestellungID = ? AND ArtikelID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, artikelBestellung.getMenge());
            ps.setDouble(2, artikelBestellung.getAufaddiert());
            ps.setInt(3, artikelBestellung.getBestellungID());
            ps.setInt(4, artikelBestellung.getArtikelID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        throw new UnsupportedOperationException(
            "ArtikelBestellung hat keinen einzelnen Primary Key. Nutze deleteByBestellungIdAndArtikelId()!"
        );
    }

    public void deleteByBestellungIdAndArtikelId(int bestellungID, int artikelID) throws SQLException {
        String sql = "DELETE FROM ArtikelBestellung WHERE BestellungID = ? AND ArtikelID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, bestellungID);
            ps.setInt(2, artikelID);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    public List<ArtikelBestellung> findByBestellungId(int bestellungID) throws SQLException {
        String sql = "SELECT BestellungID, ArtikelID, Menge, Aufaddiert FROM ArtikelBestellung WHERE BestellungID = ?";
        List<ArtikelBestellung> list = new ArrayList<>();
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, bestellungID);
            rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToArtikelBestellung(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return list;
    }

    public List<ArtikelBestellung> findByArtikelId(int artikelID) throws SQLException {
        String sql = "SELECT BestellungID, ArtikelID, Menge, Aufaddiert FROM ArtikelBestellung WHERE ArtikelID = ?";
        List<ArtikelBestellung> list = new ArrayList<>();
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, artikelID);
            rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToArtikelBestellung(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return list;
    }

    public List<ArtikelBestellung> findAll() throws SQLException {
        String sql = "SELECT BestellungID, ArtikelID, Menge, Aufaddiert FROM ArtikelBestellung";
        List<ArtikelBestellung> list = new ArrayList<>();
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToArtikelBestellung(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return list;
    }

    private ArtikelBestellung mapRowToArtikelBestellung(ResultSet rs) throws SQLException {
        return new ArtikelBestellung(
            rs.getInt("BestellungID"),
            rs.getInt("ArtikelID"),
            rs.getInt("Menge"),
            rs.getDouble("Aufaddiert")
        );
    }
}

----- Inhalt von: ArtikelDAO.txt -----
package DAOs;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import Objekte.Artikel;
import Objekte.Kategorie;

public class ArtikelDAO extends BaseDAO<Artikel> {
    private KategorieDAO kategorieDAO;

    public ArtikelDAO(Connection connection) {
        super(connection);
        this.kategorieDAO = new KategorieDAO(connection);
    }

    @Override
    public void insert(Artikel artikel) throws SQLException {
        String sql = "INSERT INTO Artikel (Name, Einzelpreis, Kommentar, KategorieID) VALUES (?, ?, ?, ?)";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, artikel.getName());
            ps.setDouble(2, artikel.getEinzelpreis());
            ps.setString(3, artikel.getKommentar());
            ps.setInt(4, artikel.getKategorie().getKategorieID()); // Änderung!
            ps.executeUpdate();

            rs = ps.getGeneratedKeys();
            if (rs.next()) {
                artikel.setArtikelID(rs.getInt(1));
            }
        } finally {
            closeResources(rs, ps);
        }
    }

    @Override
    public Artikel findById(int id) throws SQLException {
        String sql = "SELECT ArtikelID, Name, Einzelpreis, Kommentar, KategorieID FROM Artikel WHERE ArtikelID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToArtikel(rs);
            }
        } finally {
            closeResources(rs, ps);
        }
        return null;
    }

    @Override
    public void update(Artikel artikel) throws SQLException {
        String sql = "UPDATE Artikel SET Name = ?, Einzelpreis = ?, Kommentar = ?, KategorieID = ? WHERE ArtikelID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setString(1, artikel.getName());
            ps.setDouble(2, artikel.getEinzelpreis());
            ps.setString(3, artikel.getKommentar());
            ps.setInt(4, artikel.getKategorie().getKategorieID()); // Änderung!
            ps.setInt(5, artikel.getArtikelID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Artikel WHERE ArtikelID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    public List<Artikel> findAll() throws SQLException {
        String sql = "SELECT ArtikelID, Name, Einzelpreis, Kommentar, KategorieID FROM Artikel";
        List<Artikel> list = new ArrayList<>();
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToArtikel(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return list;
    }

    // Hilfsmethode: Sucht nach allen Attributen
    public List<Artikel> searchAllAttributes(String searchTerm) throws SQLException {
        List<Artikel> result = new ArrayList<>();
        String sql = "SELECT ArtikelID, Name, Einzelpreis, Kommentar, KategorieID FROM Artikel WHERE " +
                     "CAST(ArtikelID AS CHAR) LIKE ? OR " +
                     "LOWER(Name) LIKE ? OR " +
                     "LOWER(Kommentar) LIKE ? OR " +
                     "CAST(KategorieID AS CHAR) LIKE ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            String like = "%" + searchTerm.toLowerCase() + "%";
            ps.setString(1, like);
            ps.setString(2, like);
            ps.setString(3, like);
            ps.setString(4, like);
            rs = ps.executeQuery();
            while (rs.next()) {
                result.add(mapRowToArtikel(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return result;
    }

    // Änderung: Kategorie als Objekt holen
    private Artikel mapRowToArtikel(ResultSet rs) throws SQLException {
        int kategorieID = rs.getInt("KategorieID");
        Kategorie kategorie = kategorieDAO.findById(kategorieID);

        Artikel artikel = new Artikel(
            rs.getInt("ArtikelID"),
            rs.getString("Name"),
            rs.getDouble("Einzelpreis"),
            rs.getString("Kommentar"),
            kategorie
        );
        return artikel;
    }
}

----- Inhalt von: BaseDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * Abstrakte generische Basisklasse für alle DAOs.
 *
 * @param <T> Der Typ des zu verwaltenden Objekts
 */
public abstract class BaseDAO<T> {

    protected Connection connection;

    public BaseDAO(Connection connection) {
        this.connection = connection;
    }

    // CRUD-Methoden mit genereller Exception erlaubt
    public abstract T findById(int id) throws Exception;
    public abstract void insert(T entity) throws Exception;
    public abstract void update(T entity) throws Exception;
    public abstract void delete(int id) throws Exception;

    // Schließt die Verbindung
    protected void closeResources(ResultSet rs, PreparedStatement ps) {
        try {
            if (rs != null) rs.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (ps != null) ps.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // Getter
    
    protected Connection getConnection() {
        return connection;
    }
}

----- Inhalt von: BenutzerDAO.txt -----
package DAOs;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import Objekte.Benutzer;
import Objekte.Rolle;

public class BenutzerDAO extends BaseDAO<Benutzer> {

	private final RolleDAO rolleDAO;

	public BenutzerDAO(Connection connection) {
		super(connection);
		this.rolleDAO = new RolleDAO(connection);
	}

	@Override
	public void insert(Benutzer benutzer) throws SQLException {
		String sql = "INSERT INTO Benutzer (Benutzername, Passwort, RolleID) VALUES (?, ?, ?)";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, benutzer.getBenutzername());
			ps.setString(2, benutzer.getPasswort());
			ps.setInt(3, benutzer.getRolle() != null ? benutzer.getRolle().getRolleID() : 0);
			ps.executeUpdate();

			rs = ps.getGeneratedKeys();
			if (rs.next()) {
				benutzer.setBenutzerID(rs.getInt(1));
			}
		} finally {
			closeResources(rs, ps);
		}
	}

	@Override
	public Benutzer findById(int id) throws SQLException {
		String sql = "SELECT * FROM Benutzer WHERE BenutzerID = ?";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setInt(1, id);
			rs = ps.executeQuery();
			if (rs.next()) {
				return mapRowToBenutzer(rs);
			}
		} finally {
			closeResources(rs, ps);
		}
		return null;
	}

	@Override
	public void update(Benutzer benutzer) throws SQLException {
		String sql = "UPDATE Benutzer SET Benutzername = ?, Passwort = ?, RolleID = ? WHERE BenutzerID = ?";
		PreparedStatement ps = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setString(1, benutzer.getBenutzername());
			ps.setString(2, benutzer.getPasswort());
			ps.setInt(3, benutzer.getRolle() != null ? benutzer.getRolle().getRolleID() : 0);
			ps.setInt(4, benutzer.getBenutzerID());
			ps.executeUpdate();
		} finally {
			closeResources(null, ps);
		}
	}

	@Override
	public void delete(int id) throws SQLException {
		String sql = "DELETE FROM Benutzer WHERE BenutzerID = ?";
		PreparedStatement ps = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setInt(1, id);
			ps.executeUpdate();
		} finally {
			closeResources(null, ps);
		}
	}

	public List<Benutzer> findAll() throws SQLException {
		String sql = "SELECT * FROM Benutzer";
		List<Benutzer> list = new ArrayList<>();
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				list.add(mapRowToBenutzer(rs));
			}
		} finally {
			closeResources(rs, ps);
		}
		return list;
	}

	public List<Benutzer> searchAllAttributes(String searchTerm) throws SQLException {
		List<Benutzer> result = new ArrayList<>();
		String query = "SELECT * FROM Benutzer " + "WHERE CAST(BenutzerID AS CHAR) LIKE ? " + "OR Benutzername LIKE ? "
				+ "OR Passwort LIKE ? " + "OR CAST(RolleID AS CHAR) LIKE ?";
		try (PreparedStatement stmt = connection.prepareStatement(query)) {
			String like = "%" + searchTerm + "%";
			stmt.setString(1, like);
			stmt.setString(2, like);
			stmt.setString(3, like);
			stmt.setString(4, like);
			try (ResultSet rs = stmt.executeQuery()) {
				while (rs.next()) {
					result.add(mapRowToBenutzer(rs));
				}
			}
		}
		return result;
	}

	private Benutzer mapRowToBenutzer(ResultSet rs) throws SQLException {
	    Benutzer benutzer = new Benutzer();
	    benutzer.setBenutzerID(rs.getInt("BenutzerID"));
	    benutzer.setBenutzername(rs.getString("Benutzername"));
	    benutzer.setPasswort(rs.getString("Passwort"));

	    int rolleID = rs.getInt("RolleID");
	    Rolle rolle = null;
	    try {
	        rolle = rolleID > 0 ? rolleDAO.findById(rolleID) : null;
	    } catch (SQLException ex) {
	    }
	    benutzer.setRolle(rolle);

	    return benutzer;
	}

}

----- Inhalt von: BestellungDAO.txt -----
package DAOs;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import Objekte.Bestellung;

public class BestellungDAO extends BaseDAO<Bestellung> {

    public BestellungDAO(Connection connection) {
        super(connection);
    }

    @Override
    public void insert(Bestellung bestellung) throws SQLException {
        String sql = "INSERT INTO Bestellung (MitgliederID, Gesamtpreis, Bestelldatum, ZahlungID, MitarbeiterID) " +
                     "VALUES (?, ?, ?, ?, ?)";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            ps.setInt(1, bestellung.getMitgliederID());
            ps.setDouble(2, bestellung.getGesamtpreis());
            ps.setTimestamp(3, bestellung.getBestelldatum());
            ps.setInt(4, bestellung.getZahlungID());
            ps.setInt(5, bestellung.getMitarbeiterID());
            ps.executeUpdate();
            rs = ps.getGeneratedKeys();
            if (rs.next()) {
                bestellung.setBestellungID(rs.getInt(1));
            }
        } finally {
            closeResources(rs, ps);
        }
    }

    @Override
    public Bestellung findById(int id) throws SQLException {
        String sql = "SELECT BestellungID, MitgliederID, Gesamtpreis, Bestelldatum, ZahlungID, MitarbeiterID " +
                     "FROM Bestellung WHERE BestellungID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToBestellung(rs);
            }
        } finally {
            closeResources(rs, ps);
        }
        return null;
    }

    @Override
    public void update(Bestellung bestellung) throws SQLException {
        String sql = "UPDATE Bestellung SET MitgliederID = ?, Gesamtpreis = ?, Bestelldatum = ?, ZahlungID = ?, MitarbeiterID = ? WHERE BestellungID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, bestellung.getMitgliederID());
            ps.setDouble(2, bestellung.getGesamtpreis());
            ps.setTimestamp(3, bestellung.getBestelldatum());
            ps.setInt(4, bestellung.getZahlungID());
            ps.setInt(5, bestellung.getMitarbeiterID());
            ps.setInt(6, bestellung.getBestellungID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Bestellung WHERE BestellungID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    public List<Bestellung> findByMitgliederId(int mitgliederID) throws SQLException {
        String sql = "SELECT BestellungID, MitgliederID, Gesamtpreis, Bestelldatum, ZahlungID, MitarbeiterID " +
                     "FROM Bestellung WHERE MitgliederID = ?";
        List<Bestellung> list = new ArrayList<>();
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, mitgliederID);
            rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToBestellung(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return list;
    }

    public List<Bestellung> findAll() throws SQLException {
        String sql = "SELECT BestellungID, MitgliederID, Gesamtpreis, Bestelldatum, ZahlungID, MitarbeiterID FROM Bestellung";
        List<Bestellung> list = new ArrayList<>();
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToBestellung(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return list;
    }

    public List<Bestellung> searchAllAttributes(String searchTerm) throws SQLException {
        List<Bestellung> result = new ArrayList<>();
        String sql = "SELECT * FROM Bestellung WHERE " +
                     "CAST(BestellungID AS CHAR) LIKE ? OR " +
                     "CAST(MitgliederID AS CHAR) LIKE ? OR " +
                     "CAST(MitarbeiterID AS CHAR) LIKE ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            String like = "%" + searchTerm.toLowerCase() + "%";
            ps.setString(1, like);
            ps.setString(2, like);
            ps.setString(3, like);
            rs = ps.executeQuery();
            while (rs.next()) {
                result.add(mapRowToBestellung(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return result;
    }

    private Bestellung mapRowToBestellung(ResultSet rs) throws SQLException {
        return new Bestellung(
            rs.getInt("BestellungID"),
            rs.getInt("MitgliederID"),
            rs.getDouble("Gesamtpreis"),
            rs.getTimestamp("Bestelldatum"),
            rs.getInt("ZahlungID"),
            rs.getInt("MitarbeiterID") // NEU
        );
    }
}

----- Inhalt von: ConnectionDB.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

import Exception.ConnectionException;

public class ConnectionDB {

    private static String url = "jdbc:mysql://localhost:3306/MitgliederverwaltungKonsole";
    private static String user = "root";
    private static String password = "meinPasswort";

    public static Connection getConnection() throws ConnectionException {
        try {
            return DriverManager.getConnection(url, user, password);
        } catch (SQLException e) {
        	System.out.println(e.getMessage());
            throw new ConnectionException("Keine Verbindung zur Datenbank möglich.", e);
            
        }
    }
}

----- Inhalt von: InteressentenDAO.txt -----
package DAOs;

import Objekte.Interessenten;
import Objekte.Mitglieder;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import Exception.StringException;
import OUTDATED.OUT_StringValidator;

public class InteressentenDAO extends BaseDAO<Interessenten> {

    // Attribute
    private final OUT_StringValidator oUT_StringValidator = new OUT_StringValidator();

    // Konstruktor
    public InteressentenDAO(Connection connection) {
        super(connection);
    }
    
    public List<Interessenten> searchAllAttributes(String searchTerm) throws SQLException {
        List<Interessenten> results = new ArrayList<>();
        String sql = "SELECT MitgliederID, Vorname, Nachname, Telefon FROM Mitglieder WHERE " +
                     "Vorname LIKE ? OR Nachname LIKE ? OR Telefon LIKE ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            String pattern = "%" + searchTerm + "%";
            for (int i = 1; i <= 3; i++) {
                stmt.setString(i, pattern);
            }
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                Interessenten i = mapRowToInteressenten(rs);
                results.add(i);
            }
        }
        return results;
    }

    public int getID(Interessenten interessent) {
        return interessent.getMitgliederID();
    }
    
    private Mitglieder mapRowToInteressenten(ResultSet rs) throws SQLException {
        Mitglieder mitglied = new Mitglieder();
        mitglied.setMitgliederID(rs.getInt("MitgliederID"));
        mitglied.setVorname(rs.getString("Vorname"));
        mitglied.setNachname(rs.getString("Nachname"));
        mitglied.setTelefon(rs.getString("Telefon"));
        return mitglied;
    }
    
    /**
     * Findet oder legt einen Interessenten an (Vorname, Nachname, Telefon).
     * Gibt immer eine MitgliederID zurück (vorhanden oder neu).
     */
    public int findOrCreateInteressent(String vorname, String nachname, String telefon)
            throws SQLException, StringException {
        oUT_StringValidator.validate(vorname);
        oUT_StringValidator.validate(nachname);
        oUT_StringValidator.validate(telefon);

        String selectSQL = "SELECT MitgliederID FROM Mitglieder WHERE Vorname = ? AND Nachname = ? AND Telefon = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(selectSQL);
            ps.setString(1, vorname);
            ps.setString(2, nachname);
            ps.setString(3, telefon);
            rs = ps.executeQuery();
            if (rs.next()) {
                return rs.getInt("MitgliederID");
            }
        } finally {
            closeResources(rs, ps);
        }

        String insertSQL = "INSERT INTO Mitglieder (Vorname, Nachname, Telefon) VALUES (?, ?, ?)";
        try {
            ps = connection.prepareStatement(insertSQL, Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, vorname);
            ps.setString(2, nachname);
            ps.setString(3, telefon);
            ps.executeUpdate();
            rs = ps.getGeneratedKeys();
            if (rs.next()) {
                return rs.getInt(1);
            } else {
                throw new SQLException("Fehler: Neue MitgliederID konnte nicht erfasst werden.");
            }
        } finally {
            closeResources(rs, ps);
        }
    }

    // Override
    @Override
    public Interessenten findById(int id) throws SQLException {
        String sql = "SELECT MitgliederID, Vorname, Nachname, Telefon FROM Mitglieder WHERE MitgliederID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            rs = ps.executeQuery();
            if (rs.next()) {
                return new Interessenten(
                    rs.getInt("MitgliederID"),
                    rs.getString("Vorname"),
                    rs.getString("Nachname"),
                    rs.getString("Telefon")
                );
            }
        } finally {
            closeResources(rs, ps);
        }
        return null;
    }

    // Override
    @Override
    public void insert(Interessenten entity) throws SQLException {
        String sql = "INSERT INTO Mitglieder (Vorname, Nachname, Telefon) VALUES (?, ?, ?)";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, entity.getVorname());
            ps.setString(2, entity.getNachname());
            ps.setString(3, entity.getTelefon());
            ps.executeUpdate();
            ResultSet keys = ps.getGeneratedKeys();
            if (keys.next()) {
                entity.setMitgliederID(keys.getInt(1));
            }
        } finally {
            closeResources(null, ps);
        }
    }

    // Override
    @Override
    public void update(Interessenten entity) throws SQLException {
        String sql = "UPDATE Mitglieder SET Vorname = ?, Nachname = ?, Telefon = ? WHERE MitgliederID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setString(1, entity.getVorname());
            ps.setString(2, entity.getNachname());
            ps.setString(3, entity.getTelefon());
            ps.setInt(4, entity.getMitgliederID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    // Override
    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Mitglieder WHERE MitgliederID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }
}

----- Inhalt von: IntervallDAO.txt -----
package DAOs;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import Objekte.Intervall;

public class IntervallDAO extends BaseDAO<Intervall> {

    public IntervallDAO(Connection connection) {
        super(connection);
    }

    @Override
    public void insert(Intervall i) throws SQLException {
        String sql = "INSERT INTO Intervall (Zahlungsintervall, Bezeichnung) VALUES (?, ?)";
        try (PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            ps.setString(1, i.getZahlungsintervall());
            ps.setString(2, i.getBezeichnung());
            ps.executeUpdate();
            ResultSet rs = ps.getGeneratedKeys();
            if (rs.next()) {
                i.setIntervallID(rs.getInt(1));
            }
        }
    }

    @Override
    public Intervall findById(int id) throws SQLException {
        String sql = "SELECT IntervallID, Zahlungsintervall, Bezeichnung FROM Intervall WHERE IntervallID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, id);
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToIntervall(rs);
            }
        }
        return null;
    }

    @Override
    public void update(Intervall i) throws SQLException {
        String sql = "UPDATE Intervall SET Zahlungsintervall=?, Bezeichnung=? WHERE IntervallID=?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setString(1, i.getZahlungsintervall());
            ps.setString(2, i.getBezeichnung());
            ps.setInt(3, i.getIntervallID());
            ps.executeUpdate();
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Intervall WHERE IntervallID=?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, id);
            ps.executeUpdate();
        }
    }

    public List<Intervall> findAll() throws SQLException {
        String sql = "SELECT IntervallID, Zahlungsintervall, Bezeichnung FROM Intervall";
        List<Intervall> list = new ArrayList<>();
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToIntervall(rs));
            }
        }
        return list;
    }
    
    public List<Intervall> searchAllAttributes(String searchTerm) throws SQLException {
        List<Intervall> result = new ArrayList<>();
        String sql = "SELECT * FROM Intervall WHERE " +
                     "CAST(IntervallID AS CHAR) LIKE ? OR " +
                     "LOWER(Bezeichnung) LIKE ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            String like = "%" + searchTerm.toLowerCase() + "%";
            ps.setString(1, like);
            ps.setString(2, like);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    result.add(mapRowToIntervall(rs));
                }
            }
        }
        return result;
    }

    
    private Intervall mapRowToIntervall(ResultSet rs) throws SQLException {
        return new Intervall(
            rs.getInt("IntervallID"),
            rs.getString("Zahlungsintervall"),
            rs.getString("Bezeichnung")
        );
    }
}

----- Inhalt von: KategorieDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import Objekte.Kategorie;

public class KategorieDAO extends BaseDAO<Kategorie> {
    public KategorieDAO(Connection connection) {
        super(connection);
    }

    @Override
    public void insert(Kategorie kategorie) throws SQLException {
        String sql = "INSERT INTO Kategorie (Bezeichnung) VALUES (?)";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, kategorie.getBezeichnung());
            ps.executeUpdate();
            rs = ps.getGeneratedKeys();
            if (rs.next()) {
                kategorie.setKategorieID(rs.getInt(1));
            }
        } finally {
            closeResources(rs, ps);
        }
    }

    @Override
    public Kategorie findById(int id) throws SQLException {
        String sql = "SELECT KategorieID, Bezeichnung FROM Kategorie WHERE KategorieID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToKategorie(rs);
            }
        } finally {
            closeResources(rs, ps);
        }
        return null;
    }

    @Override
    public void update(Kategorie kategorie) throws SQLException {
        String sql = "UPDATE Kategorie SET Bezeichnung = ? WHERE KategorieID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setString(1, kategorie.getBezeichnung());
            ps.setInt(2, kategorie.getKategorieID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Kategorie WHERE KategorieID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    public List<Kategorie> findAll() throws SQLException {
        String sql = "SELECT KategorieID, Bezeichnung FROM Kategorie";
        List<Kategorie> list = new ArrayList<>();
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToKategorie(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return list;
    }

    private Kategorie mapRowToKategorie(ResultSet rs) throws SQLException {
        Kategorie kategorie = new Kategorie();
        kategorie.setKategorieID(rs.getInt("KategorieID"));
        kategorie.setBezeichnung(rs.getString("Bezeichnung"));
        return kategorie;
    }
}

----- Inhalt von: KursDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Kurs;

public class KursDAO extends BaseDAO<Kurs> {

    public KursDAO(Connection connection) {
        super(connection);
    }

    @Override
    public Kurs findById(int id) throws SQLException, IntException, NotFoundException {
        String sql = "SELECT KursID, Bezeichnung, Kostenfrei, Aktiv, Teilnehmerzahl, AnzahlTermine, Preis, Kommentar FROM Kurs WHERE KursID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToKurs(rs);
            }
        } finally {
            closeResources(rs, ps);
        }
        return null;
    }

    @Override
    public void insert(Kurs entity) throws SQLException {
        String sql = "INSERT INTO Kurs (Bezeichnung, Kostenfrei, Aktiv, Teilnehmerzahl, AnzahlTermine, Preis, Kommentar) VALUES (?, ?, ?, ?, ?, ?, ?)";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql, java.sql.Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, entity.getBezeichnung());
            ps.setBoolean(2, entity.isKostenfrei());
            ps.setBoolean(3, entity.isAktiv());
            ps.setInt(4, entity.getTeilnehmerzahl());
            ps.setInt(5, entity.getAnzahlTermine());
            ps.setDouble(6, entity.getPreis());
            ps.setString(7, entity.getKommentar());
            ps.executeUpdate();

            rs = ps.getGeneratedKeys();
            if (rs.next()) {
                entity.setKursID(rs.getInt(1));
            }
        } finally {
            closeResources(rs, ps);
        }
    }

    @Override
    public void update(Kurs entity) throws SQLException {
        String sql = "UPDATE Kurs SET Bezeichnung = ?, Kostenfrei = ?, Aktiv = ?, Teilnehmerzahl = ?, AnzahlTermine = ?, Preis = ?, Kommentar = ? WHERE KursID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setString(1, entity.getBezeichnung());
            ps.setBoolean(2, entity.isKostenfrei());
            ps.setBoolean(3, entity.isAktiv());
            ps.setInt(4, entity.getTeilnehmerzahl());
            ps.setInt(5, entity.getAnzahlTermine());
            ps.setDouble(6, entity.getPreis());
            ps.setString(7, entity.getKommentar());
            ps.setInt(8, entity.getKursID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Kurs WHERE KursID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    public List<Kurs> findAll() throws SQLException {
        List<Kurs> kurse = new ArrayList<>();
        String sql = "SELECT KursID, Bezeichnung, Kostenfrei, Aktiv, Teilnehmerzahl, AnzahlTermine, Preis, Kommentar FROM Kurs";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            rs = ps.executeQuery();
            while (rs.next()) {
                kurse.add(mapRowToKurs(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return kurse;
    }

    public List<Kurs> searchAllAttributes(String searchTerm) throws SQLException {
        List<Kurs> results = new ArrayList<>();
        String sql = "SELECT KursID, Bezeichnung, Kostenfrei, Aktiv, Teilnehmerzahl, AnzahlTermine, Preis, Kommentar FROM Kurs " +
                     "WHERE Bezeichnung LIKE ? OR Kommentar LIKE ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            String pattern = "%" + searchTerm + "%";
            ps.setString(1, pattern);
            ps.setString(2, pattern);
            rs = ps.executeQuery();
            while (rs.next()) {
                results.add(mapRowToKurs(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return results;
    }

    private Kurs mapRowToKurs(ResultSet rs) throws SQLException {
        Kurs kurs = new Kurs();
        kurs.setKursID(rs.getInt("KursID"));
        kurs.setBezeichnung(rs.getString("Bezeichnung"));
        kurs.setKostenfrei(rs.getBoolean("Kostenfrei"));
        kurs.setAktiv(rs.getBoolean("Aktiv"));
        kurs.setTeilnehmerzahl(rs.getInt("Teilnehmerzahl"));
        kurs.setAnzahlTermine(rs.getInt("AnzahlTermine"));
        kurs.setPreis(rs.getDouble("Preis"));
        kurs.setKommentar(rs.getString("Kommentar"));
        return kurs;
    }
}

----- Inhalt von: KursleitungDAO.txt -----
package DAOs;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import Objekte.Kursleitung;

public class KursleitungDAO extends BaseDAO<Kursleitung> {

    public KursleitungDAO(Connection connection) {
        super(connection);
    }

    @Override
    public void insert(Kursleitung kursleitung) throws SQLException {
        String sql = "INSERT INTO Kursleitung (KursterminID, MitarbeiterID, Bestätigt, Bestätigungszeit, Abgemeldet, Abmeldezeit, Aktiv, Kommentar) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, kursleitung.getKursterminID());
            ps.setInt(2, kursleitung.getMitarbeiterID());
            ps.setBoolean(3, kursleitung.isBestätigt());
            ps.setTimestamp(4, kursleitung.getBestätigungszeit());
            ps.setBoolean(5, kursleitung.isAbgemeldet());
            ps.setTimestamp(6, kursleitung.getAbmeldezeit());
            ps.setBoolean(7, kursleitung.isAktiv());
            ps.setString(8, kursleitung.getKommentar());
            ps.executeUpdate();
        }
    }

    @Override
    public Kursleitung findById(int kursterminID) throws SQLException {
        String sql = "SELECT * FROM Kursleitung WHERE KursterminID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, kursterminID);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return mapRowToKursleitung(rs);
                }
            }
        }
        return null;
    }

    @Override
    public void update(Kursleitung kursleitung) throws SQLException {
        String sql = "UPDATE Kursleitung SET MitarbeiterID = ?, Bestätigt = ?, Bestätigungszeit = ?, Abgemeldet = ?, Abmeldezeit = ?, Aktiv = ?, Kommentar = ? WHERE KursterminID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, kursleitung.getMitarbeiterID());
            ps.setBoolean(2, kursleitung.isBestätigt());
            ps.setTimestamp(3, kursleitung.getBestätigungszeit());
            ps.setBoolean(4, kursleitung.isAbgemeldet());
            ps.setTimestamp(5, kursleitung.getAbmeldezeit());
            ps.setBoolean(6, kursleitung.isAktiv());
            ps.setString(7, kursleitung.getKommentar());
            ps.setInt(8, kursleitung.getKursterminID());
            ps.executeUpdate();
        }
    }

    @Override
    public void delete(int kursterminID) throws SQLException {
        String sql = "DELETE FROM Kursleitung WHERE KursterminID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, kursterminID);
            ps.executeUpdate();
        }
    }

    public List<Kursleitung> findAll() throws SQLException {
        List<Kursleitung> leitungen = new ArrayList<>();
        String sql = "SELECT * FROM Kursleitung";
        try (PreparedStatement ps = connection.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {
            while (rs.next()) {
                leitungen.add(mapRowToKursleitung(rs));
            }
        }
        return leitungen;
    }

    public List<Kursleitung> findByKursterminId(int kursterminID) throws SQLException {
        List<Kursleitung> leitungen = new ArrayList<>();
        String sql = "SELECT * FROM Kursleitung WHERE KursterminID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, kursterminID);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    leitungen.add(mapRowToKursleitung(rs));
                }
            }
        }
        return leitungen;
    }

    public List<Kursleitung> findAktiveLeitungByKursterminId(int kursterminID) throws SQLException {
        List<Kursleitung> leitungen = new ArrayList<>();
        String sql = "SELECT * FROM Kursleitung WHERE KursterminID = ? AND Aktiv = TRUE";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, kursterminID);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    leitungen.add(mapRowToKursleitung(rs));
                }
            }
        }
        return leitungen;
    }

    public List<Kursleitung> searchAllAttributes(String searchTerm) throws SQLException {
        List<Kursleitung> results = new ArrayList<>();
        String sql = "SELECT * FROM Kursleitung WHERE " +
                "CAST(KursterminID AS CHAR) LIKE ? OR " +
                "CAST(MitarbeiterID AS CHAR) LIKE ? OR " +
                "LOWER(Kommentar) LIKE ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            String pattern = "%" + searchTerm.toLowerCase() + "%";
            ps.setString(1, pattern);
            ps.setString(2, pattern);
            ps.setString(3, pattern);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    results.add(mapRowToKursleitung(rs));
                }
            }
        }
        return results;
    }

    private Kursleitung mapRowToKursleitung(ResultSet rs) throws SQLException {
        Kursleitung kursleitung = new Kursleitung();
        kursleitung.setKursterminID(rs.getInt("KursterminID"));
        kursleitung.setMitarbeiterID(rs.getInt("MitarbeiterID"));
        kursleitung.setBestätigt(rs.getBoolean("Bestätigt"));
        kursleitung.setBestätigungszeit(rs.getTimestamp("Bestätigungszeit"));
        kursleitung.setAbgemeldet(rs.getBoolean("Abgemeldet"));
        kursleitung.setAbmeldezeit(rs.getTimestamp("Abmeldezeit"));
        kursleitung.setAktiv(rs.getBoolean("Aktiv"));
        kursleitung.setKommentar(rs.getString("Kommentar"));
        return kursleitung;
    }
}

----- Inhalt von: KursteilnahmeDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Kursteilnahme;

public class KursteilnahmeDAO extends BaseDAO<Kursteilnahme> {

    public KursteilnahmeDAO(Connection connection) {
        super(connection);
    }

    /**
     * Findet eine Kursteilnahme anhand des zusammengesetzten Primärschlüssels
     * (MitgliederID + KursterminID)
     */
    @Override
    public Kursteilnahme findById(int id) throws SQLException, IntException, NotFoundException {
        throw new UnsupportedOperationException(
            "Use findByCompositeKey(mitgliederID, kursterminID) instead - no single ID primary key exists");
    }

    /**
     * Findet eine Kursteilnahme anhand des zusammengesetzten Primärschlüssels
     */
    public Kursteilnahme findByCompositeKey(int mitgliederID, int kursterminID) 
            throws SQLException, NotFoundException {
        String sql = "SELECT MitgliederID, KursterminID, Angemeldet, Anmeldezeit, "
                + "Abgemeldet, Abmeldezeit, Aktiv, Kommentar "
                + "FROM Kursteilnahme WHERE MitgliederID = ? AND KursterminID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, mitgliederID);
            ps.setInt(2, kursterminID);
            rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToKursteilnahme(rs);
            }
            throw new NotFoundException(
                "Kursteilnahme nicht gefunden: MitgliederID=" + mitgliederID 
                + ", KursterminID=" + kursterminID);
        } finally {
            closeResources(rs, ps);
        }
    }

    @Override
    public void insert(Kursteilnahme entity) throws SQLException {
        String sql = "INSERT INTO Kursteilnahme "
                + "(MitgliederID, KursterminID, Angemeldet, Anmeldezeit, Abgemeldet, Abmeldezeit, Aktiv, Kommentar) "
                + "VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, entity.getMitgliederID());
            ps.setInt(2, entity.getKursterminID());
            ps.setBoolean(3, entity.isAngemeldet());
            ps.setTimestamp(4, entity.getAnmeldezeit());
            ps.setBoolean(5, entity.isAbgemeldet());
            ps.setTimestamp(6, entity.getAbmeldezeit());
            ps.setBoolean(7, entity.isAktiv());
            ps.setString(8, entity.getKommentar());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public void update(Kursteilnahme entity) throws SQLException {
        String sql = "UPDATE Kursteilnahme SET Angemeldet = ?, Anmeldezeit = ?, Abgemeldet = ?, "
                + "Abmeldezeit = ?, Aktiv = ?, Kommentar = ? "
                + "WHERE MitgliederID = ? AND KursterminID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setBoolean(1, entity.isAngemeldet());
            ps.setTimestamp(2, entity.getAnmeldezeit());
            ps.setBoolean(3, entity.isAbgemeldet());
            ps.setTimestamp(4, entity.getAbmeldezeit());
            ps.setBoolean(5, entity.isAktiv());
            ps.setString(6, entity.getKommentar());
            ps.setInt(7, entity.getMitgliederID());
            ps.setInt(8, entity.getKursterminID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        throw new UnsupportedOperationException(
            "Use deleteByCompositeKey(mitgliederID, kursterminID) instead - no single ID primary key exists");
    }

    /**
     * Löscht eine Kursteilnahme anhand des zusammengesetzten Primärschlüssels
     */
    public void deleteByCompositeKey(int mitgliederID, int kursterminID) throws SQLException {
        String sql = "DELETE FROM Kursteilnahme WHERE MitgliederID = ? AND KursterminID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, mitgliederID);
            ps.setInt(2, kursterminID);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    public List<Kursteilnahme> findAll() throws SQLException {
        List<Kursteilnahme> teilnahmen = new ArrayList<>();
        String sql = "SELECT MitgliederID, KursterminID, Angemeldet, Anmeldezeit, "
                + "Abgemeldet, Abmeldezeit, Aktiv, Kommentar FROM Kursteilnahme";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            rs = ps.executeQuery();
            while (rs.next()) {
                teilnahmen.add(mapRowToKursteilnahme(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return teilnahmen;
    }

    public List<Kursteilnahme> findByMitgliederId(int mitgliederID) throws SQLException {
        List<Kursteilnahme> teilnahmen = new ArrayList<>();
        String sql = "SELECT MitgliederID, KursterminID, Angemeldet, Anmeldezeit, "
                + "Abgemeldet, Abmeldezeit, Aktiv, Kommentar "
                + "FROM Kursteilnahme WHERE MitgliederID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, mitgliederID);
            rs = ps.executeQuery();
            while (rs.next()) {
                teilnahmen.add(mapRowToKursteilnahme(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return teilnahmen;
    }

    public List<Kursteilnahme> findByKursterminId(int kursterminID) throws SQLException {
        List<Kursteilnahme> teilnahmen = new ArrayList<>();
        String sql = "SELECT MitgliederID, KursterminID, Angemeldet, Anmeldezeit, "
                + "Abgemeldet, Abmeldezeit, Aktiv, Kommentar "
                + "FROM Kursteilnahme WHERE KursterminID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, kursterminID);
            rs = ps.executeQuery();
            while (rs.next()) {
                teilnahmen.add(mapRowToKursteilnahme(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return teilnahmen;
    }

    public List<Kursteilnahme> searchAllAttributes(String searchTerm) throws SQLException {
        List<Kursteilnahme> results = new ArrayList<>();

        String sql = "SELECT MitgliederID, KursterminID, Angemeldet, Anmeldezeit, "
                + "Abgemeldet, Abmeldezeit, Aktiv, Kommentar "
                + "FROM Kursteilnahme "
                + "WHERE CAST(MitgliederID AS CHAR) LIKE ? "
                + "OR CAST(KursterminID AS CHAR) LIKE ? "
                + "OR CAST(Anmeldezeit AS CHAR) LIKE ? "
                + "OR CAST(Abmeldezeit AS CHAR) LIKE ? "
                + "OR Kommentar LIKE ?";

        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            String searchPattern = "%" + searchTerm + "%";
            pstmt.setString(1, searchPattern);
            pstmt.setString(2, searchPattern);
            pstmt.setString(3, searchPattern);
            pstmt.setString(4, searchPattern);
            pstmt.setString(5, searchPattern);

            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                results.add(mapRowToKursteilnahme(rs));
            }
        }

        return results;
    }

    private Kursteilnahme mapRowToKursteilnahme(ResultSet rs) throws SQLException {
        Kursteilnahme teilnahme = new Kursteilnahme();
        teilnahme.setMitgliederID(rs.getInt("MitgliederID"));
        teilnahme.setKursterminID(rs.getInt("KursterminID"));
        teilnahme.setAngemeldet(rs.getBoolean("Angemeldet"));
        teilnahme.setAnmeldezeit(rs.getTimestamp("Anmeldezeit"));
        teilnahme.setAbgemeldet(rs.getBoolean("Abgemeldet"));
        teilnahme.setAbmeldezeit(rs.getTimestamp("Abmeldezeit"));
        teilnahme.setAktiv(rs.getBoolean("Aktiv"));
        teilnahme.setKommentar(rs.getString("Kommentar"));
        return teilnahme;
    }
}

----- Inhalt von: KursterminDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Kurstermin;

public class KursterminDAO extends BaseDAO<Kurstermin> {

    public KursterminDAO(Connection connection) {
        super(connection);
    }

    @Override
    public Kurstermin findById(int id) throws SQLException, IntException, NotFoundException {
        String sql = "SELECT KursterminID, KursID, Termin, Teilnehmerfrei, Anmeldebar, Aktiv, Kommentar FROM Kurstermin WHERE KursterminID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToKurstermin(rs);
            }
        } finally {
            closeResources(rs, ps);
        }
        return null;
    }

    @Override
    public void insert(Kurstermin entity) throws SQLException {
        String sql = "INSERT INTO Kurstermin (KursID, Termin, Teilnehmerfrei, Anmeldebar, Aktiv, Kommentar) VALUES (?, ?, ?, ?, ?, ?)";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql, java.sql.Statement.RETURN_GENERATED_KEYS);
            ps.setInt(1, entity.getKursID());
            ps.setTimestamp(2, entity.getTermin());
            ps.setInt(3, entity.getTeilnehmerfrei());
            ps.setBoolean(4, entity.isAnmeldebar());
            ps.setBoolean(5, entity.isAktiv());
            ps.setString(6, entity.getKommentar());
            ps.executeUpdate();

            rs = ps.getGeneratedKeys();
            if (rs.next()) {
                entity.setKursterminID(rs.getInt(1));
            }
        } finally {
            closeResources(rs, ps);
        }
    }

    @Override
    public void update(Kurstermin entity) throws SQLException {
        String sql = "UPDATE Kurstermin SET KursID = ?, Termin = ?, Teilnehmerfrei = ?, Anmeldebar = ?, Aktiv = ?, Kommentar = ? WHERE KursterminID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, entity.getKursID());
            ps.setTimestamp(2, entity.getTermin());
            ps.setInt(3, entity.getTeilnehmerfrei());
            ps.setBoolean(4, entity.isAnmeldebar());
            ps.setBoolean(5, entity.isAktiv());
            ps.setString(6, entity.getKommentar());
            ps.setInt(7, entity.getKursterminID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Kurstermin WHERE KursterminID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    public List<Kurstermin> findAll() throws SQLException {
        List<Kurstermin> termine = new ArrayList<>();
        String sql = "SELECT KursterminID, KursID, Termin, Teilnehmerfrei, Anmeldebar, Aktiv, Kommentar FROM Kurstermin";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            rs = ps.executeQuery();
            while (rs.next()) {
                termine.add(mapRowToKurstermin(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return termine;
    }

    public List<Kurstermin> findByKursId(int kursID) throws SQLException {
        List<Kurstermin> termine = new ArrayList<>();
        String sql = "SELECT KursterminID, KursID, Termin, Teilnehmerfrei, Anmeldebar, Aktiv, Kommentar FROM Kurstermin WHERE KursID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, kursID);
            rs = ps.executeQuery();
            while (rs.next()) {
                termine.add(mapRowToKurstermin(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return termine;
    }

    public List<Kurstermin> searchAllAttributes(String searchTerm) throws SQLException {
        List<Kurstermin> results = new ArrayList<>();
        String sql = "SELECT KursterminID, KursID, Termin, Teilnehmerfrei, Anmeldebar, Aktiv, Kommentar FROM Kurstermin WHERE " + 
                     "CAST(KursterminID AS CHAR) LIKE ? OR CAST(KursID AS CHAR) LIKE ? OR " + 
                     "CAST(Termin AS CHAR) LIKE ? OR CAST(Teilnehmerfrei AS CHAR) LIKE ? OR " + 
                     "CAST(Anmeldebar AS CHAR) LIKE ? OR CAST(Aktiv AS CHAR) LIKE ? OR LOWER(Kommentar) LIKE ?";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            String like = "%" + searchTerm.toLowerCase() + "%";
            pstmt.setString(1, like);
            pstmt.setString(2, like);
            pstmt.setString(3, like);
            pstmt.setString(4, like);
            pstmt.setString(5, like);
            pstmt.setString(6, like);
            pstmt.setString(7, like);
            ResultSet rs = pstmt.executeQuery();
            while (rs.next()) {
                results.add(mapRowToKurstermin(rs));
            }
        }
        return results;
    }

    private Kurstermin mapRowToKurstermin(ResultSet rs) throws SQLException {
        Kurstermin termin = new Kurstermin();
        termin.setKursterminID(rs.getInt("KursterminID"));
        termin.setKursID(rs.getInt("KursID"));
        termin.setTermin(rs.getTimestamp("Termin"));
        termin.setTeilnehmerfrei(rs.getInt("Teilnehmerfrei"));
        termin.setAnmeldebar(rs.getBoolean("Anmeldebar"));
        termin.setAktiv(rs.getBoolean("Aktiv"));
        termin.setKommentar(rs.getString("Kommentar"));
        return termin;
    }
}

----- Inhalt von: MitarbeiterDAO.txt -----
package DAOs;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import Objekte.Benutzer;
import Objekte.Mitarbeiter;
import Objekte.Ort;
import Objekte.Zahlungsdaten;

public class MitarbeiterDAO extends BaseDAO<Mitarbeiter> {

	private final OrtDAO ortDAO;
	private final ZahlungsdatenDAO zahlungsdatenDAO;
	private final BenutzerDAO benutzerDAO;

	public MitarbeiterDAO(Connection connection) {
		super(connection);
		this.ortDAO = new OrtDAO(connection);
		this.zahlungsdatenDAO = new ZahlungsdatenDAO(connection);
		this.benutzerDAO = new BenutzerDAO(connection);
	}

	@Override
	public void insert(Mitarbeiter mitarbeiter) throws SQLException {
		String sql = "INSERT INTO Mitarbeiter (Vorname, Nachname, Geburtsdatum, Straße, Hausnr, OrtID, ZahlungsdatenID, Mail, BenutzerID) "
				+ "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, mitarbeiter.getVorname());
			ps.setString(2, mitarbeiter.getNachname());
			ps.setString(3, mitarbeiter.getGeburtsdatum());
			ps.setString(4, mitarbeiter.getStraße());
			ps.setString(5, mitarbeiter.getHausnr());
			ps.setInt(6, mitarbeiter.getOrt() != null ? mitarbeiter.getOrt().getOrtID() : 0);
			ps.setInt(7,
					mitarbeiter.getZahlungsdaten() != null ? mitarbeiter.getZahlungsdaten().getZahlungsdatenID() : 0);
			ps.setString(8, mitarbeiter.getMail());
			ps.setInt(9, mitarbeiter.getBenutzer() != null ? mitarbeiter.getBenutzer().getBenutzerID() : 0);
			ps.executeUpdate();

			rs = ps.getGeneratedKeys();
			if (rs.next()) {
				mitarbeiter.setMitarbeiterID(rs.getInt(1));
			}
		} finally {
			closeResources(rs, ps);
		}
	}

	@Override
	public Mitarbeiter findById(int id) throws SQLException {
		String sql = "SELECT * FROM Mitarbeiter WHERE MitarbeiterID = ?";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setInt(1, id);
			rs = ps.executeQuery();
			if (rs.next()) {
				return mapRowToMitarbeiter(rs);
			}
		} finally {
			closeResources(rs, ps);
		}
		return null;
	}

	@Override
	public void update(Mitarbeiter mitarbeiter) throws SQLException {
		String sql = "UPDATE Mitarbeiter SET Vorname=?, Nachname=?, Geburtsdatum=?, Straße=?, Hausnr=?, OrtID=?, ZahlungsdatenID=?, Mail=?, BenutzerID=? WHERE MitarbeiterID=?";
		PreparedStatement ps = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setString(1, mitarbeiter.getVorname());
			ps.setString(2, mitarbeiter.getNachname());
			ps.setString(3, mitarbeiter.getGeburtsdatum());
			ps.setString(4, mitarbeiter.getStraße());
			ps.setString(5, mitarbeiter.getHausnr());
			ps.setInt(6, mitarbeiter.getOrt() != null ? mitarbeiter.getOrt().getOrtID() : 0);
			ps.setInt(7,
					mitarbeiter.getZahlungsdaten() != null ? mitarbeiter.getZahlungsdaten().getZahlungsdatenID() : 0);
			ps.setString(8, mitarbeiter.getMail());
			ps.setInt(9, mitarbeiter.getBenutzer() != null ? mitarbeiter.getBenutzer().getBenutzerID() : 0);
			ps.setInt(10, mitarbeiter.getMitarbeiterID());
			ps.executeUpdate();
		} finally {
			closeResources(null, ps);
		}
	}

	@Override
	public void delete(int id) throws SQLException {
		String sql = "DELETE FROM Mitarbeiter WHERE MitarbeiterID = ?";
		PreparedStatement ps = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setInt(1, id);
			ps.executeUpdate();
		} finally {
			closeResources(null, ps);
		}
	}

	public List<Mitarbeiter> findAll() throws SQLException {
		String sql = "SELECT * FROM Mitarbeiter";
		List<Mitarbeiter> list = new ArrayList<>();
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				list.add(mapRowToMitarbeiter(rs));
			}
		} finally {
			closeResources(rs, ps);
		}
		return list;
	}

	public List<Mitarbeiter> searchAllAttributes(String searchTerm) throws SQLException {
		List<Mitarbeiter> result = new ArrayList<>();
		String sql = "SELECT * FROM Mitarbeiter WHERE " + "LOWER(Vorname) LIKE ? OR LOWER(Nachname) LIKE ? "
				+ "OR CAST(MitarbeiterID AS CHAR) LIKE ? " + "OR LOWER(Mail) LIKE ?";
		try (PreparedStatement ps = connection.prepareStatement(sql)) {
			String like = "%" + searchTerm.toLowerCase() + "%";
			ps.setString(1, like);
			ps.setString(2, like);
			ps.setString(3, like);
			ps.setString(4, like);
			ResultSet rs = ps.executeQuery();
			while (rs.next()) {
				result.add(mapRowToMitarbeiter(rs));
			}
		}
		return result;
	}

	public List<Mitarbeiter> findByOrtId(int ortId) throws SQLException {
		List<Mitarbeiter> result = new ArrayList<>();
		String query = "SELECT * FROM Mitarbeiter WHERE OrtID = ?";
		try (PreparedStatement stmt = connection.prepareStatement(query)) {
			stmt.setInt(1, ortId);
			try (ResultSet rs = stmt.executeQuery()) {
				while (rs.next()) {
					result.add(mapRowToMitarbeiter(rs));
				}
			}
		}
		return result;
	}

	public List<Mitarbeiter> findByZahlungsdatenId(int zahlungsdatenId) throws SQLException {
		List<Mitarbeiter> result = new ArrayList<>();
		String query = "SELECT * FROM Mitarbeiter WHERE ZahlungsdatenID = ?";
		try (PreparedStatement stmt = connection.prepareStatement(query)) {
			stmt.setInt(1, zahlungsdatenId);
			try (ResultSet rs = stmt.executeQuery()) {
				while (rs.next()) {
					result.add(mapRowToMitarbeiter(rs));
				}
			}
		}
		return result;
	}

	public List<Mitarbeiter> findByBenutzerId(int benutzerId) throws SQLException {
		List<Mitarbeiter> result = new ArrayList<>();
		String query = "SELECT * FROM Mitarbeiter WHERE BenutzerID = ?";
		try (PreparedStatement stmt = connection.prepareStatement(query)) {
			stmt.setInt(1, benutzerId);
			try (ResultSet rs = stmt.executeQuery()) {
				while (rs.next()) {
					result.add(mapRowToMitarbeiter(rs));
				}
			}
		}
		return result;
	}

	public List<Mitarbeiter> findByRolleId(int rolleId) throws SQLException {
		List<Mitarbeiter> result = new ArrayList<>();
		String query = "SELECT m.* FROM Mitarbeiter m JOIN Benutzer b ON m.BenutzerID = b.BenutzerID WHERE b.RolleID = ?";
		try (PreparedStatement stmt = connection.prepareStatement(query)) {
			stmt.setInt(1, rolleId);
			try (ResultSet rs = stmt.executeQuery()) {
				while (rs.next()) {
					result.add(mapRowToMitarbeiter(rs));
				}
			}
		}
		return result;
	}

	/**
	 * Hilfsmethode zum Zuordnen einer Datenbankzeile zum Mitarbeiter-Objekt
	 */

	private Mitarbeiter mapRowToMitarbeiter(ResultSet rs) throws SQLException {
		Mitarbeiter mitarbeiter = new Mitarbeiter();
		mitarbeiter.setMitarbeiterID(rs.getInt("MitarbeiterID"));
		mitarbeiter.setVorname(rs.getString("Vorname"));
		mitarbeiter.setNachname(rs.getString("Nachname"));
		mitarbeiter.setGeburtsdatum(rs.getString("Geburtsdatum"));
		mitarbeiter.setStraße(rs.getString("Straße"));
		mitarbeiter.setHausnr(rs.getString("Hausnr"));
		mitarbeiter.setAktiv(rs.getInt("Aktiv") == 1);
		// Ort über OrtID holen
		int ortID = rs.getInt("OrtID");
		Ort ort = null;
		try {
			ort = ortID > 0 ? ortDAO.findById(ortID) : null;
		} catch (Exception ex) {
			ort = null;
		}
		mitarbeiter.setOrt(ort);

		// Zahlungsdaten und Benutzer
		int zahlungsdatenID = rs.getInt("ZahlungsdatenID");
		mitarbeiter.setTelefon(rs.getString("Telefon"));
		int benutzerID = rs.getInt("BenutzerID");
		Zahlungsdaten zahlungsdaten = null;
		Benutzer benutzer = null;
		try {
			zahlungsdaten = zahlungsdatenID > 0 ? zahlungsdatenDAO.findById(zahlungsdatenID) : null;
		} catch (Exception ex) {
			zahlungsdaten = null;
		}
		try {
			benutzer = benutzerID > 0 ? benutzerDAO.findById(benutzerID) : null;
		} catch (Exception ex) {
			benutzer = null;
		}
		mitarbeiter.setZahlungsdaten(zahlungsdaten);
		mitarbeiter.setBenutzer(benutzer);

		mitarbeiter.setMail(rs.getString("Mail"));
		return mitarbeiter;
	}
}

----- Inhalt von: MitgliederDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Mitglieder;
import Objekte.Ort;
import Objekte.Zahlungsdaten;

import java.sql.Date;

public class MitgliederDAO extends BaseDAO<Mitglieder> {

	private final OrtDAO ortDAO;
	private final ZahlungsdatenDAO zahlungsdatenDAO;

	public MitgliederDAO(Connection connection) {
		super(connection);
		ortDAO = new OrtDAO(connection);
		zahlungsdatenDAO = new ZahlungsdatenDAO(connection);
	}

	public List<Mitglieder> searchAllAttributes(String searchTerm) throws SQLException {
		List<Mitglieder> results = new ArrayList<>();
		String sql = "SELECT m.MitgliederID, m.Vorname, m.Nachname, m.Geburtsdatum, m.Aktiv, m.Straße, m.Hausnr, "
				+ "m.OrtID, o.PLZ, o.Ort, m.ZahlungsdatenID, m.Telefon, m.Mail " + "FROM Mitglieder AS m "
				+ "LEFT JOIN Ort AS o ON o.OrtID = m.OrtID "
				+ "WHERE Vorname LIKE ? OR Nachname LIKE ? OR Mail LIKE ? OR Telefon LIKE ?";
		try (PreparedStatement stmt = connection.prepareStatement(sql)) {
			String pattern = "%" + searchTerm + "%";
			for (int i = 1; i <= 4; i++) {
				stmt.setString(i, pattern);
			}
			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				Mitglieder m = mapRowToMitglieder(rs);
				results.add(m);
			}
		}
		return results;
	}

	public List<Mitglieder> searchByName(String vorname, String nachname) throws SQLException {
		String sql = "SELECT m.MitgliederID, m.Vorname, m.Nachname, m.Geburtsdatum, m.Aktiv, m.Straße, m.Hausnr, m.OrtID, o.PLZ, o.Ort, m.ZahlungsdatenID, m.Telefon,"
				+ "m.Mail FROM Mitglieder WHERE LOWER(Vorname) LIKE ? AND LOWER(Nachname) LIKE ?";
		List<Mitglieder> result = new ArrayList<>();
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setString(1, "%" + vorname.toLowerCase() + "%");
			ps.setString(2, "%" + nachname.toLowerCase() + "%");
			rs = ps.executeQuery();
			while (rs.next()) {
				result.add(mapRowToMitglieder(rs));
			}
		} finally {
			closeResources(rs, ps);
		}
		return result;
	}

	public List<Mitglieder> findByOrtId(int ortId) throws SQLException {
		List<Mitglieder> results = new ArrayList<>();
		String sql = "SELECT m.MitgliederID, m.Vorname, m.Nachname, m.Geburtsdatum, m.Aktiv, m.Straße, m.Hausnr, "
				+ "m.OrtID, o.PLZ, o.Ort, m.ZahlungsdatenID, m.Telefon, m.Mail " + "FROM Mitglieder AS m "
				+ "LEFT JOIN Ort AS o ON o.OrtID = m.OrtID " + "WHERE m.OrtID = ?";
		try (PreparedStatement stmt = connection.prepareStatement(sql)) {
			stmt.setInt(1, ortId);
			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				Mitglieder m = mapRowToMitglieder(rs);
				results.add(m);
			}
		}
		return results;
	}

	public List<Mitglieder> findByZahlungsdatenId(int zahlungsdatenId) throws SQLException {
		List<Mitglieder> results = new ArrayList<>();
		String sql = "SELECT m.MitgliederID, m.Vorname, m.Nachname, m.Geburtsdatum, m.Aktiv, m.Straße, m.Hausnr, "
				+ "m.OrtID, o.PLZ, o.Ort, m.ZahlungsdatenID, m.Telefon, m.Mail " + "FROM Mitglieder AS m "
				+ "LEFT JOIN Ort AS o ON o.OrtID = m.OrtID " + "WHERE m.ZahlungsdatenID = ?";
		try (PreparedStatement stmt = connection.prepareStatement(sql)) {
			stmt.setInt(1, zahlungsdatenId);
			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				Mitglieder m = mapRowToMitglieder(rs);
				results.add(m);
			}
		}
		return results;
	}

	public List<Mitglieder> findByInteressentenId(int mitgliederID) throws SQLException {
		List<Mitglieder> results = new ArrayList<>();
		String sql = "SELECT m.MitgliederID, m.Vorname, m.Nachname, m.Geburtsdatum, m.Aktiv, m.Straße, m.Hausnr, "
				+ "m.OrtID, o.PLZ, o.Ort, m.ZahlungsdatenID, m.Telefon, m.Mail " + "FROM Mitglieder AS m "
				+ "LEFT JOIN Ort AS o ON o.OrtID = m.OrtID " + "WHERE MitgliederID = ?";
		try (PreparedStatement stmt = connection.prepareStatement(sql)) {
			stmt.setInt(1, mitgliederID);
			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				Mitglieder m = mapRowToMitglieder(rs);
				results.add(m);
			}
		}
		return results;
	}

	public int getID(Mitglieder mitglied) {
		return mitglied.getMitgliederID();
	}

	public List<Mitglieder> findAll() throws SQLException {
		List<Mitglieder> list = new ArrayList<>();
		String sql = "SELECT m.*, o.* FROM Mitglieder AS m JOIN Ort AS o ON o.OrtID = m.OrtID";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				list.add(mapRowToMitglieder(rs));
			}
		} finally {
			if (rs != null)
				rs.close();
			if (ps != null)
				ps.close();
		}
		return list;
	}

	private Mitglieder mapRowToMitglieder(ResultSet rs) throws SQLException {
		Mitglieder mitglied = new Mitglieder();
		mitglied.setMitgliederID(rs.getInt("MitgliederID"));
		mitglied.setVorname(rs.getString("Vorname"));
		mitglied.setNachname(rs.getString("Nachname"));
		mitglied.setGeburtsdatum(rs.getDate("Geburtsdatum"));
		mitglied.setAktiv(rs.getBoolean("Aktiv"));
		mitglied.setStrasse(rs.getString("Straße"));
		mitglied.setHausnr(rs.getString("Hausnr"));
		Ort ort = new Ort(rs.getInt("OrtID"), rs.getString("PLZ"), rs.getString("Ort"));
		mitglied.setOrt(ort);
		mitglied.setZahlungsdatenID(rs.getInt("ZahlungsdatenID"));
		mitglied.setTelefon(rs.getString("Telefon"));
		mitglied.setMail(rs.getString("Mail"));
		return mitglied;
	}

	@Override
	public Mitglieder findById(int id) throws SQLException, IntException, NotFoundException {
		String sql = "SELECT m.MitgliederID, m.Vorname, m.Nachname, m.Geburtsdatum, m.Aktiv, m.Straße, m.Hausnr, "
				+ "m.OrtID, o.PLZ, o.Ort, m.ZahlungsdatenID, m.Telefon, m.Mail " + "FROM Mitglieder AS m "
				+ "LEFT JOIN Ort AS o ON o.OrtID = m.OrtID " + "WHERE m.MitgliederID = ?";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setInt(1, id);
			rs = ps.executeQuery();
			if (rs.next()) {
				int ortID = rs.getInt("OrtID");
				int zahlungsdatenID = rs.getInt("ZahlungsdatenID");

				Ort ort = ortDAO.findById(ortID);
				Zahlungsdaten zahlungsdaten = zahlungsdatenDAO.findById(zahlungsdatenID);

				return new Mitglieder(rs.getInt("MitgliederID"), rs.getString("Vorname"), rs.getString("Nachname"),
						rs.getString("Telefon"), rs.getDate("Geburtsdatum"), rs.getBoolean("Aktiv"),
						rs.getString("Straße"), rs.getString("Hausnr"), ort, zahlungsdaten, rs.getString("Mail"));
			}
		} finally {
			closeResources(rs, ps);
		}
		return null;
	}

	@Override
	public void insert(Mitglieder entity) throws SQLException {
		String sql = "INSERT INTO Mitglieder (Vorname, Nachname, Telefon, Geburtsdatum, Aktiv, Straße, Hausnr, OrtID, ZahlungsdatenID, Mail) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql, java.sql.Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, entity.getVorname());
			ps.setString(2, entity.getNachname());
			ps.setString(3, entity.getTelefon());
			ps.setDate(4, entity.getGeburtsdatum() != null ? new Date(entity.getGeburtsdatum().getTime()) : null);
			ps.setBoolean(5, entity.isAktiv());
			ps.setString(6, entity.getStrasse());
			ps.setString(7, entity.getHausnr());
			ps.setInt(8, entity.getOrtID());
			ps.setInt(9, entity.getZahlungsdatenID());
			ps.setString(10, entity.getMail());
			ps.executeUpdate();

			rs = ps.getGeneratedKeys();
			if (rs.next()) {
				entity.setMitgliederID(rs.getInt(1));
			}
		} finally {
			closeResources(rs, ps);
		}
	}

	@Override
	public void update(Mitglieder entity) throws SQLException {
		String sql = "UPDATE Mitglieder SET Vorname = ?, Nachname = ?, Telefon = ?, Geburtsdatum = ?, Aktiv = ?, Straße = ?, Hausnr = ?, OrtID = ?, ZahlungsdatenID = ?, Mail = ? WHERE MitgliederID = ?";
		PreparedStatement ps = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setString(1, entity.getVorname());
			ps.setString(2, entity.getNachname());
			ps.setString(3, entity.getTelefon());
			ps.setDate(4, entity.getGeburtsdatum() != null ? new Date(entity.getGeburtsdatum().getTime()) : null);
			ps.setBoolean(5, entity.isAktiv());
			ps.setString(6, entity.getStrasse());
			ps.setString(7, entity.getHausnr());
			ps.setInt(8, entity.getOrtID());
			ps.setInt(9, entity.getZahlungsdatenID());
			ps.setString(10, entity.getMail());
			ps.setInt(11, entity.getMitgliederID());
			ps.executeUpdate();
		} finally {
			closeResources(null, ps);
		}
	}

	@Override
	public void delete(int id) throws SQLException {
		String sql = "DELETE FROM Mitglieder WHERE MitgliederID = ?";
		PreparedStatement ps = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setInt(1, id);
			ps.executeUpdate();
		} finally {
			closeResources(null, ps);
		}
	}
}

----- Inhalt von: MitgliederVertragDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import Objekte.Mitglieder;
import Objekte.MitgliederVertrag;
import Objekte.Vertrag;
import Objekte.Zahlung;

public class MitgliederVertragDAO extends BaseDAO<MitgliederVertrag> {

    public MitgliederVertragDAO(Connection connection) {
        super(connection);
    }

    @Override
    public void insert(MitgliederVertrag entity) throws Exception {
        throw new UnsupportedOperationException(
            "Nutze insert(MitgliederVertrag, Vertrag, Zahlung, Mitglieder, int laufzeitWochen)!"
        );
    }

    @Override
    public void update(MitgliederVertrag entity) throws Exception {
        throw new UnsupportedOperationException(
            "Nutze update(MitgliederVertrag, Vertrag, Zahlung, Mitglieder, int laufzeitWochen)!"
        );
    }

    // Angepasste Insert-Methode mit MitarbeiterID
    public void insert(MitgliederVertrag mv, Vertrag vertrag, Zahlung zahlung, Mitglieder mitglied, int laufzeitWochen)
            throws Exception {
        mv.validateAll(vertrag, zahlung, mitglied, laufzeitWochen);
        String sql = "INSERT INTO MitgliederVertrag (MitgliederID, VertragID, Vertragsbeginn, Vertragsende, Verlängerung, Aktiv, Gekündigt, Preisrabatt, IntervallID, ZahlungID, MitarbeiterID, Trainingsbeginn, Kommentar) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        try (PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            ps.setInt(1, mv.getMitgliederID());
            ps.setInt(2, mv.getVertragID());
            ps.setDate(3, mv.getVertragsbeginn() != null ? new java.sql.Date(mv.getVertragsbeginn().getTime()) : null);
            ps.setDate(4, mv.getVertragsende() != null ? new java.sql.Date(mv.getVertragsende().getTime()) : null);
            ps.setBoolean(5, mv.isVerlängerung());
            ps.setBoolean(6, mv.isAktiv());
            ps.setBoolean(7, mv.isGekündigt());
            ps.setDouble(8, mv.getPreisrabatt());
            ps.setInt(9, mv.getIntervallID());
            ps.setInt(10, mv.getZahlungID());
            ps.setInt(11, mv.getMitarbeiterID()); // NEU
            ps.setDate(12, mv.getTrainingsbeginn() != null ? new java.sql.Date(mv.getTrainingsbeginn().getTime()) : null);
            ps.setString(13, mv.getKommentar());
            ps.executeUpdate();
            ResultSet rs = ps.getGeneratedKeys();
            if (rs.next()) {
                mv.setVertragNr(rs.getInt(1));
            }
        }
    }

    @Override
    public MitgliederVertrag findById(int id) throws SQLException {
        String sql = "SELECT * FROM MitgliederVertrag WHERE VertragNr = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, id);
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToMitgliederVertrag(rs);
            }
        }
        return null;
    }

    // Angepasste Update-Methode mit MitarbeiterID
    public void update(MitgliederVertrag mv, Vertrag vertrag, Zahlung zahlung, Mitglieder mitglied, int laufzeitWochen)
            throws Exception {
        mv.validateAll(vertrag, zahlung, mitglied, laufzeitWochen);
        String sql = "UPDATE MitgliederVertrag SET MitgliederID=?, VertragID=?, Vertragsbeginn=?, Vertragsende=?, Verlängerung=?, Aktiv=?, Gekündigt=?, Preisrabatt=?, IntervallID=?, ZahlungID=?, MitarbeiterID=?, Trainingsbeginn=?, Kommentar=? WHERE VertragNr=?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, mv.getMitgliederID());
            ps.setInt(2, mv.getVertragID());
            ps.setDate(3, mv.getVertragsbeginn() != null ? new java.sql.Date(mv.getVertragsbeginn().getTime()) : null);
            ps.setDate(4, mv.getVertragsende() != null ? new java.sql.Date(mv.getVertragsende().getTime()) : null);
            ps.setBoolean(5, mv.isVerlängerung());
            ps.setBoolean(6, mv.isAktiv());
            ps.setBoolean(7, mv.isGekündigt());
            ps.setDouble(8, mv.getPreisrabatt());
            ps.setInt(9, mv.getIntervallID());
            ps.setInt(10, mv.getZahlungID());
            ps.setInt(11, mv.getMitarbeiterID()); // NEU
            ps.setDate(12, mv.getTrainingsbeginn() != null ? new java.sql.Date(mv.getTrainingsbeginn().getTime()) : null);
            ps.setString(13, mv.getKommentar());
            ps.setInt(14, mv.getVertragNr());
            ps.executeUpdate();
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM MitgliederVertrag WHERE VertragNr=?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, id);
            ps.executeUpdate();
        }
    }

    public List<MitgliederVertrag> findAll() throws SQLException {
        String sql = "SELECT * FROM MitgliederVertrag";
        List<MitgliederVertrag> list = new ArrayList<>();
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToMitgliederVertrag(rs));
            }
        }
        return list;
    }

    public List<MitgliederVertrag> searchAllAttributes(String searchTerm) throws SQLException {
        List<MitgliederVertrag> result = new ArrayList<>();
        String sql = "SELECT * FROM MitgliederVertrag WHERE " +
                     "CAST(VertragNr AS CHAR) LIKE ? OR " +
                     "CAST(MitgliederID AS CHAR) LIKE ? OR " +
                     "CAST(VertragID AS CHAR) LIKE ? OR " +
                     "CAST(MitarbeiterID AS CHAR) LIKE ? OR " +
                     "LOWER(Kommentar) LIKE ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            String like = "%" + searchTerm.toLowerCase() + "%";
            ps.setString(1, like);
            ps.setString(2, like);
            ps.setString(3, like);
            ps.setString(4, like); // MitarbeiterID
            ps.setString(5, like);
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                result.add(mapRowToMitgliederVertrag(rs));
            }
        }
        return result;
    }

    public List<MitgliederVertrag> findByMitgliedId(int mitgliedId) throws SQLException {
        List<MitgliederVertrag> result = new ArrayList<>();
        String sql = "SELECT * FROM MitgliederVertrag WHERE MitgliederID = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setInt(1, mitgliedId);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                result.add(mapRowToMitgliederVertrag(rs));
            }
        }
        return result;
    }

    public List<MitgliederVertrag> findByZahlungId(int zahlungId) throws SQLException {
        List<MitgliederVertrag> result = new ArrayList<>();
        String sql = "SELECT * FROM MitgliederVertrag WHERE ZahlungID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, zahlungId);
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                result.add(mapRowToMitgliederVertrag(rs));
            }
        }
        return result;
    }

    public List<MitgliederVertrag> findByVertragId(int vertragId) throws SQLException {
        List<MitgliederVertrag> result = new ArrayList<>();
        String sql = "SELECT * FROM MitgliederVertrag WHERE VertragID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, vertragId);
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                result.add(mapRowToMitgliederVertrag(rs));
            }
        }
        return result;
    }

    public List<MitgliederVertrag> findByIntervallId(int intervallId) throws SQLException {
        List<MitgliederVertrag> result = new ArrayList<>();
        String sql = "SELECT * FROM MitgliederVertrag WHERE IntervallID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, intervallId);
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                result.add(mapRowToMitgliederVertrag(rs));
            }
        }
        return result;
    }

    public List<MitgliederVertrag> findByMitarbeiterId(int mitarbeiterId) throws SQLException {
        List<MitgliederVertrag> result = new ArrayList<>();
        String sql = "SELECT * FROM MitgliederVertrag WHERE MitarbeiterID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, mitarbeiterId);
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                result.add(mapRowToMitgliederVertrag(rs));
            }
        }
        return result;
    }

    private MitgliederVertrag mapRowToMitgliederVertrag(ResultSet rs) throws SQLException {
        MitgliederVertrag mv = new MitgliederVertrag();
        mv.setVertragNr(rs.getInt("VertragNr"));
        mv.setMitgliederID(rs.getInt("MitgliederID"));
        mv.setVertragID(rs.getInt("VertragID"));
        mv.setVertragsbeginn(rs.getDate("Vertragsbeginn"));
        mv.setVertragsende(rs.getDate("Vertragsende"));
        mv.setVerlängerung(rs.getBoolean("Verlängerung"));
        mv.setAktiv(rs.getBoolean("Aktiv"));
        mv.setGekündigt(rs.getBoolean("Gekündigt"));
        mv.setPreisrabatt(rs.getDouble("Preisrabatt"));
        mv.setIntervallID(rs.getInt("IntervallID"));
        mv.setZahlungID(rs.getInt("ZahlungID"));
        mv.setMitarbeiterID(rs.getInt("MitarbeiterID")); // NEU
        mv.setTrainingsbeginn(rs.getDate("Trainingsbeginn"));
        mv.setKommentar(rs.getString("Kommentar"));
        return mv;
    }
}

----- Inhalt von: OrtDAO.txt -----
package DAOs;

import Objekte.Ort;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import Exception.IntException;
import Exception.StringException;
import Exception.TooLongException;
import Exception.TooShortException;
import OUTDATED.OUT_IntValidator;
import OUTDATED.OUT_StringValidator;

public class OrtDAO extends BaseDAO<Ort> {

    // Attribute
    private final OUT_IntValidator oUT_IntValidator = new OUT_IntValidator();
    private final OUT_StringValidator oUT_StringValidator = new OUT_StringValidator();

    // Konstruktor
    public OrtDAO(Connection connection) {
        super(connection);
    }

    // Methoden
    
    public List<Ort> searchAllAttributes(String searchTerm) throws SQLException {
        List<Ort> results = new ArrayList<>();
        String sql = "SELECT OrtID, PLZ, Ort FROM Ort WHERE Ort LIKE ? OR PLZ LIKE ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            String pattern = "%" + searchTerm + "%";
            stmt.setString(1, pattern);
            stmt.setString(2, pattern);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                Ort o = mapRowToOrt(rs);
                results.add(o);
            }
        }
        return results;
    }

    public int getID(Ort ort) {
        return ort.getOrtID();
    }
    
    /**
     * Findet eine OrtID nach PLZ und Name oder legt den Ort an, falls nicht vorhanden.
     * Gibt immer die passende OrtID zurück (neu oder vorhanden).
     */
    public int findOrCreateOrt(String plz, String ort)
            throws SQLException, StringException, TooShortException, TooLongException {
        
        // Validierung
        oUT_StringValidator.validate(plz);
        oUT_StringValidator.checkLength(plz, "PLZ", 5, 5);
        oUT_StringValidator.validate(ort);
        
        // Suche nach existierendem Ort
        String selectSQL = "SELECT OrtID, PLZ, Ort FROM Ort WHERE PLZ = ? AND Ort = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(selectSQL);
            ps.setString(1, plz);
            ps.setString(2, ort);
            rs = ps.executeQuery();
            if (rs.next()) {
                return rs.getInt("OrtID");
            }
        } finally {
            closeResources(rs, ps);
        }

        // Falls nicht vorhanden: neu anlegen
        String insertSQL = "INSERT INTO Ort (PLZ, Ort) VALUES (?, ?)";
        try {
            ps = connection.prepareStatement(insertSQL, Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, plz);
            ps.setString(2, ort);
            ps.executeUpdate();
            rs = ps.getGeneratedKeys();
            if (rs.next()) {
                return rs.getInt(1); // ID zurückgeben
            } else {
                throw new SQLException("Fehler: Neue OrtID konnte nicht erfasst werden.");
            }
        } finally {
            closeResources(rs, ps);
        }
    }

    // Override
    @Override
    public Ort findById(int id) throws SQLException, IntException {
        try {
            oUT_IntValidator.validate(id);
        } catch (Exception e) {
            throw new IntException("Fehler bei der OrtID-Validierung: " + e.getMessage());
        }
        String sql = "SELECT OrtID, PLZ, Ort FROM Ort WHERE OrtID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            rs = ps.executeQuery();
            if (rs.next()) {
                return new Ort(
                    rs.getInt("OrtID"),
                    rs.getString("PLZ"),
                    rs.getString("Ort")
                );
            }
        } finally {
            closeResources(rs, ps);
        }
        return null;
    }

    public List<Ort> findAll() throws SQLException {
        List<Ort> list = new ArrayList<>();
        String sql = "SELECT * FROM Ort";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToOrt(rs));
            }
        } finally {
            if (rs != null) rs.close();
            if (ps != null) ps.close();
        }
        return list;
    }

    private Ort mapRowToOrt(ResultSet rs) throws SQLException {
        Ort o = new Ort();
        o.setOrtID(rs.getInt("OrtID"));
        o.setPLZ(rs.getString("PLZ"));
        o.setOrt(rs.getString("Ort"));
        return o;
    }

    // Override
    @Override
    public void insert(Ort entity)
            throws SQLException, StringException, TooShortException, TooLongException, IntException {
        try {
            oUT_IntValidator.validate(entity.getOrtID());
        } catch (Exception e) {
            throw new IntException("Fehler bei OrtID: " + e.getMessage());
        }
        try {
            oUT_StringValidator.validate(entity.getPLZ());
            oUT_StringValidator.checkLength(entity.getPLZ(), "PLZ", 5, 5);
            oUT_StringValidator.validate(entity.getOrt());
        } catch (TooShortException | TooLongException | StringException ex) {
            throw ex;
        }

        String sql = "INSERT INTO Ort (OrtID, PLZ, Ort) VALUES (?, ?, ?)";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, entity.getOrtID());
            ps.setString(2, entity.getPLZ());
            ps.setString(3, entity.getOrt());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    // Override
    @Override
    public void update(Ort entity)
            throws SQLException, StringException, TooShortException, TooLongException, IntException {
        try {
            oUT_IntValidator.validate(entity.getOrtID());
            oUT_StringValidator.validate(entity.getPLZ());
            oUT_StringValidator.checkLength(entity.getPLZ(), "PLZ", 5, 5);
            oUT_StringValidator.validate(entity.getOrt());
        } catch (TooShortException | TooLongException | StringException | IntException ex) {
            throw ex;
        }

        String sql = "UPDATE Ort SET PLZ = ?, Ort = ? WHERE OrtID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setString(1, entity.getPLZ());
            ps.setString(2, entity.getOrt());
            ps.setInt(3, entity.getOrtID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    // Override
    @Override
    public void delete(int id) throws SQLException, IntException {
        try {
            oUT_IntValidator.validate(id);
        } catch (Exception e) {
            throw new IntException("Fehler bei OrtID: " + e.getMessage());
        }
        String sql = "DELETE FROM Ort WHERE OrtID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }
}

----- Inhalt von: RolleDAO.txt -----
package DAOs;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

import Objekte.Rolle;

public class RolleDAO extends BaseDAO<Rolle> {

    public RolleDAO(Connection connection) {
        super(connection);
    }

    @Override
    public void insert(Rolle rolle) throws SQLException {
        String sql = "INSERT INTO Rolle (Bezeichnung, Kommentar) VALUES (?, ?)";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, rolle.getBezeichnung());
            ps.setString(2, rolle.getKommentar());
            ps.executeUpdate();
            rs = ps.getGeneratedKeys();
            if (rs.next()) {
                rolle.setRolleID(rs.getInt(1));
            }
        } finally {
            closeResources(rs, ps);
        }
    }

    @Override
    public Rolle findById(int id) throws SQLException {
        String sql = "SELECT * FROM Rolle WHERE RolleID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToRolle(rs);
            }
        } finally {
            closeResources(rs, ps);
        }
        return null;
    }

    @Override
    public void update(Rolle rolle) throws SQLException {
        String sql = "UPDATE Rolle SET Bezeichnung = ?, Kommentar = ? WHERE RolleID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setString(1, rolle.getBezeichnung());
            ps.setString(2, rolle.getKommentar());
            ps.setInt(3, rolle.getRolleID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Rolle WHERE RolleID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    public List<Rolle> findAll() throws SQLException {
        String sql = "SELECT * FROM Rolle";
        List<Rolle> list = new ArrayList<>();
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToRolle(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return list;
    }

    public List<Rolle> searchAllAttributes(String searchTerm) throws SQLException {
        List<Rolle> result = new ArrayList<>();
        String query = 
            "SELECT * FROM Rolle " +
            "WHERE CAST(RolleID AS CHAR) LIKE ? " +
            "OR Bezeichnung LIKE ? " +
            "OR Kommentar LIKE ?";
        try (PreparedStatement stmt = connection.prepareStatement(query)) {
            String like = "%" + searchTerm + "%";
            stmt.setString(1, like);
            stmt.setString(2, like);
            stmt.setString(3, like);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    result.add(mapRowToRolle(rs));
                }
            }
        }
        return result;
    }
    
    private Rolle mapRowToRolle(ResultSet rs) throws SQLException {
        Rolle rolle = new Rolle();
        rolle.setRolleID(rs.getInt("RolleID"));
        rolle.setBezeichnung(rs.getString("Bezeichnung"));
        rolle.setKommentar(rs.getString("Kommentar"));
        return rolle;
    }
}

----- Inhalt von: TrainerDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Trainer;

public class TrainerDAO extends BaseDAO<Trainer> {

    public TrainerDAO(Connection connection) {
        super(connection);
    }

    @Override
    public Trainer findById(int id) throws SQLException, IntException, NotFoundException {
        String sql = "SELECT TrainerID, Vorname, Nachname, Kommentar FROM Trainer WHERE TrainerID = ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToTrainer(rs);
            }
        } finally {
            closeResources(rs, ps);
        }
        return null;
    }

    @Override
    public void insert(Trainer entity) throws SQLException {
        String sql = "INSERT INTO Trainer (Vorname, Nachname, Kommentar) VALUES (?, ?, ?)";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql, java.sql.Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, entity.getVorname());
            ps.setString(2, entity.getNachname());
            ps.setString(3, entity.getKommentar());
            ps.executeUpdate();

            rs = ps.getGeneratedKeys();
            if (rs.next()) {
                entity.setTrainerID(rs.getInt(1));
            }
        } finally {
            closeResources(rs, ps);
        }
    }

    @Override
    public void update(Trainer entity) throws SQLException {
        String sql = "UPDATE Trainer SET Vorname = ?, Nachname = ?, Kommentar = ? WHERE TrainerID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setString(1, entity.getVorname());
            ps.setString(2, entity.getNachname());
            ps.setString(3, entity.getKommentar());
            ps.setInt(4, entity.getTrainerID());
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Trainer WHERE TrainerID = ?";
        PreparedStatement ps = null;
        try {
            ps = connection.prepareStatement(sql);
            ps.setInt(1, id);
            ps.executeUpdate();
        } finally {
            closeResources(null, ps);
        }
    }

    public List<Trainer> findAll() throws SQLException {
        List<Trainer> trainer = new ArrayList<>();
        String sql = "SELECT TrainerID, Vorname, Nachname, Kommentar FROM Trainer";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            rs = ps.executeQuery();
            while (rs.next()) {
                trainer.add(mapRowToTrainer(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return trainer;
    }

    public List<Trainer> searchAllAttributes(String searchTerm) throws SQLException {
        List<Trainer> results = new ArrayList<>();
        String sql = "SELECT TrainerID, Vorname, Nachname, Kommentar FROM Trainer " +
                     "WHERE Vorname LIKE ? OR Nachname LIKE ? OR Kommentar LIKE ?";
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = connection.prepareStatement(sql);
            String pattern = "%" + searchTerm + "%";
            ps.setString(1, pattern);
            ps.setString(2, pattern);
            ps.setString(3, pattern);
            rs = ps.executeQuery();
            while (rs.next()) {
                results.add(mapRowToTrainer(rs));
            }
        } finally {
            closeResources(rs, ps);
        }
        return results;
    }

    private Trainer mapRowToTrainer(ResultSet rs) throws SQLException {
        Trainer trainer = new Trainer();
        trainer.setTrainerID(rs.getInt("TrainerID"));
        trainer.setVorname(rs.getString("Vorname"));
        trainer.setNachname(rs.getString("Nachname"));
        trainer.setKommentar(rs.getString("Kommentar"));
        return trainer;
    }
}

----- Inhalt von: Transaction.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.SQLException;

import Exception.ConnectionException;

public class Transaction {
    private final Connection connection;
    private boolean active = false;

    public Transaction(Connection connection) throws ConnectionException, SQLException {
        if (connection == null || connection.isClosed()) {
            throw new ConnectionException("Transaktion kann nicht gestartet werden: Keine gültige Datenbankverbindung.");
        }
        this.connection = connection;
        this.connection.setAutoCommit(false);
        this.active = true;
    }


    public void commit() throws SQLException {
        if (active) {
            connection.commit();
            active = false;
            connection.setAutoCommit(true);
        }
    }

    public void rollback() throws SQLException {
        if (active) {
            connection.rollback();
            active = false;
            connection.setAutoCommit(true);
        }
    }

    public void close() throws SQLException {
        if (active) {
            rollback();
        }
        if (!connection.isClosed()) {
            connection.close();
        }
    }

    public Connection getConnection() {
        return connection;
    }

    public boolean isActive() {
        return active;
    }
}

//
//
//Transaction tx = new Transaction(conn);
//try {
//    // DB-Operationen
//    tx.commit();
//} catch (Exception e) {
//    tx.rollback();
//} finally {
//    tx.close();
//}

----- Inhalt von: VertragDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import Objekte.Vertrag;

public class VertragDAO extends BaseDAO<Vertrag> {

    public VertragDAO(Connection connection) {
        super(connection);
    }

    @Override
    public void insert(Vertrag v) throws SQLException {
        String sql = "INSERT INTO Vertrag (Bezeichnung, Laufzeit, Grundpreis) VALUES (?, ?, ?)";
        try (PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            ps.setString(1, v.getBezeichnung());
            ps.setInt(2, v.getLaufzeit());
            ps.setDouble(3, v.getGrundpreis());
            ps.executeUpdate();
            ResultSet rs = ps.getGeneratedKeys();
            if (rs.next()) {
                v.setVertragID(rs.getInt(1));
            }
        }
    }

    @Override
    public Vertrag findById(int id) throws SQLException {
        String sql = "SELECT VertragID, Bezeichnung, Laufzeit, Grundpreis FROM Vertrag WHERE VertragID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, id);
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToVertrag(rs);
            }
        }
        return null;
    }

    @Override
    public void update(Vertrag v) throws SQLException {
        String sql = "UPDATE Vertrag SET Bezeichnung=?, Laufzeit=?, Grundpreis=? WHERE VertragID=?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setString(1, v.getBezeichnung());
            ps.setInt(2, v.getLaufzeit());
            ps.setDouble(3, v.getGrundpreis());
            ps.setInt(4, v.getVertragID());
            ps.executeUpdate();
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Vertrag WHERE VertragID=?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, id);
            ps.executeUpdate();
        }
    }

    public List<Vertrag> findAll() throws SQLException {
        String sql = "SELECT VertragID, Bezeichnung, Laufzeit, Grundpreis FROM Vertrag";
        List<Vertrag> list = new ArrayList<>();
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToVertrag(rs));
            }
        }
        return list;
    }
    
    public List<Vertrag> searchAllAttributes(String searchTerm) throws SQLException {
        List<Vertrag> result = new ArrayList<>();
        String sql = "SELECT * FROM Vertrag WHERE " +
                     "CAST(VertragID AS CHAR) LIKE ? OR " +
                     "LOWER(Bezeichnung) LIKE ? OR " +
                     "CAST(Laufzeit AS CHAR) LIKE ? OR " +
                     "CAST(Grundpreis AS CHAR) LIKE ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            String like = "%" + searchTerm.toLowerCase() + "%";
            ps.setString(1, like);
            ps.setString(2, like);
            ps.setString(3, like);
            ps.setString(4, like);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    result.add(mapRowToVertrag(rs));
                }
            }
        }
        return result;
    }

    private Vertrag mapRowToVertrag(ResultSet rs) throws SQLException {
        return new Vertrag(
                rs.getInt("VertragID"),
                rs.getString("Bezeichnung"),
                rs.getInt("Laufzeit"),
                rs.getDouble("Grundpreis")
        );
    }
}

----- Inhalt von: ZahlungDAO.txt -----
package DAOs;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import Objekte.Zahlung;

public class ZahlungDAO extends BaseDAO<Zahlung> {

    public ZahlungDAO(Connection connection) {
        super(connection);
    }

    @Override
    public void insert(Zahlung z) throws SQLException {
        String sql = "INSERT INTO Zahlung (Zahlungsart) VALUES (?)";
        try (PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            ps.setString(1, z.getZahlungsart());
            ps.executeUpdate();
            ResultSet rs = ps.getGeneratedKeys();
            if (rs.next()) {
                z.setZahlungID(rs.getInt(1));
            }
        }
    }

    @Override
    public Zahlung findById(int id) throws SQLException {
        String sql = "SELECT ZahlungID, Zahlungsart FROM Zahlung WHERE ZahlungID = ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, id);
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                return mapRowToZahlung(rs);
            }
        }
        return null;
    }

    @Override
    public void update(Zahlung z) throws SQLException {
        String sql = "UPDATE Zahlung SET Zahlungsart=? WHERE ZahlungID=?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setString(1, z.getZahlungsart());
            ps.setInt(2, z.getZahlungID());
            ps.executeUpdate();
        }
    }

    @Override
    public void delete(int id) throws SQLException {
        String sql = "DELETE FROM Zahlung WHERE ZahlungID=?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ps.setInt(1, id);
            ps.executeUpdate();
        }
    }

    public List<Zahlung> findAll() throws SQLException {
        String sql = "SELECT ZahlungID, Zahlungsart FROM Zahlung";
        List<Zahlung> list = new ArrayList<>();
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                list.add(mapRowToZahlung(rs));
            }
        }
        return list;
    }
    
    public List<Zahlung> searchAllAttributes(String searchTerm) throws SQLException {
        List<Zahlung> result = new ArrayList<>();
        String sql = "SELECT * FROM Zahlung WHERE " +
                     "CAST(ZahlungID AS CHAR) LIKE ? OR " +
                     "LOWER(Zahlungsart) LIKE ?";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
            String like = "%" + searchTerm.toLowerCase() + "%";
            ps.setString(1, like);
            ps.setString(2, like);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    result.add(mapRowToZahlung(rs));
                }
            }
        }
        return result;
    }

    
    private Zahlung mapRowToZahlung(ResultSet rs) throws SQLException {
        return new Zahlung(
            rs.getInt("ZahlungID"),
            rs.getString("Zahlungsart")
        );
    }
}

----- Inhalt von: ZahlungsdatenDAO.txt -----
package DAOs;

import Objekte.Zahlungsdaten;

import java.util.ArrayList;
import java.util.List;

import Exception.PaymentDetailsException;
import Exception.StringException;
import OUTDATED.OUT_StringValidator;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class ZahlungsdatenDAO extends BaseDAO<Zahlungsdaten> {

	// Attribute
	private final OUT_StringValidator oUT_StringValidator = new OUT_StringValidator();

	// Konstruktor
	public ZahlungsdatenDAO(Connection connection) {
		super(connection);
	}

	// Methoden

	public List<Zahlungsdaten> searchAllAttributes(String searchTerm) throws SQLException {
		List<Zahlungsdaten> results = new ArrayList<>();
		String sql = "SELECT * FROM zahlungsdaten WHERE " + "Name LIKE ? OR IBAN LIKE ? OR BIC LIKE ?";
		try (PreparedStatement stmt = connection.prepareStatement(sql)) {
			String pattern = "%" + searchTerm + "%";
			for (int i = 1; i <= 3; i++) {
				stmt.setString(i, pattern);
			}
			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				Zahlungsdaten z = mapRowToZahlungsdaten(rs);
				results.add(z);
			}
		}
		return results;
	}

	public int getID(Zahlungsdaten zahlungsdaten) {
		return zahlungsdaten.getZahlungsdatenID();
	}

	private Zahlungsdaten mapRowToZahlungsdaten(ResultSet rs) throws SQLException {
		Zahlungsdaten zahlungsdaten = new Zahlungsdaten();
		zahlungsdaten.setZahlungsdatenID(rs.getInt("zahlungsdatenid"));
		zahlungsdaten.setName(rs.getString("name"));
		zahlungsdaten.setIBAN(rs.getString("IBAN"));
		zahlungsdaten.setBIC(rs.getString("BIC"));
		return zahlungsdaten;
	}

	/**
	 * Findet oder erstellt Zahlungsdaten nach Name, IBAN & BIC, liefert immer die
	 * ID aus der DB.
	 */
	/**
	 * Findet oder erstellt Zahlungsdaten nach Name, IBAN & BIC, liefert immer die
	 * ID aus der DB.
	 */
	public int findOrCreateZahlungsdaten(String name, String iban, String bic)
			throws SQLException, StringException, PaymentDetailsException {
		oUT_StringValidator.validate(name);
		oUT_StringValidator.validate(iban);
		oUT_StringValidator.validate(bic);

		// Plausibilitäts-Checks gegen TEST/Platzhalter
		if (name.trim().isEmpty() || iban.trim().isEmpty() || bic.trim().isEmpty()
				|| "TEST".equalsIgnoreCase(iban.trim()) || "TEST".equalsIgnoreCase(bic.trim())) {
			throw new PaymentDetailsException("Zahlungsdaten unzulässig: Leere oder Platzhalter-Werte!");
		}

		String selectSQL = "SELECT ZahlungsdatenID FROM Zahlungsdaten WHERE IBAN = ? AND BIC = ?";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(selectSQL);
			ps.setString(1, iban);
			ps.setString(2, bic);
			rs = ps.executeQuery();
			while (rs.next()) {
				int id = rs.getInt("ZahlungsdatenID");
				Zahlungsdaten check = findById(id);
				if (check != null && !check.getName().isEmpty() && !check.getIBAN().isEmpty()
						&& !check.getBIC().isEmpty() && !"TEST".equalsIgnoreCase(check.getIBAN())
						&& !"TEST".equalsIgnoreCase(check.getBIC())) {
					return id;
				}
			}
		} finally {
			closeResources(rs, ps);
		}

		String insertSQL = "INSERT INTO Zahlungsdaten (Name, IBAN, BIC) VALUES (?, ?, ?)";
		try {
			ps = connection.prepareStatement(insertSQL, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, name.trim());
			ps.setString(2, iban.trim());
			ps.setString(3, bic.trim());
			ps.executeUpdate();
			rs = ps.getGeneratedKeys();
			if (rs.next()) {
				return rs.getInt(1);
			} else {
				throw new SQLException("Fehler: Neue ZahlungsdatenID konnte nicht erfasst werden.");
			}
		} finally {
			closeResources(rs, ps);
		}
	}

	public List<Zahlungsdaten> findAll() throws SQLException {
		List<Zahlungsdaten> list = new ArrayList<>();
		String sql = "SELECT * FROM Zahlungsdaten";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				list.add(mapRowToZahlungsdaten(rs));
			}
		} finally {
			if (rs != null)
				rs.close();
			if (ps != null)
				ps.close();
		}
		return list;
	}

	// Override
	@Override
	public Zahlungsdaten findById(int id) throws SQLException {
		String sql = "SELECT ZahlungsdatenID, Name, IBAN, BIC FROM Zahlungsdaten WHERE ZahlungsdatenID = ?";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setInt(1, id);
			rs = ps.executeQuery();
			if (rs.next()) {
				return new Zahlungsdaten(rs.getInt("ZahlungsdatenID"), rs.getString("Name"), rs.getString("IBAN"),
						rs.getString("BIC"));
			}
		} finally {
			closeResources(rs, ps);
		}
		return null;
	}

	// Override
	@Override
	public void insert(Zahlungsdaten entity) throws SQLException, StringException, PaymentDetailsException {
		oUT_StringValidator.validate(entity.getName());
		oUT_StringValidator.validate(entity.getIBAN());
		oUT_StringValidator.validate(entity.getBIC());

		String sql = "INSERT INTO Zahlungsdaten (Name, IBAN, BIC) VALUES (?, ?, ?)";
		PreparedStatement ps = null;
		try {
			ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, entity.getName());
			ps.setString(2, entity.getIBAN());
			ps.setString(3, entity.getBIC());
			ps.executeUpdate();
			ResultSet keys = ps.getGeneratedKeys();
			if (keys.next()) {
				entity.setZahlungsdatenID(keys.getInt(1));
			}
		} finally {
			closeResources(null, ps);
		}
	}

	// Override
	@Override
	public void update(Zahlungsdaten entity) throws SQLException, StringException, PaymentDetailsException {
		oUT_StringValidator.validate(entity.getName());
		oUT_StringValidator.validate(entity.getIBAN());
		oUT_StringValidator.validate(entity.getBIC());

		String sql = "UPDATE Zahlungsdaten SET Name = ?, IBAN = ?, BIC = ? WHERE ZahlungsdatenID = ?";
		PreparedStatement ps = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setString(1, entity.getName());
			ps.setString(2, entity.getIBAN());
			ps.setString(3, entity.getBIC());
			ps.setInt(4, entity.getZahlungsdatenID());
			ps.executeUpdate();
		} finally {
			closeResources(null, ps);
		}
	}

	// Override
	@Override
	public void delete(int id) throws SQLException {
		String sql = "DELETE FROM Zahlungsdaten WHERE ZahlungsdatenID = ?";
		PreparedStatement ps = null;
		try {
			ps = connection.prepareStatement(sql);
			ps.setInt(1, id);
			ps.executeUpdate();
		} finally {
			closeResources(null, ps);
		}
	}
}

----- Inhalt von: AppException.txt -----
package Exception;

public class AppException extends Exception {
    private static final long serialVersionUID = 1L;

    public AppException() {
        super();
    }

    public AppException(String message) {
        super(message);
    }

    public AppException(String message, Throwable cause) {
        super(message, cause);
    }

    public AppException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: BigDecimalException.txt -----
package Exception;

public class BigDecimalException extends NumericException {
    private static final long serialVersionUID = 1L;

    public BigDecimalException() {
        super();
    }

    public BigDecimalException(String message) {
        super(message);
    }

    public BigDecimalException(String message, Throwable cause) {
        super(message, cause);
    }

    public BigDecimalException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: BigIntegerException.txt -----
package Exception;

public class BigIntegerException extends NumericException {
    private static final long serialVersionUID = 1L;

    public BigIntegerException() {
        super();
    }

    public BigIntegerException(String message) {
        super(message);
    }

    public BigIntegerException(String message, Throwable cause) {
        super(message, cause);
    }

    public BigIntegerException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: BooleanException.txt -----
package Exception;

public class BooleanException extends AppException {
    private static final long serialVersionUID = 1L;

    public BooleanException() {
        super();
    }

    public BooleanException(String message) {
        super(message);
    }

    public BooleanException(String message, Throwable cause) {
        super(message, cause);
    }

    public BooleanException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: ByteException.txt -----
package Exception;

public class ByteException extends NumericException {
    private static final long serialVersionUID = 1L;

    public ByteException() {
        super();
    }

    public ByteException(String message) {
        super(message);
    }

    public ByteException(String message, Throwable cause) {
        super(message, cause);
    }

    public ByteException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: ConnectionException.txt -----
package Exception;

public class ConnectionException extends Exception {
    private static final long serialVersionUID = 1L;

    public ConnectionException(String message) {
        super(message);
    }

    public ConnectionException(String message, Throwable cause) {
        super(message, cause);
    }
}

----- Inhalt von: CurrencyException.txt -----
package Exception;

public class CurrencyException extends DirectException {
    private static final long serialVersionUID = 1L;

    public CurrencyException() {
        super();
    }

    public CurrencyException(String message) {
        super(message);
    }

    public CurrencyException(String message, Throwable cause) {
        super(message, cause);
    }

    public CurrencyException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: DataIsNullException.txt -----
package Exception;

public class DataIsNullException extends EntryException {
    private static final long serialVersionUID = 1L;

    public DataIsNullException() {
        super();
    }

    public DataIsNullException(String message) {
        super(message);
    }

    public DataIsNullException(String message, Throwable cause) {
        super(message, cause);
    }

    public DataIsNullException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: DateException.txt -----
package Exception;

public class DateException extends AppException {
    private static final long serialVersionUID = 1L;

    public DateException() {
        super();
    }

    public DateException(String message) {
        super(message);
    }

    public DateException(String message, Throwable cause) {
        super(message, cause);
    }

    public DateException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: DirectException.txt -----
package Exception;

public class DirectException extends Exception {
    private static final long serialVersionUID = 1L;

    public DirectException() {
        super();
    }

    public DirectException(String message) {
        super(message);
    }

    public DirectException(String message, Throwable cause) {
        super(message, cause);
    }

    public DirectException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: DiscountException.txt -----
package Exception;

public class DiscountException extends DirectException {
    private static final long serialVersionUID = 1L;

    public DiscountException() {
        super();
    }

    public DiscountException(String message) {
        super(message);
    }

    public DiscountException(String message, Throwable cause) {
        super(message, cause);
    }

    public DiscountException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: DoubleException.txt -----
package Exception;

public class DoubleException extends NumericException {
    private static final long serialVersionUID = 1L;

    public DoubleException() {
        super();
    }

    public DoubleException(String message) {
        super(message);
    }

    public DoubleException(String message, Throwable cause) {
        super(message, cause);
    }

    public DoubleException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: EndDateException.txt -----
package Exception;

public class EndDateException extends DateException {
    private static final long serialVersionUID = 1L;

    public EndDateException() {
        super();
    }

    public EndDateException(String message) {
        super(message);
    }

    public EndDateException(String message, Throwable cause) {
        super(message, cause);
    }

    public EndDateException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: EntryException.txt -----
package Exception;

public class EntryException extends AppException {
    private static final long serialVersionUID = 1L;

    public EntryException() {
        super();
    }

    public EntryException(String message) {
        super(message);
    }

    public EntryException(String message, Throwable cause) {
        super(message, cause);
    }

    public EntryException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: FloatException.txt -----
package Exception;

public class FloatException extends NumericException {
    private static final long serialVersionUID = 1L;

    public FloatException() {
        super();
    }

    public FloatException(String message) {
        super(message);
    }

    public FloatException(String message, Throwable cause) {
        super(message, cause);
    }

    public FloatException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: IDNotFoundException.txt -----
package Exception;

public class IDNotFoundException extends NotFoundException {
    private static final long serialVersionUID = 1L;

    public IDNotFoundException() {
        super();
    }

    public IDNotFoundException(String message) {
        super(message);
    }

    public IDNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public IDNotFoundException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: IntException.txt -----
package Exception;

public class IntException extends NumericException {
    private static final long serialVersionUID = 1L;

    public IntException() {
        super();
    }

    public IntException(String message) {
        super(message);
    }

    public IntException(String message, Throwable cause) {
        super(message, cause);
    }

    public IntException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: LongException.txt -----
package Exception;

public class LongException extends NumericException {
    private static final long serialVersionUID = 1L;

    public LongException() {
        super();
    }

    public LongException(String message) {
        super(message);
    }

    public LongException(String message, Throwable cause) {
        super(message, cause);
    }

    public LongException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: MailException.txt -----
package Exception;

public class MailException extends StringException {
    private static final long serialVersionUID = 1L;

    public MailException() {
        super();
    }

    public MailException(String message) {
        super(message);
    }

    public MailException(String message, Throwable cause) {
        super(message, cause);
    }

    public MailException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: NotAllNecessaryDataEnteredException.txt -----
package Exception;

public class NotAllNecessaryDataEnteredException extends EntryException {
    private static final long serialVersionUID = 1L;

    public NotAllNecessaryDataEnteredException(String message) {
        super(message);
    }

    public NotAllNecessaryDataEnteredException(String message, Throwable cause) {
        super(message, cause);
    }
}

----- Inhalt von: NotFoundException.txt -----
package Exception;

public class NotFoundException extends Exception {
	private static final long serialVersionUID = 1L;

	public NotFoundException() {
		super();
	}

	public NotFoundException(String message) {
		super(message);
	}

	public NotFoundException(String message, Throwable cause) {
		super(message, cause);
	}

	public NotFoundException(Throwable cause) {
		super(cause);
	}
}

----- Inhalt von: NumericException.txt -----
package Exception;

public class NumericException extends AppException {
    private static final long serialVersionUID = 1L;

    public NumericException() {
        super();
    }

    public NumericException(String message) {
        super(message);
    }

    public NumericException(String message, Throwable cause) {
        super(message, cause);
    }

    public NumericException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: PaymentDetailsException.txt -----
package Exception;

public class PaymentDetailsException extends StringException {
    private static final long serialVersionUID = 1L;

    public PaymentDetailsException(String message) {
        super(message);
    }
}

----- Inhalt von: ShortException.txt -----
package Exception;

public class ShortException extends NumericException {
    private static final long serialVersionUID = 1L;

    public ShortException() {
        super();
    }

    public ShortException(String message) {
        super(message);
    }

    public ShortException(String message, Throwable cause) {
        super(message, cause);
    }

    public ShortException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: StartDateException.txt -----
package Exception;

public class StartDateException extends DateException {
    private static final long serialVersionUID = 1L;

    public StartDateException() {
        super();
    }

    public StartDateException(String message) {
        super(message);
    }

    public StartDateException(String message, Throwable cause) {
        super(message, cause);
    }

    public StartDateException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: StringException.txt -----
package Exception;

public class StringException extends AppException {
    private static final long serialVersionUID = 1L;

    public StringException() {
        super();
    }

    public StringException(String message) {
        super(message);
    }

    public StringException(String message, Throwable cause) {
        super(message, cause);
    }

    public StringException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: TelefonException.txt -----
package Exception;

public class TelefonException extends StringException {
    private static final long serialVersionUID = 1L;

    public TelefonException(String message) {
        super(message);
    }
}

----- Inhalt von: TimeException.txt -----
package Exception;

public class TimeException extends DateException {
    private static final long serialVersionUID = 1L;

    public TimeException() {
        super();
    }

    public TimeException(String message) {
        super(message);
    }

    public TimeException(String message, Throwable cause) {
        super(message, cause);
    }

    public TimeException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: TooLongException.txt -----
package Exception;

public class TooLongException extends StringException {
	private static final long serialVersionUID = 1L;

	public TooLongException(String message) {
		super(message);
	}
}

----- Inhalt von: TooShortException.txt -----
package Exception;

public class TooShortException extends StringException {
	private static final long serialVersionUID = 1L;

	public TooShortException(String message) {
		super(message);
	}
}

----- Inhalt von: ValueNotFoundException.txt -----
package Exception;

public class ValueNotFoundException extends NotFoundException {
    private static final long serialVersionUID = 1L;

    public ValueNotFoundException() {
        super();
    }

    public ValueNotFoundException(String message) {
        super(message);
    }

    public ValueNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public ValueNotFoundException(Throwable cause) {
        super(cause);
    }
}

----- Inhalt von: CopyCat.txt -----
package Helper;

import java.io.*;
import java.nio.file.*;
import java.util.stream.Collectors;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class CopyCat {

    public static void runCopyCat() {
        String srcFolder = "src";
        Path srcPath = Paths.get(srcFolder);

        if (!Files.isDirectory(srcPath)) {
            System.out.println("Der angegebene Pfad ist kein Verzeichnis: " + srcFolder);
            return;
        }

        try {
            // Alle .java-Dateien finden und konvertieren
            List<Path> txtFiles = Files.walk(srcPath)
                 .filter(p -> p.toString().endsWith(".java"))
                 .map(CopyCat::convertJavaToText)
                 .collect(Collectors.toList());

            // Projektwurzel über src
            Path projectRoot = srcPath.toAbsolutePath().getParent();
            if (projectRoot == null) {
                System.out.println("Kein übergeordneter Ordner gefunden.");
                return;
            }

            // Zielort: direkt im Projektordner (MitgliedermanagementKonsole)
            Path targetFolder = projectRoot; // Kein Unterordner, nur der Projektordner

            // Prüfe, ob eine bestehende Datei existiert und finde die höchste Seriennummer
            int nextSerial = 1;
            Pattern pattern = Pattern.compile("combined_java_texts(?:_(\\d+))?\\.txt");
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(targetFolder, "combined_java_texts*.txt")) {
                for (Path file : stream) {
                    String name = file.getFileName().toString();
                    Matcher matcher = pattern.matcher(name);
                    if (matcher.matches()) {
                        String numStr = matcher.group(1);
                        if (numStr != null) {
                            int num = Integer.parseInt(numStr);
                            if (num >= nextSerial) {
                                nextSerial = num + 1;
                            }
                        }
                    }
                }
            }

            // Name der neuen Datei
            String newFileName = "combined_java_texts" + (nextSerial > 1 ? "_" + nextSerial : "") + ".txt";
            Path combinedFile = targetFolder.resolve(newFileName);

            // Alle .txt Dateien zusammenfügen
            try (BufferedWriter writer = Files.newBufferedWriter(combinedFile)) {
                for (Path txtFile : txtFiles) {
                    if (txtFile != null && Files.exists(txtFile)) {
                        List<String> lines = Files.readAllLines(txtFile);
                        writer.write("----- Inhalt von: " + txtFile.getFileName() + " -----");
                        writer.newLine();
                        for (String line : lines) {
                            writer.write(line);
                            writer.newLine();
                        }
                        writer.newLine();
                    }
                }
            }

            System.out.println("Kombinierte Textdatei erstellt: " + combinedFile);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static Path convertJavaToText(Path javaFilePath) {
        try {
            String content = Files.readString(javaFilePath);
            Path txtFilePath = Paths.get(javaFilePath.toString().replaceAll("\\.java$", ".txt"));
            Files.writeString(txtFilePath, content);
            System.out.println("Konvertiert: " + javaFilePath + " -> " + txtFilePath);
            return txtFilePath;
        } catch (IOException e) {
            System.err.println("Fehler beim Verarbeiten der Datei: " + javaFilePath);
            e.printStackTrace();
            return null;
        }
    }
}

----- Inhalt von: Datum.txt -----
package Helper;

import java.util.Calendar;
import java.util.Date;
import java.util.Objects;

public class Datum {

	// Attribute

	private int tag;
	private int monat;
	private int jahr;

	// Konstruktoren

	public Datum(int j, int m, int t) {
		jahr = j;
		monat = m;
		tag = t;
	}

	public Datum() {
		jahr = setJahr();
		monat = setMonat();
		tag = setTag();
	}
	
	public Datum(Date date) {
	    Calendar cal = Calendar.getInstance();
	    cal.setTime(date);
	    this.jahr = cal.get(Calendar.YEAR);
	    this.monat = cal.get(Calendar.MONTH) + 1;
	    this.tag = cal.get(Calendar.DAY_OF_MONTH);
	}

	// Setter und Getter

	public int setTag() {
		tag = DatumHelper.readTag(jahr, monat);
		System.out.printf("Der Tag wurde auf %02d geändert.\n", tag);
		return tag;
	}

	public int setTag(int tag) {
		this.tag = tag;
		System.out.printf("Der Tag wurde auf %02d geändert.\n", tag);
		return tag;
	}

	public int setMonat() {
		monat = DatumHelper.readMonat();
		System.out.printf("Der Monat wurde auf %02d geändert.\n", monat);
		return monat;
	}

	public int setMonat(int monat) {
		this.monat = monat;
		System.out.printf("Der Monat wurde auf %02d geändert.\n", monat);
		return monat;
	}

	public int setJahr() {
		jahr = DatumHelper.readJahr();
		System.out.printf("Das Jahr wurde auf %4d geändert.\n", jahr);
		return jahr;
	}

	public int setJahr(int jahr) {
		this.jahr = jahr;
		System.out.printf("Das Jahr wurde auf %4d geändert.\n", jahr);
		return jahr;
	}

	public int getTag() {
		return tag;
	}

	public int getMonat() {
		return monat;
	}

	public int getJahr() {
		return jahr;
	}

	public String getDatum() {
		return String.format("%02d.%02d.%4d", tag, monat, jahr);
	}

	// Override
	
	@Override
	public String toString() {
		return String.format("%02d.%02d.%4d", tag, monat, jahr);
	}

	@Override
	public int hashCode() {
		return Objects.hash(jahr, monat, tag);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Datum other = (Datum) obj;
		return jahr == other.jahr && monat == other.monat && tag == other.tag;
	}
	
	// Methoden

	public static boolean testeDatum(int tag, int monat, int jahr) {

		return DatumHelper.istJahr(jahr) && DatumHelper.istMonat(monat) && DatumHelper.istTag(jahr, monat, tag);
	}

	public void printDatumDE() {
		System.out.println(toString());
	}

	public boolean isBefore(Datum other) {
	    if (this.jahr < other.jahr) {
	        return true;
	    } else if (this.jahr == other.jahr) {
	        if (this.monat < other.monat) {
	            return true;
	        } else if (this.monat == other.monat) {
	            return this.tag < other.tag;
	        }
	    }
	    return false;
	}

}

----- Inhalt von: DatumHelper.txt -----
package Helper;

import java.util.Calendar;

public class DatumHelper {
	
	// Validation
	
	public static boolean istSchaltjahr(int jahr) {
		return ((jahr % 4 == 0 && jahr % 100 != 0) || (jahr % 400 == 0));
	}

	public static boolean istJahr(int jahr) {
		return (jahr != 0);
	}

	public static boolean istMonat(int monat) {
		return monat >= 1 && monat <= 12;
	}

	public static boolean istTag(int jahr, int monat, int tag) {
		int maxtage = 31;
		return tag >= 1 && tag <= maxtage ? monat == 4 || monat == 7 || monat == 9 || monat == 11 ? tag <= maxtage - 1
				: monat == 2 ? (istSchaltjahr(jahr) ? tag <= maxtage - 2 : tag <= maxtage - 3) : true : false;
	}
		
	public static String asDE(int dtag, int dmonat, int djahr) {
		String dedat = "";
		if (dtag < 10) {
			dedat = "0" + dtag;
		} else {
			dedat = "" + dtag;
		}
		dedat += ".";
		if (dmonat < 10) {
			dedat += "0" + dmonat;
		} else {
			dedat += dmonat;
		}
		dedat += ".";
		int deneg = 0;
		if (djahr < 0) {
			deneg = -1;
		}
		djahr = Math.abs(djahr);
		if (djahr < 10) {
			dedat += "   " + djahr;
		} else if (djahr < 100) {
			dedat += "  " + djahr;
		} else if (djahr < 1000) {
			dedat += " " + djahr;
		} else if (djahr < 10000) {
			dedat += djahr;
		} else {
			dedat += djahr + " Jahreszahl zu groß! Prüfe auf Fehler!";
		}
		if (deneg < 0) {
			dedat += " v. Chr.";
		}
		return dedat;
	}
	
	// Input

	public static int readJahr() {
		int jahr = IO.readInt("Jahr: ");
		while ((!istSchaltjahr(jahr) || istSchaltjahr(jahr)) && !istJahr(jahr)) {
			System.out.printf("Das Jahr %4d gibt es nicht.\n", jahr);
			jahr = IO.readInt("Jahr: ");
		}
		return jahr;
	}

	public static int readMonat() {
		int monat = IO.readInt("Monat: ");
		while (!istMonat(monat)) {
			System.out.printf("Der Monat %02d gibt es nicht.\n", monat);
			monat = IO.readInt("Monat: ");
		}
		return monat;
	}

	public static int readTag(int jahr, int monat) {
		int tag = IO.readInt("Tag: ");
		while (!istTag(jahr, monat, tag)) {
			System.out.printf("Den Tag %02d gibt es nicht.\n", tag);
			tag = IO.readInt("Tag: ");
		}
		return tag;
	}
	
	// Methoden
	
	public static Datum getAktuellesDatum() {
	    Calendar heute = Calendar.getInstance();
	    return new Datum(
	        heute.get(Calendar.YEAR),
	        heute.get(Calendar.MONTH) + 1,
	        heute.get(Calendar.DAY_OF_MONTH)
	    );
	
	}
}

----- Inhalt von: Formater.txt -----
package Helper;

import java.util.List;
import java.util.Locale;

public class Formater {

	public static void printTabelle(List<Integer> spaltenBreiten, List<String> spaltenNamen, List<List<String>> daten) {
		// Formatstring bauen
		StringBuilder formatBuilder = new StringBuilder();
		for (int breite : spaltenBreiten) {
			formatBuilder.append("| %-").append(breite).append("s ");
		}
		formatBuilder.append("|\n");
		String format = formatBuilder.toString();

		// Trennlinie berechnen
		int trennBreite = spaltenBreiten.stream().mapToInt(b -> b + 3).sum() + 1;

		// Header
		System.out.printf(format, spaltenNamen.toArray());
		System.out.println("-".repeat(trennBreite));

		// Datensätze
		for (List<String> zeile : daten) {
			System.out.printf(format, zeile.toArray());
		}
	}

	public static String printDatum(java.util.Date date) {
		if (date == null)
			return "-";
		java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("dd.MM.yyyy");
		return sdf.format(date);
	}

	public static String printZeit(java.util.Date date) {
		if (date == null)
			return "-";
		java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("HH:mm");
		return sdf.format(date);
	}

	// Alternativ direkt für java.sql.Time:
	public static String printZeit(java.sql.Time zeit) {
		if (zeit == null)
			return "-";
		java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("HH:mm");
		return sdf.format(zeit);
	}

	public static String printWährung(double betrag, int feldBreite) {
		java.text.NumberFormat nf = java.text.NumberFormat.getNumberInstance(Locale.GERMANY);
		nf.setMinimumFractionDigits(2);
		nf.setMaximumFractionDigits(2);

		String formatted = nf.format(betrag) + " €";
		// Mit führenden Leerzeichen rechtsbündig (z. B. für Tabellenform)
		return String.format("%" + feldBreite + "s", formatted);
	}

	// Alternative für Float oder String:
	public static String printWährung(float betrag, int feldBreite) {
		return printWährung((double) betrag, feldBreite);
	}

	public static String printID(int id, int feldBreite) {
		String idStr = String.valueOf(id);
		return String.format("%" + feldBreite + "s", idStr);
	}

}

----- Inhalt von: IO.txt -----
package Helper;

import java.util.Scanner;
import java.math.BigInteger;
import java.math.BigDecimal;

import Exception.*;
import OUTDATED.OUT_BasicTypeValidator;

public class IO {

    private static final Scanner scanner = new Scanner(System.in);

    public static int readInt(String prompt) throws IntException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        int value = Integer.parseInt(input);
        OUT_BasicTypeValidator.validateInt(value);
        return value;
    }

    public static double readDouble(String prompt) throws IntException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        double value = Double.parseDouble(input);
        OUT_BasicTypeValidator.validateDouble(value);
        return value;
    }

    public static String readString(String prompt) throws StringException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        OUT_BasicTypeValidator.validateString(input);
        return input;
    }

    public static char readChar(String prompt) throws StringException {
        System.out.println(prompt);
        String line = scanner.nextLine();
        String clean = StripEntry.clean(line);
        char value = clean.isEmpty() ? '\0' : clean.charAt(0);
        OUT_BasicTypeValidator.validateCharacter(value);
        return value;
    }

    public static byte readByte(String prompt) throws IntException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        byte value = Byte.parseByte(input);
        OUT_BasicTypeValidator.validateByte(value);
        return value;
    }

    public static short readShort(String prompt) throws IntException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        short value = Short.parseShort(input);
        OUT_BasicTypeValidator.validateShort(value);
        return value;
    }

    public static long readLong(String prompt) throws IntException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        long value = Long.parseLong(input);
        OUT_BasicTypeValidator.validateLong(value);
        return value;
    }

    public static float readFloat(String prompt) throws IntException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        float value = Float.parseFloat(input);
        OUT_BasicTypeValidator.validateFloat(value);
        return value;
    }

    public static boolean readBoolean(String prompt) throws BooleanException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        boolean value = Boolean.parseBoolean(input);
        OUT_BasicTypeValidator.validateBoolean(value);
        return value;
    }

    public static String readLine(String prompt) throws StringException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        OUT_BasicTypeValidator.validateString(input);
        return input;
    }

    public static String readToken(String prompt) throws StringException {
        System.out.println(prompt);
        String input = scanner.next();
        input = StripEntry.clean(input);
        OUT_BasicTypeValidator.validateString(input);
        return input;
    }

    public static BigInteger readBigInteger(String prompt) throws IntException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        BigInteger value = new BigInteger(input);
        OUT_BasicTypeValidator.validateBigInteger(value);
        return value;
    }

    public static BigDecimal readBigDecimal(String prompt) throws IntException {
        System.out.println(prompt);
        String input = scanner.nextLine();
        input = StripEntry.clean(input);
        input = input.replace(",", ".");
        BigDecimal value = new BigDecimal(input);
        OUT_BasicTypeValidator.validateBigDecimal(value);
        return value;
    }
}

----- Inhalt von: StripEntry.txt -----
package Helper;

import java.util.regex.Pattern;

public class StripEntry {

    private static final Pattern DANGEROUS_SQL_PATTERN = Pattern.compile("(['\";-]|(\\b(SELECT|UPDATE|DELETE|INSERT|WHERE|DROP|SHOW|TRUNCATE|ALTER)\\b))", Pattern.CASE_INSENSITIVE);


    /**
     * Entfernt alle Whitespace-Zeichen am Anfang und Ende,
     * ersetzt doppelte/triple Spaces und prüft auf SQL-Injections/Gefahren
     * @param input Der zu säubernde String
     * @return der bereinigte String, mögliche gefährliche Inhalte werden ersetzt
     */
    public static String clean(String input) {
        if (input == null) return null;
        String result = input.trim();
        result = result.replaceAll("\\s{2,}", " ");
        result = DANGEROUS_SQL_PATTERN.matcher(result).replaceAll("");
        result = result.replaceAll("[\\x00\\x08\\x09\\x1a\\n\\r\\'\\\"\\\\]", "");
        return result;
    }
}

----- Inhalt von: ZeitHelper.txt -----
package Helper;

public class ZeitHelper {
	
	// Validation
	
    public static boolean istStunde(int stunde) {
        return stunde >= 0 && stunde <= 23;
    }

    public static boolean istMinute(int minute) {
        return minute >= 0 && minute <= 59;
    }

    public static boolean istSekunde(int sekunde) {
        return sekunde >= 0 && sekunde <= 59;
    }
    
    // Input
    
    public static int readStunde() {
        int stunde = IO.readInt("Stunde: ");
        while (!istStunde(stunde)) {
            System.out.printf("Die Stunde %02d gibt es nicht.\n", stunde);
            stunde = IO.readInt("Stunde: ");
        }
        return stunde;
    }
    
    public static int readMinute() {
        int minute = IO.readInt("Minute: ");
        while (!istMinute(minute)) {
            System.out.printf("Die Minute %02d gibt es nicht.\n", minute);
            minute = IO.readInt("Minute: ");
        }
        return minute;
    }

    public static int readSekunde() {
        int sekunde = IO.readInt("Sekunde: ");
        while (!istSekunde(sekunde)) {
            System.out.printf("Die Sekunde %02d gibt es nicht.\n", sekunde);
            sekunde = IO.readInt("Sekunde: ");
        }
        return sekunde;
    }
    
}

----- Inhalt von: AdminManager.txt -----
package Manager;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

import DAOs.BenutzerDAO;
import DAOs.ConnectionDB;
import DAOs.RolleDAO;
import Exception.ConnectionException;
import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Benutzer;
import Objekte.Rolle;

public class AdminManager {

    private final BenutzerDAO benutzerDAO;
    private final RolleDAO rolleDAO;

    public AdminManager() throws ConnectionException, SQLException {
        Connection connection = ConnectionDB.getConnection();
        this.benutzerDAO = new BenutzerDAO(connection);
        this.rolleDAO = new RolleDAO(connection);
    }

    // Benutzer-Methoden

    public Benutzer findBenutzerById(int id) throws SQLException, IntException, NotFoundException {
        return benutzerDAO.findById(id);
    }

    public List<Benutzer> findAllBenutzer() throws SQLException {
        return benutzerDAO.findAll();
    }

    public void createBenutzer(Benutzer benutzer) throws SQLException {
        benutzerDAO.insert(benutzer);
    }

    public void updateBenutzer(Benutzer benutzer) throws SQLException {
        benutzerDAO.update(benutzer);
    }

    public void deleteBenutzer(int id) throws SQLException {
        benutzerDAO.delete(id);
    }

    // Rolle-Methoden

    public Rolle findRolleById(int id) throws SQLException, IntException, NotFoundException {
        return rolleDAO.findById(id);
    }

    public List<Rolle> findAllRollen() throws SQLException {
        return rolleDAO.findAll();
    }

    public void createRolle(Rolle rolle) throws SQLException {
        rolleDAO.insert(rolle);
    }

    public void updateRolle(Rolle rolle) throws SQLException {
        rolleDAO.update(rolle);
    }

    public void deleteRolle(int id) throws SQLException {
        rolleDAO.delete(id);
    }

    // Weitere Admin-Funktionen können hier hinzugefügt werden
}

----- Inhalt von: BaseManager.txt -----
package Manager;

import java.util.ArrayList;
import java.util.List;

public abstract class BaseManager<T> {

    protected List<T> items = new ArrayList<>();

    // Fügt ein Element zur Liste hinzu.
    public void add(T item) {
        items.add(item);
    }

    // Entfernt ein Element aus der Liste.
    public void remove(T item) {
        items.remove(item);
    }

    // Gibt die Liste aller Elemente zurück.
    public List<T> getAll() {
        return new ArrayList<>(items);
    }

    // Löscht alle gespeicherten Elemente.
    public void clear() {
        items.clear();
    }

    // Abstrakte Methode, die spezialisierte Manager überschreiben können/müssen.
    public abstract void process();
}

----- Inhalt von: ConnectionManager.txt -----
package Manager;

import java.sql.Connection;

import DAOs.ConnectionDB;
import Exception.ConnectionException;

public class ConnectionManager {

    public ConnectionManager() {
    }

    public Connection getConnection() throws ConnectionException {
        return ConnectionDB.getConnection();
    }
}

----- Inhalt von: KursManager.txt -----
package Manager;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import DAOs.ConnectionDB;
import DAOs.KursDAO;
import DAOs.KursleitungDAO;
import DAOs.KursteilnahmeDAO;
import DAOs.KursterminDAO;
import DAOs.MitarbeiterDAO;
import DAOs.MitgliederDAO;
import Exception.ConnectionException;
import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Kurs;
import Objekte.Kursleitung;
import Objekte.Kursteilnahme;
import Objekte.Kurstermin;
import Objekte.Mitarbeiter;
import Objekte.Mitglieder;

public class KursManager extends BaseManager<Kurs> {

    private final KursDAO kursDAO;
    private final KursterminDAO kursterminDAO;
    private final KursteilnahmeDAO kursteilnahmeDAO;
    private final KursleitungDAO kursleitungDAO;
    private final MitarbeiterDAO mitarbeiterDAO;
    private final MitgliederDAO mitgliederDAO;

    public KursManager() throws ConnectionException, SQLException {
        Connection connection = ConnectionDB.getConnection();
        kursDAO = new KursDAO(connection);
        kursterminDAO = new KursterminDAO(connection);
        kursteilnahmeDAO = new KursteilnahmeDAO(connection);
        kursleitungDAO = new KursleitungDAO(connection);
        mitarbeiterDAO = new MitarbeiterDAO(connection);
        mitgliederDAO = new MitgliederDAO(connection);
    }

    // Getter für DAOs
    public KursDAO getKursDAO() {
        return kursDAO;
    }

    public KursterminDAO getKursterminDAO() {
        return kursterminDAO;
    }

    public KursteilnahmeDAO getKursteilnahmeDAO() {
        return kursteilnahmeDAO;
    }

    public KursleitungDAO getKursleitungDAO() {
        return kursleitungDAO;
    }

    public MitarbeiterDAO getMitarbeiterDAO() {
        return mitarbeiterDAO;
    }

    public MitgliederDAO getMitgliederDAO() {
        return mitgliederDAO;
    }

    @Override
    public void process() {
        // Implementiere hier spezifische Verarbeitung für Kurse
    }

    /**
     * Findet einen Kurs anhand der KursID
     */
    public Kurs findById(int kursID) throws NotFoundException, IntException, SQLException {
        Kurs kurs = kursDAO.findById(kursID);
        if (kurs == null) {
            throw new NotFoundException("Kurs mit ID " + kursID + " nicht gefunden.");
        }
        return kurs;
    }

    /**
     * Gemeinsame Suche nach einem Suchbegriff über Kurse und Termine
     *
     * @param searchTerm Suchbegriff
     * @return Liste gefundener Kurse
     */
    public List<Kurs> search(String searchTerm) throws SQLException, IntException {
        List<Kurs> result = new ArrayList<>();

        // Suche in Kursen
        List<Kurs> kurse = kursDAO.searchAllAttributes(searchTerm);
        if (kurse != null) {
            result.addAll(kurse);
        }
        // Suche in Kursterminen
        List<Kurstermin> terminResult = kursterminDAO.searchAllAttributes(searchTerm);
        if (terminResult != null) {
            for (Kurstermin termin : terminResult) {
                try {
                    Kurs kurs = kursDAO.findById(termin.getKursID());
                    if (kurs != null && !result.contains(kurs)) {
                        result.add(kurs);
                    }
                } catch (NotFoundException e) {
                    // Kurs nicht gefunden - ignorieren und weitermachen
                }
            }
        }

        // Suche in Kursleitungen/Mitarbeiter
        List<Kursleitung> kursleitungen = kursleitungDAO.searchAllAttributes(searchTerm);
        if (kursleitungen != null) {
            for (Kursleitung leitung : kursleitungen) {
                try {
                    Kurstermin termin = kursterminDAO.findById(leitung.getKursterminID());
                    if (termin != null) {
                        Kurs kurs = kursDAO.findById(termin.getKursID());
                        if (kurs != null && !result.contains(kurs)) {
                            result.add(kurs);
                        }
                    }
                } catch (Exception e) {
                }
            }
        }

        return result;
    }

    /**
     * Alle Kurstermine eines Kurses finden
     */
    public List<Kurstermin> findTermineByKursId(int kursID) throws SQLException {
        return kursterminDAO.findByKursId(kursID);
    }

    /**
     * Alle Kursteilnahmen eines Mitglieds finden
     */
    public List<Kursteilnahme> findTeilnahmenByMitgliedId(int mitgliederID) throws SQLException {
        return kursteilnahmeDAO.findByMitgliederId(mitgliederID);
    }

    /**
     * Alle Kursteilnahmen eines Kurstermins finden
     */
    public List<Kursteilnahme> findTeilnahmenByKursterminId(int kursterminID) throws SQLException {
        return kursteilnahmeDAO.findByKursterminId(kursterminID);
    }

    /**
     * Meldet ein Mitglied für einen Kurstermin an
     */
    public void meldeAnFuerKurs(int mitgliederID, int kursterminID)
            throws SQLException, IntException, NotFoundException {
        Mitglieder mitglied = mitgliederDAO.findById(mitgliederID);
        if (mitglied == null) {
            throw new NotFoundException("Mitglied mit ID " + mitgliederID + " nicht gefunden.");
        }

        Kurstermin termin = kursterminDAO.findById(kursterminID);
        if (termin == null) {
            throw new NotFoundException("Kurstermin mit ID " + kursterminID + " nicht gefunden.");
        }

        try {
            Kursteilnahme existingTeilnahme = kursteilnahmeDAO.findByCompositeKey(mitgliederID, kursterminID);
            if (existingTeilnahme != null) {
                System.out.println("Mitglied ist bereits für diesen Kurstermin angemeldet.");
                return;
            }
        } catch (NotFoundException e) {
            // Teilnahme existiert nicht - das ist OK, wir können fortfahren
        }

        Kursteilnahme teilnahme = new Kursteilnahme();
        teilnahme.setMitgliederID(mitgliederID);
        teilnahme.setKursterminID(kursterminID);
        teilnahme.setAngemeldet(true);
        teilnahme.setAnmeldezeit(new java.sql.Timestamp(System.currentTimeMillis()));
        teilnahme.setAbgemeldet(false);
        teilnahme.setAbmeldezeit(null);
        teilnahme.setAktiv(true);
        teilnahme.setKommentar(null);

        kursteilnahmeDAO.insert(teilnahme);
    }

    /**
     * Meldet ein Mitglied von einem Kurstermin ab
     */
    public void meldeAbVonKurs(int mitgliederID, int kursterminID) throws SQLException, NotFoundException {
        Kursteilnahme teilnahme = kursteilnahmeDAO.findByCompositeKey(mitgliederID, kursterminID);

        if (teilnahme == null) {
            throw new NotFoundException("Keine Anmeldung für diesen Kurstermin gefunden.");
        }
        kursteilnahmeDAO.deleteByCompositeKey(mitgliederID, kursterminID);
    }

    /**
     * Trainer (Mitarbeiter) für einen Kurstermin über Kursleitung ermitteln
     */
    public Mitarbeiter findeTrainerFürKurstermin(int kursterminID) throws SQLException, IntException {
        // Nimmt an, es gibt nur eine aktive Kursleitung je Kurstermin; sonst ersten nehmen
        List<Kursleitung> leitungen = kursleitungDAO.findAktiveLeitungByKursterminId(kursterminID);
        for (Kursleitung kursleitung : leitungen) {
            Mitarbeiter trainer = mitarbeiterDAO.findById(kursleitung.getMitarbeiterID());
            if (trainer != null) {
                return trainer;
            }
        }
        return null;
    }

    /**
     * Zeigt alle Kursteilnehmer eines Kurstermins an
     */
    public void zeigeKursteilnehmer(int kursterminID) throws SQLException, IntException, NotFoundException {
        Kurstermin termin = kursterminDAO.findById(kursterminID);
        if (termin == null) {
            System.out.println("Kurstermin nicht gefunden!");
            return;
        }

        Kurs kurs = kursDAO.findById(termin.getKursID());
        Mitarbeiter trainer = findeTrainerFürKurstermin(kursterminID);

        String terminDatumZeit = "-";
        if (termin.getTermin() != null) {
            Calendar cal = Calendar.getInstance();
            cal.setTime(termin.getTermin());
            int tag = cal.get(Calendar.DAY_OF_MONTH);
            int monat = cal.get(Calendar.MONTH) + 1;
            int jahr = cal.get(Calendar.YEAR);
            int stunde = cal.get(Calendar.HOUR_OF_DAY);
            int minute = cal.get(Calendar.MINUTE);
            terminDatumZeit = String.format("%02d.%02d.%4d %02d:%02d", tag, monat, jahr, stunde, minute);
        }

        System.out.println("\n=== Kursteilnehmer ===");
        System.out.println("Kurs: " + (kurs != null ? kurs.getBezeichnung() : "-"));
        System.out.println("Trainer: " + (trainer != null ? trainer.getVorname() + " " + trainer.getNachname() : "-"));
        System.out.println("Termin: " + terminDatumZeit);
        System.out.println();

        List<Kursteilnahme> teilnahmen = kursteilnahmeDAO.findByKursterminId(kursterminID);
        if (teilnahmen.isEmpty()) {
            System.out.println("Keine Teilnehmer angemeldet.");
            return;
        }

        System.out.printf("%-12s | %-20s | %-20s%n", "MitgliederID", "Vorname", "Nachname");
        System.out.println("-".repeat(60));

        for (Kursteilnahme teilnahme : teilnahmen) {
            Mitglieder mitglied = mitgliederDAO.findById(teilnahme.getMitgliederID());
            if (mitglied != null) {
                System.out.printf("%-12d | %-20s | %-20s%n", mitglied.getMitgliederID(), mitglied.getVorname(),
                        mitglied.getNachname());
            }
        }
    }

}

----- Inhalt von: Main.txt -----
package Manager;

import java.sql.Connection;
import java.util.Scanner;

import Helper.CopyCat;
import Exception.ConnectionException;
import Service.*;

public class Main {

    public static void main(String[] args) {
        // CopyCat als Erstes ausführen
        CopyCat.runCopyCat();

        Connection connection = null;
        Scanner scanner = new Scanner(System.in);
        ConnectionManager connectionManager = new ConnectionManager();

        try {
            connection = connectionManager.getConnection();
            System.out.println("✓ Datenbankverbindung erfolgreich!\n");

            // Services initialisieren (wie gehabt)...

            MitgliederService mitgliederService = new MitgliederService(connection, scanner);
            VerkaufService verkaufService = new VerkaufService(connection, scanner);
            KursService kursService = new KursService(connection, scanner);
            VertragService vertragService = new VertragService(connection, scanner);
            ÜbersichtService übersichtService = new ÜbersichtService(connection, scanner);
            SucheService sucheService = new SucheService(connection, scanner);
            AdminService adminService = new AdminService(connection, scanner);

            HauptmenüService hauptmenüService = new HauptmenüService(
                connection, scanner,
                mitgliederService,
                verkaufService,
                kursService,
                vertragService,
                übersichtService,
                sucheService,
                adminService         
            );

            hauptmenüService.start();

        } catch (ConnectionException e) {
            System.err.println("✗ Fehler beim Verbinden mit der Datenbank:");
            System.err.println("  " + e.getMessage());
            System.err.println("\nBitte überprüfen Sie:");
            System.err.println("  - Ist der MySQL-Server gestartet?");
            System.err.println("  - Sind die Verbindungsdaten korrekt?");
            System.err.println("  - Existiert die Datenbank 'Mitgliederverwaltung'?");
        } finally {
            scanner.close();
            if (connection != null) {
                try {
                    connection.close();
                    System.out.println("\n✓ Datenbankverbindung geschlossen.");
                } catch (Exception e) {
                    System.err.println("✗ Fehler beim Schließen der Verbindung: " + e.getMessage());
                }
            }
        }
    }
}

----- Inhalt von: MitarbeiterManager.txt -----
package Manager;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import DAOs.ConnectionDB;
import DAOs.MitarbeiterDAO;
import DAOs.OrtDAO;
import DAOs.ZahlungsdatenDAO;
import DAOs.BenutzerDAO;
import DAOs.RolleDAO;
import Exception.ConnectionException;
import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Mitarbeiter;
import Objekte.Ort;
import Objekte.Zahlungsdaten;
import Objekte.Benutzer;
import Objekte.Rolle;

public class MitarbeiterManager extends BaseManager<Mitarbeiter> {

    private final MitarbeiterDAO mitarbeiterDAO;
    private final OrtDAO ortDAO;
    private final ZahlungsdatenDAO zahlungsdatenDAO;
    private final BenutzerDAO benutzerDAO;
    private final RolleDAO rolleDAO;

    public MitarbeiterManager() throws ConnectionException, SQLException {
        Connection connection = ConnectionDB.getConnection();
        mitarbeiterDAO = new MitarbeiterDAO(connection);
        ortDAO = new OrtDAO(connection);
        zahlungsdatenDAO = new ZahlungsdatenDAO(connection);
        benutzerDAO = new BenutzerDAO(connection);
        rolleDAO = new RolleDAO(connection);
    }

    public MitarbeiterDAO getMitarbeiterDAO() {
        return mitarbeiterDAO;
    }

    public OrtDAO getOrtDAO() {
        return ortDAO;
    }

    public ZahlungsdatenDAO getZahlungsdatenDAO() {
        return zahlungsdatenDAO;
    }

    public BenutzerDAO getBenutzerDAO() {
        return benutzerDAO;
    }

    public RolleDAO getRolleDAO() {
        return rolleDAO;
    }

    @Override
    public void add(Mitarbeiter item) {
        super.add(item);
    }

    @Override
    public void remove(Mitarbeiter item) {
        super.remove(item);
    }

    @Override
    public List<Mitarbeiter> getAll() {
        return super.getAll();
    }

    @Override
    public void clear() {
        super.clear();
    }

    @Override
    public void process() {
    }

    public Mitarbeiter findById(int mitarbeiterID) throws NotFoundException, IntException, SQLException {
        Mitarbeiter mitarbeiter = mitarbeiterDAO.findById(mitarbeiterID);
        if (mitarbeiter == null) {
            throw new NotFoundException("Mitarbeiter mit ID " + mitarbeiterID + " nicht gefunden.");
        }
        return mitarbeiter;
    }

    /**
     * Gemeinsame Suche nach einem Suchbegriff über alle Attribute von Mitarbeitern,
     * Ort, Zahlungsdaten, Benutzer und Rolle.
     * 
     * @param searchTerm Suchbegriff
     * @return Liste gefundener Mitarbeiter
     */
    public List<Mitarbeiter> search(String searchTerm) throws SQLException, IntException {
        List<Mitarbeiter> result = new ArrayList<>();

        List<Mitarbeiter> mitarbeiter = mitarbeiterDAO.searchAllAttributes(searchTerm);
        if (mitarbeiter != null) {
            result.addAll(mitarbeiter);
        }

        List<Ort> orte = ortDAO.searchAllAttributes(searchTerm);
        if (orte != null) {
            for (Ort o : orte) {
                List<Mitarbeiter> ortMitarbeiter = mitarbeiterDAO.findByOrtId(o.getOrtID());
                for (Mitarbeiter m : ortMitarbeiter) {
                    if (!result.contains(m)) {
                        result.add(m);
                    }
                }
            }
        }

        List<Zahlungsdaten> zahlungsdatenListe = zahlungsdatenDAO.searchAllAttributes(searchTerm);
        if (zahlungsdatenListe != null) {
            for (Zahlungsdaten z : zahlungsdatenListe) {
                List<Mitarbeiter> zahlungsdatenMitarbeiter = mitarbeiterDAO.findByZahlungsdatenId(z.getZahlungsdatenID());
                for (Mitarbeiter m : zahlungsdatenMitarbeiter) {
                    if (!result.contains(m)) {
                        result.add(m);
                    }
                }
            }
        }

        List<Benutzer> benutzerListe = benutzerDAO.searchAllAttributes(searchTerm);
        if (benutzerListe != null) {
            for (Benutzer b : benutzerListe) {
                List<Mitarbeiter> benutzerMitarbeiter = mitarbeiterDAO.findByBenutzerId(b.getBenutzerID());
				for (Mitarbeiter m : benutzerMitarbeiter) {
					if (!result.contains(m)) {
                        result.add(m);
                    }
                }
            }
        }

        List<Rolle> rollenListe = rolleDAO.searchAllAttributes(searchTerm);
        if (rollenListe != null) {
            for (Rolle r : rollenListe) {
                List<Mitarbeiter> rollenMitarbeiter = mitarbeiterDAO.findByRolleId(r.getRolleID());
                for (Mitarbeiter m : rollenMitarbeiter) {
                    if (!result.contains(m)) {
                        result.add(m);
                    }
                }
            }
        }

        return result;
    }
}

----- Inhalt von: MitgliederManager.txt -----
package Manager;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import DAOs.ConnectionDB;
import DAOs.InteressentenDAO;
import DAOs.MitgliederDAO;
import DAOs.OrtDAO;
import DAOs.ZahlungsdatenDAO;
import Exception.ConnectionException;
import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Interessenten;
import Objekte.Mitglieder;
import Objekte.Ort;
import Objekte.Zahlungsdaten;

public class MitgliederManager extends BaseManager<Mitglieder> {

	private final MitgliederDAO mitgliederDAO;
	private final InteressentenDAO interessentenDAO;
	private final OrtDAO ortDAO;
	private final ZahlungsdatenDAO zahlungsdatenDAO;

	public MitgliederManager() throws ConnectionException, SQLException {
		Connection connection = ConnectionDB.getConnection();
		mitgliederDAO = new MitgliederDAO(connection);
		interessentenDAO = new InteressentenDAO(connection);
		ortDAO = new OrtDAO(connection);
		zahlungsdatenDAO = new ZahlungsdatenDAO(connection);
	}
	
	public int createInteressent(String vorname, String nachname, String telefon) throws Exception {
	    return interessentenDAO.findOrCreateInteressent(vorname, nachname, telefon);
	}

	public MitgliederDAO getMitgliederDAO() {
	    return mitgliederDAO;
	}

	public OrtDAO getOrtDAO() {
	    return ortDAO;
	}

	public ZahlungsdatenDAO getZahlungsdatenDAO() {
	    return zahlungsdatenDAO;
	}

	@Override
	public void add(Mitglieder item) {
		super.add(item);
	}

	@Override
	public void remove(Mitglieder item) {
		super.remove(item);
	}

	@Override
	public List<Mitglieder> getAll() {
		return super.getAll();
	}

	@Override
	public void clear() {
		super.clear();
	}

	@Override
	public void process() {
	}

	public Mitglieder findById(int MitgliederID) throws NotFoundException, IntException, SQLException {
		Mitglieder mitglied = mitgliederDAO.findById(MitgliederID);
		if (mitglied == null) {
			throw new NotFoundException("Mitglied mit ID " + MitgliederID + " nicht gefunden.");
		}
		return mitglied;
	}

	/**
	 * Gemeinsame Suche nach einem Suchbegriff über alle Attribute von Mitgliedern,
	 * Interessenten, Ort und Zahlungsdaten.
	 * 
	 * @param searchTerm Suchbegriff
	 * @return Liste gefundener Mitglieder
	 */
	public List<Mitglieder> search(String searchTerm) throws SQLException, IntException {
		List<Mitglieder> result = new ArrayList<>();

		List<Mitglieder> mitglieder = mitgliederDAO.searchAllAttributes(searchTerm);
		if (mitglieder != null) {
			result.addAll(mitglieder);
		}

		List<Interessenten> interessenten = interessentenDAO.searchAllAttributes(searchTerm);
		if (interessenten != null) {
			for (Interessenten i : interessenten) {
				List<Mitglieder> mitgliederByInteressent = mitgliederDAO.findByInteressentenId(i.getMitgliederID());
				for (Mitglieder m : mitgliederByInteressent) {
					if (!result.contains(m)) {
						result.add(m);
					}
				}
			}
		}

		List<Ort> orte = ortDAO.searchAllAttributes(searchTerm);
		if (orte != null) {
			for (Ort o : orte) {
				List<Mitglieder> ortMitglieder = mitgliederDAO.findByOrtId(o.getOrtID());
				for (Mitglieder m : ortMitglieder) {
					if (!result.contains(m)) {
						result.add(m);
					}
				}
			}
		}

		List<Zahlungsdaten> zahlungsdatenListe = zahlungsdatenDAO.searchAllAttributes(searchTerm);
		if (zahlungsdatenListe != null) {
			for (Zahlungsdaten z : zahlungsdatenListe) {
				List<Mitglieder> zahlungsdatenMitglieder = mitgliederDAO.findByZahlungsdatenId(z.getZahlungsdatenID());
				for (Mitglieder m : zahlungsdatenMitglieder) {
					if (!result.contains(m)) {
						result.add(m);
					}
				}
			}
		}
		return result;
	}
}

----- Inhalt von: TransactionManager.txt -----
package Manager;

import java.sql.Connection;
import java.sql.SQLException;

import DAOs.ConnectionDB;
import DAOs.Transaction;
import Exception.ConnectionException;

public class TransactionManager extends BaseManager<Transaction> {

    private Transaction currentTransaction;

    public TransactionManager() {
    }

    public void begin() throws ConnectionException, SQLException {
        if (currentTransaction != null && currentTransaction.isActive()) {
            throw new SQLException("Transaktion bereits aktiv");
        }
        Connection connection = ConnectionDB.getConnection();
        currentTransaction = new Transaction(connection);
    }

    public void commit() throws SQLException {
        if (currentTransaction == null || !currentTransaction.isActive()) {
            throw new SQLException("Keine aktive Transaktion");
        }
        currentTransaction.commit();
    }

    public void rollback() throws SQLException {
        if (currentTransaction == null || !currentTransaction.isActive()) {
            throw new SQLException("Keine aktive Transaktion");
        }
        currentTransaction.rollback();
    }

    public void close() throws SQLException {
        if (currentTransaction != null) {
            currentTransaction.close();
        }
    }
    
    @Override
    public void process() {
        for (Transaction tx : items) {
            try {
                if (tx.isActive()) {
                    tx.rollback();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        clear();
    }
}

----- Inhalt von: VerkaufManager.txt -----
package Manager;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import DAOs.ArtikelBestellungDAO;
import DAOs.ArtikelDAO;
import DAOs.BestellungDAO;
import DAOs.ConnectionDB;
import DAOs.KategorieDAO;
import DAOs.MitarbeiterDAO;
import DAOs.MitgliederDAO;
import DAOs.ZahlungDAO;
import Exception.ConnectionException;
import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Artikel;
import Objekte.ArtikelBestellung;
import Objekte.Bestellung;
import Objekte.Mitglieder;
import Objekte.Zahlung;

public class VerkaufManager extends BaseManager<Bestellung> {

    private final ArtikelDAO artikelDAO;
    private final KategorieDAO kategorieDAO;
    private final BestellungDAO bestellungDAO;
    private final ArtikelBestellungDAO artikelBestellungDAO;
    private final ZahlungDAO zahlungDAO;
    private final MitgliederDAO mitgliederDAO;
    private final MitarbeiterDAO mitarbeiterDAO;

    public VerkaufManager() throws ConnectionException, SQLException {
        Connection connection = ConnectionDB.getConnection();
        artikelDAO = new ArtikelDAO(connection);
        kategorieDAO = new KategorieDAO(connection);
        bestellungDAO = new BestellungDAO(connection);
        artikelBestellungDAO = new ArtikelBestellungDAO(connection);
        zahlungDAO = new ZahlungDAO(connection);
        mitgliederDAO = new MitgliederDAO(connection);
        mitarbeiterDAO = new MitarbeiterDAO(connection);
    }

    // Getter für DAOs
    public ArtikelDAO getArtikelDAO() {
        return artikelDAO;
    }

    public KategorieDAO getKategorieDAO() {
        return kategorieDAO;
    }

    public BestellungDAO getBestellungDAO() {
        return bestellungDAO;
    }

    public ArtikelBestellungDAO getArtikelBestellungDAO() {
        return artikelBestellungDAO;
    }

    public ZahlungDAO getZahlungDAO() {
        return zahlungDAO;
    }

    public MitgliederDAO getMitgliederDAO() {
        return mitgliederDAO;
    }
    
    public MitarbeiterDAO getMitarbeiterDAO() {
        return mitarbeiterDAO;
    }
    
    @Override
    public void process() {
        // Hier ggf. die spezifische Verarbeitung für Bestellungen implementieren
    }

    public Bestellung findById(int bestellungID) throws NotFoundException, IntException, SQLException {
        Bestellung bestellung = bestellungDAO.findById(bestellungID);
        if (bestellung == null) {
            throw new NotFoundException("Bestellung mit ID " + bestellungID + " nicht gefunden.");
        }
        return bestellung;
    }

    /**
     * Gemeinsame Suche nach einem Suchbegriff über Bestellungen, Artikel und Zahlungen.
     * 
     * @param searchTerm Suchbegriff
     * @return Liste gefundener Bestellungen
     */
    public List<Bestellung> search(String searchTerm) throws SQLException, IntException {
        List<Bestellung> result = new ArrayList<>();

        List<Bestellung> bestellungen = bestellungDAO.searchAllAttributes(searchTerm);
        if (bestellungen != null) {
            result.addAll(bestellungen);
        }

        List<Artikel> artikelResult = artikelDAO.searchAllAttributes(searchTerm);
        if (artikelResult != null) {
            for (Artikel artikel : artikelResult) {
                List<ArtikelBestellung> artikelBestellungen =
                    artikelBestellungDAO.findByArtikelId(artikel.getArtikelID());
                for (ArtikelBestellung ab : artikelBestellungen) {
                    Bestellung bestellung = bestellungDAO.findById(ab.getBestellungID());
                    if (bestellung != null && !result.contains(bestellung)) {
                        result.add(bestellung);
                    }
                }
            }
        }

        List<Zahlung> zahlungResult = zahlungDAO.searchAllAttributes(searchTerm);
        if (zahlungResult != null) {
            for (Zahlung zahlung : zahlungResult) {
                List<Bestellung> bestellungenByZahlung =
                    bestellungDAO.findAll().stream()
                        .filter(b -> b.getZahlungID() == zahlung.getZahlungID())
                        .toList();
                for (Bestellung bestellung : bestellungenByZahlung) {
                    if (!result.contains(bestellung)) {
                        result.add(bestellung);
                    }
                }
            }
        }

        return result;
    }

    /**
     * Findet alle Bestellungen eines Mitglieds
     */
    public List<Bestellung> findByMitgliederId(int mitgliederID) throws SQLException {
        return bestellungDAO.findByMitgliederId(mitgliederID);
    }

    /**
     * Findet alle ArtikelBestellungen zu einer Bestellung
     */
    public List<ArtikelBestellung> findArtikelBestellungen(int bestellungID) throws SQLException {
        return artikelBestellungDAO.findByBestellungId(bestellungID);
    }

    /**
     * Druckt eine formatierte Bestellungsquittung für eine gespeicherte Bestellung
     */
    public void druckeBestellungsQuittung(int bestellungID) throws SQLException, IntException, NotFoundException {
        // Bestellung laden
        Bestellung bestellung = bestellungDAO.findById(bestellungID);
        if (bestellung == null) {
            System.out.println("Bestellung nicht gefunden!");
            return;
        }

        // Mitglied laden
        Mitglieder mitglied = mitgliederDAO.findById(bestellung.getMitgliederID());

        // Zahlungsart laden
        Zahlung zahlung = zahlungDAO.findById(bestellung.getZahlungID());

        // Artikel der Bestellung laden
        List<ArtikelBestellung> artikelBestellungen = artikelBestellungDAO.findByBestellungId(bestellungID);

        System.out.println("\n" + "=".repeat(80));
        System.out.println("                          BESTELLUNGSQUITTUNG");
        System.out.println("=".repeat(80));
        System.out.println();
        System.out.println("--- Bestellung ID: " + bestellungID + " ---");
        System.out.println("Datum:         " + bestellung.getBestelldatum());
        System.out.println("Gesamtpreis:   " + String.format("%.2f €", bestellung.getGesamtpreis()));
        System.out.println();

        // Kundendaten
        if (mitglied != null) {
            System.out.println("Kunde:         " + mitglied.getVorname() + " " + mitglied.getNachname());
            System.out.println("Mitglied-ID:   " + mitglied.getMitgliederID());
        }
        System.out.println();

        // Zahlungsart
        if (zahlung != null) {
            System.out.println("Zahlungsart:   " + zahlung.getZahlungsart());
        }
        System.out.println();

        // Artikelliste mit ArtikelID-Spalte
        System.out.println("Artikel:");
        System.out.printf("%-10s | %-30s | %-15s | %5s | %12s | %12s%n", "ArtikelID", "Name", "Kategorie", "Menge", "Einzelpreis", "Summe");
        System.out.println("=".repeat(110));

        for (ArtikelBestellung ab : artikelBestellungen) {
            Artikel artikel = artikelDAO.findById(ab.getArtikelID());
            if (artikel != null) {
                String name = artikel.getName() != null ? artikel.getName() : "-";
                String kategorie = (artikel.getKategorie() != null && artikel.getKategorie().getBezeichnung() != null)
                                  ? artikel.getKategorie().getBezeichnung() : "-";
                if (name.length() > 30) {
                    name = name.substring(0, 27) + "...";
                }
                if (kategorie.length() > 15) {
                    kategorie = kategorie.substring(0, 12) + "...";
                }
                double einzelpreis = ab.getMenge() > 0 ? ab.getAufaddiert() / ab.getMenge() : 0;

                System.out.printf("%-10d | %-30s | %-15s | %5d | %12s | %12s%n",
                    artikel.getArtikelID(),
                    name,
                    kategorie,
                    ab.getMenge(),
                    String.format("%,.2f €", einzelpreis),
                    String.format("%,.2f €", ab.getAufaddiert())
                );
            }
        }

        System.out.println("=".repeat(110));
        System.out.printf("%-10s %-30s %-15s %5s %12s %12s%n", "", "", "", "", "Gesamtpreis:", String.format("%,.2f €", bestellung.getGesamtpreis()));
        System.out.println("=".repeat(80));
    }

}

----- Inhalt von: VertragManager.txt -----
package Manager;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import DAOs.ConnectionDB;
import DAOs.IntervallDAO;
import DAOs.MitgliederDAO;
import DAOs.MitgliederVertragDAO;
import DAOs.VertragDAO;
import DAOs.ZahlungDAO;
import Exception.ConnectionException;
import Exception.IntException;
import Exception.NotFoundException;
import Objekte.Intervall;
import Objekte.MitgliederVertrag;
import Objekte.Vertrag;
import Objekte.Zahlung;

public class VertragManager extends BaseManager<MitgliederVertrag> {

    private final MitgliederVertragDAO mitgliederVertragDAO;
    private final VertragDAO vertragDAO;
    private final ZahlungDAO zahlungDAO;
    private final IntervallDAO intervallDAO;
    private final MitgliederDAO mitgliederDAO;

    public VertragManager() throws ConnectionException, SQLException {
        Connection connection = ConnectionDB.getConnection();
        mitgliederVertragDAO = new MitgliederVertragDAO(connection);
        vertragDAO = new VertragDAO(connection);
        zahlungDAO = new ZahlungDAO(connection);
        intervallDAO = new IntervallDAO(connection);
        mitgliederDAO = new MitgliederDAO(connection);
    }

    public MitgliederVertragDAO getMitgliederVertragDAO() {
        return mitgliederVertragDAO;
    }

    public VertragDAO getVertragDAO() {
        return vertragDAO;
    }

    public ZahlungDAO getZahlungDAO() {
        return zahlungDAO;
    }

    public IntervallDAO getIntervallDAO() {
        return intervallDAO;
    }

    public MitgliederDAO getMitgliederDAO() {
        return mitgliederDAO;
    }
    
    @Override
    public void add(MitgliederVertrag item) {
        super.add(item);
    }

    @Override
    public void remove(MitgliederVertrag item) {
        super.remove(item);
    }

    @Override
    public List<MitgliederVertrag> getAll() {
        return super.getAll();
    }

    @Override
    public void clear() {
        super.clear();
    }

    @Override
    public void process() {
    }

    public MitgliederVertrag findById(int vertragNr) throws NotFoundException, IntException, SQLException {
        MitgliederVertrag mv = mitgliederVertragDAO.findById(vertragNr);
        if (mv == null) {
            throw new NotFoundException("MitgliederVertrag mit Nummer " + vertragNr + " nicht gefunden.");
        }
        return mv;
    }

    /**
     * Gemeinsame Suche nach einem Suchbegriff über MitgliederVertrag, Vertrag, Zahlung, Intervall.
     * @param searchTerm Suchbegriff
     * @return Liste gefundener MitgliederVerträge
     */
    public List<MitgliederVertrag> search(String searchTerm) throws SQLException, IntException {
        List<MitgliederVertrag> result = new ArrayList<>();

        List<MitgliederVertrag> vertragsListe = mitgliederVertragDAO.searchAllAttributes(searchTerm);
        if (vertragsListe != null) {
            result.addAll(vertragsListe);
        }

        List<Vertrag> vertragResult = vertragDAO.searchAllAttributes(searchTerm);
        if (vertragResult != null) {
            for (Vertrag v : vertragResult) {
                List<MitgliederVertrag> mvByVertrag = mitgliederVertragDAO.findByVertragId(v.getVertragID());
                for (MitgliederVertrag mv : mvByVertrag) {
                    if (!result.contains(mv)) {
                        result.add(mv);
                    }
                }
            }
        }

        List<Zahlung> zahlungResult = zahlungDAO.searchAllAttributes(searchTerm);
        if (zahlungResult != null) {
            for (Zahlung z : zahlungResult) {
                List<MitgliederVertrag> mvByZahlung = mitgliederVertragDAO.findByZahlungId(z.getZahlungID());
                for (MitgliederVertrag mv : mvByZahlung) {
                    if (!result.contains(mv)) {
                        result.add(mv);
                    }
                }
            }
        }

        List<Intervall> intervallResult = intervallDAO.searchAllAttributes(searchTerm);
        if (intervallResult != null) {
            for (Intervall i : intervallResult) {
                List<MitgliederVertrag> mvByIntervall = mitgliederVertragDAO.findByIntervallId(i.getIntervallID());
                for (MitgliederVertrag mv : mvByIntervall) {
                    if (!result.contains(mv)) {
                        result.add(mv);
                    }
                }
            }
        }

        return result;
    }
}

----- Inhalt von: Artikel.txt -----
package Objekte;

public class Artikel {
    private int artikelID;
    private String name;
    private double einzelpreis;
    private String kommentar;
    private Kategorie kategorie; // Änderung: Kategorie als Objekt

    // Konstruktor
    public Artikel(int artikelID, String name, double einzelpreis, String kommentar, Kategorie kategorie) {
        this.artikelID = artikelID;
        this.name = name;
        this.einzelpreis = einzelpreis;
        this.kommentar = kommentar;
        this.kategorie = kategorie;
    }

    // Leerer Konstruktor
    public Artikel() {
    }

    // Getter und Setter
    public int getArtikelID() { return artikelID; }
    public void setArtikelID(int artikelID) { this.artikelID = artikelID; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public double getEinzelpreis() { return einzelpreis; }
    public void setEinzelpreis(double einzelpreis) { this.einzelpreis = einzelpreis; }

    public String getKommentar() { return kommentar; }
    public void setKommentar(String kommentar) { this.kommentar = kommentar; }

    public Kategorie getKategorie() { return kategorie; }
    public void setKategorie(Kategorie kategorie) { this.kategorie = kategorie; }

    @Override
    public String toString() {
        return "Artikel{" +
            "artikelID=" + artikelID +
            ", name='" + name + '\'' +
            ", einzelpreis=" + einzelpreis +
            ", kommentar='" + kommentar + '\'' +
            ", kategorie=" + (kategorie != null ? kategorie.getBezeichnung() : null) +
            '}';
    }
}

----- Inhalt von: ArtikelBestellung.txt -----
package Objekte;

public class ArtikelBestellung {
    private int bestellungID;
    private int artikelID;
    private int menge;
    private double aufaddiert;

    public ArtikelBestellung() {
    }

    public ArtikelBestellung(int bestellungID, int artikelID, int menge, double aufaddiert) {
        this.bestellungID = bestellungID;
        this.artikelID = artikelID;
        this.menge = menge;
        this.aufaddiert = aufaddiert;
    }

    // Getter und Setter
    public int getBestellungID() { return bestellungID; }
    public void setBestellungID(int bestellungID) { this.bestellungID = bestellungID; }

    public int getArtikelID() { return artikelID; }
    public void setArtikelID(int artikelID) { this.artikelID = artikelID; }

    public int getMenge() { return menge; }
    public void setMenge(int menge) { this.menge = menge; }

    public double getAufaddiert() { return aufaddiert; }
    public void setAufaddiert(double aufaddiert) { this.aufaddiert = aufaddiert; }

    @Override
    public String toString() {
        return "ArtikelBestellung{" +
            "bestellungID=" + bestellungID +
            ", artikelID=" + artikelID +
            ", menge=" + menge +
            ", aufaddiert=" + aufaddiert +
            '}';
    }
}

----- Inhalt von: Benutzer.txt -----
package Objekte;

public class Benutzer {
    private int benutzerID;
    private String benutzername;
    private String passwort;
    private Rolle rolle;

    public Benutzer() {}

    public Benutzer(int benutzerID, String benutzername, String passwort, Rolle rolle) {
        this.benutzerID = benutzerID;
        this.benutzername = benutzername;
        this.passwort = passwort;
        this.rolle = rolle;
    }

    public int getBenutzerID() { return benutzerID; }
    public void setBenutzerID(int benutzerID) { this.benutzerID = benutzerID; }

    public String getBenutzername() { return benutzername; }
    public void setBenutzername(String benutzername) { this.benutzername = benutzername; }

    public String getPasswort() { return passwort; }
    public void setPasswort(String passwort) { this.passwort = passwort; }

    public Rolle getRolle() { return rolle; }
    public void setRolle(Rolle rolle) { this.rolle = rolle; }

    // Hilfsmethode, um RolleID zu bekommen (z.B. für DAO und SQL-Operationen)
    public int getRolleID() {
        return rolle != null ? rolle.getRolleID() : -1; // oder ggf. Exception werfen
    }

    @Override
    public String toString() {
        return "Benutzer{" +
                "benutzerID=" + benutzerID +
                ", benutzername='" + benutzername + '\'' +
                ", passwort='" + passwort + '\'' +
                ", rolle=" + (rolle != null ? rolle.getBezeichnung() : "-") +
                '}';
    }
}

----- Inhalt von: Bestellung.txt -----
package Objekte;

import java.sql.Timestamp;

public class Bestellung {
    private int bestellungID;
    private int mitgliederID;
    private double gesamtpreis;
    private Timestamp bestelldatum;
    private int zahlungID;
    private int mitarbeiterID; // NEU

    // Konstruktoren
    public Bestellung() {}

    public Bestellung(int bestellungID, int mitgliederID, double gesamtpreis, 
                      Timestamp bestelldatum, int zahlungID, int mitarbeiterID) {
        this.bestellungID = bestellungID;
        this.mitgliederID = mitgliederID;
        this.gesamtpreis = gesamtpreis;
        this.bestelldatum = bestelldatum;
        this.zahlungID = zahlungID;
        this.mitarbeiterID = mitarbeiterID;
    }

    // Getter und Setter
    public int getBestellungID() { return bestellungID; }
    public void setBestellungID(int bestellungID) { this.bestellungID = bestellungID; }

    public int getMitgliederID() { return mitgliederID; }
    public void setMitgliederID(int mitgliederID) { this.mitgliederID = mitgliederID; }

    public double getGesamtpreis() { return gesamtpreis; }
    public void setGesamtpreis(double gesamtpreis) { this.gesamtpreis = gesamtpreis; }

    public Timestamp getBestelldatum() { return bestelldatum; }
    public void setBestelldatum(Timestamp bestelldatum) { this.bestelldatum = bestelldatum; }

    public int getZahlungID() { return zahlungID; }
    public void setZahlungID(int zahlungID) { this.zahlungID = zahlungID; }

    public int getMitarbeiterID() { return mitarbeiterID; }
    public void setMitarbeiterID(int mitarbeiterID) { this.mitarbeiterID = mitarbeiterID; }

    @Override
    public String toString() {
        return "Bestellung{" +
                "bestellungID=" + bestellungID +
                ", mitgliederID=" + mitgliederID +
                ", gesamtpreis=" + gesamtpreis +
                ", bestelldatum=" + bestelldatum +
                ", zahlungID=" + zahlungID +
                ", mitarbeiterID=" + mitarbeiterID +
                '}';
    }
}

----- Inhalt von: Interessenten.txt -----
package Objekte;

import java.util.Objects;

public class Interessenten {

    // Attribute
    private int mitgliederID;
    private String vorname;
    private String nachname;
    private String telefon;

    // Konstruktor
    public Interessenten() { }

    public Interessenten(String vorname, String nachname, String telefon) {
        this.vorname = vorname;
        this.nachname = nachname;
        this.telefon = telefon;
    }

    public Interessenten(int mitgliederID, String vorname, String nachname, String telefon) {
        this.mitgliederID = mitgliederID;
        this.vorname = vorname;
        this.nachname = nachname;
        this.telefon = telefon;
    }

    // Getter & Setter
    public int getMitgliederID() {
        return mitgliederID;
    }

    public void setMitgliederID(int mitgliederID) {
        this.mitgliederID = mitgliederID;
    }

    public String getVorname() {
        return vorname;
    }

    public void setVorname(String vorname) {
        this.vorname = vorname;
    }

    public String getNachname() {
        return nachname;
    }

    public void setNachname(String nachname) {
        this.nachname = nachname;
    }

    public String getTelefon() {
        return telefon;
    }

    public void setTelefon(String telefon) {
        this.telefon = telefon;
    }

    // Override
    @Override
    public String toString() {
        return "Interessent:\nMitgliederID: " + mitgliederID + "\nName: " + vorname + " " + nachname + "\nTelefon: " + telefon + "\n";
    }

    @Override
    public int hashCode() {
        return Objects.hash(mitgliederID);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Interessenten)) return false;
        Interessenten other = (Interessenten) obj;
        return this.mitgliederID == other.mitgliederID;
    }
}

----- Inhalt von: Intervall.txt -----
package Objekte;

import java.util.Objects;

import OUTDATED.OUT_IntValidator;
import OUTDATED.OUT_StringValidator;

public class Intervall {
    private int intervallID;
    private String zahlungsintervall;
    private String bezeichnung;

    public Intervall() {}

    public Intervall(int intervallID, String zahlungsintervall, String bezeichnung) {
        this.intervallID = intervallID;
        this.zahlungsintervall = zahlungsintervall;
        this.bezeichnung = bezeichnung;
    }

    public Intervall(String zahlungsintervall, String bezeichnung) {
        this.zahlungsintervall = zahlungsintervall;
        this.bezeichnung = bezeichnung;
    }

    public int getIntervallID() {
        return intervallID;
    }
    public void setIntervallID(int intervallID) {
        this.intervallID = intervallID;
    }
    public String getZahlungsintervall() {
        return zahlungsintervall;
    }
    public void setZahlungsintervall(String zahlungsintervall) {
        this.zahlungsintervall = zahlungsintervall;
    }
    public String getBezeichnung() {
        return bezeichnung;
    }
    public void setBezeichnung(String bezeichnung) {
        this.bezeichnung = bezeichnung;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Intervall)) return false;
        Intervall that = (Intervall) o;
        return intervallID == that.intervallID;
    }

    @Override
    public int hashCode() {
        return Objects.hash(intervallID);
    }

    @Override
    public String toString() {
        return String.format("Intervall:\nID: %d\nZahlungsintervall: %s\nBezeichnung: %s", 
            intervallID, zahlungsintervall, bezeichnung);
    }
    
    public void validateAll() throws Exception {
        OUT_IntValidator intVal = new OUT_IntValidator();
        intVal.validate(intervallID);

        OUT_StringValidator strVal = new OUT_StringValidator();
        strVal.checkLength(bezeichnung, "Bezeichnung", 1, 100);
    }
}

----- Inhalt von: Kategorie.txt -----
package Objekte;

public class Kategorie {
    private int kategorieID;
    private String bezeichnung;

    // Konstruktor
    public Kategorie(int kategorieID, String bezeichnung) {
        this.kategorieID = kategorieID;
        this.bezeichnung = bezeichnung;
    }

    // Leerer Konstruktor
    public Kategorie() {
    }

    // Getter und Setter
    public int getKategorieID() { return kategorieID; }
    public void setKategorieID(int kategorieID) { this.kategorieID = kategorieID; }

    public String getBezeichnung() { return bezeichnung; }
    public void setBezeichnung(String bezeichnung) { this.bezeichnung = bezeichnung; }

    @Override
    public String toString() {
        return "Kategorie{" +
            "kategorieID=" + kategorieID +
            ", bezeichnung='" + bezeichnung + '\'' +
            '}';
    }
}

----- Inhalt von: Kurs.txt -----
package Objekte;

public class Kurs {
    private int kursID;
    private String bezeichnung;
    private boolean kostenfrei;
    private boolean aktiv;
    private int teilnehmerzahl;
    private int anzahlTermine;
    private double preis;
    private String kommentar;

    // Konstruktoren
    public Kurs() {}

    public Kurs(int kursID, String bezeichnung, boolean kostenfrei, boolean aktiv, int teilnehmerzahl, int anzahlTermine, double preis, String kommentar) {
        this.kursID = kursID;
        this.bezeichnung = bezeichnung;
        this.kostenfrei = kostenfrei;
        this.aktiv = aktiv;
        this.teilnehmerzahl = teilnehmerzahl;
        this.anzahlTermine = anzahlTermine;
        this.preis = preis;
        this.kommentar = kommentar;
    }

    // Getter und Setter
    public int getKursID() {
        return kursID;
    }

    public void setKursID(int kursID) {
        this.kursID = kursID;
    }

    public String getBezeichnung() {
        return bezeichnung;
    }

    public void setBezeichnung(String bezeichnung) {
        this.bezeichnung = bezeichnung;
    }

    public boolean isKostenfrei() {
        return kostenfrei;
    }

    public void setKostenfrei(boolean kostenfrei) {
        this.kostenfrei = kostenfrei;
    }

    public boolean isAktiv() {
        return aktiv;
    }

    public void setAktiv(boolean aktiv) {
        this.aktiv = aktiv;
    }

    public int getTeilnehmerzahl() {
        return teilnehmerzahl;
    }

    public void setTeilnehmerzahl(int teilnehmerzahl) {
        this.teilnehmerzahl = teilnehmerzahl;
    }

    public int getAnzahlTermine() {
        return anzahlTermine;
    }

    public void setAnzahlTermine(int anzahlTermine) {
        this.anzahlTermine = anzahlTermine;
    }

    public double getPreis() {
        return preis;
    }

    public void setPreis(double preis) {
        this.preis = preis;
    }

    public String getKommentar() {
        return kommentar;
    }

    public void setKommentar(String kommentar) {
        this.kommentar = kommentar;
    }

    @Override
    public String toString() {
        return "Kurs{" +
                "kursID=" + kursID +
                ", bezeichnung='" + bezeichnung + '\'' +
                ", kostenfrei=" + kostenfrei +
                ", aktiv=" + aktiv +
                ", teilnehmerzahl=" + teilnehmerzahl +
                ", anzahlTermine=" + anzahlTermine +
                ", preis=" + preis +
                ", kommentar='" + kommentar + '\'' +
                '}';
    }
}

----- Inhalt von: Kursleitung.txt -----
package Objekte;

import java.sql.Timestamp;

public class Kursleitung {
    private int kursterminID;
    private int mitarbeiterID;
    private boolean bestätigt;
    private Timestamp bestätigungszeit;
    private boolean abgemeldet;
    private Timestamp abmeldezeit;
    private boolean aktiv;
    private String kommentar;

    public Kursleitung() {}

    public Kursleitung(int kursterminID, int mitarbeiterID, boolean bestätigt, Timestamp bestätigungszeit,
                       boolean abgemeldet, Timestamp abmeldezeit, boolean aktiv, String kommentar) {
        this.kursterminID = kursterminID;
        this.mitarbeiterID = mitarbeiterID;
        this.bestätigt = bestätigt;
        this.bestätigungszeit = bestätigungszeit;
        this.abgemeldet = abgemeldet;
        this.abmeldezeit = abmeldezeit;
        this.aktiv = aktiv;
        this.kommentar = kommentar;
    }

    public int getKursterminID() { return kursterminID; }
    public void setKursterminID(int kursterminID) { this.kursterminID = kursterminID; }

    public int getMitarbeiterID() { return mitarbeiterID; }
    public void setMitarbeiterID(int mitarbeiterID) { this.mitarbeiterID = mitarbeiterID; }

    public boolean isBestätigt() { return bestätigt; }
    public void setBestätigt(boolean bestätigt) { this.bestätigt = bestätigt; }

    public Timestamp getBestätigungszeit() { return bestätigungszeit; }
    public void setBestätigungszeit(Timestamp bestätigungszeit) { this.bestätigungszeit = bestätigungszeit; }

    public boolean isAbgemeldet() { return abgemeldet; }
    public void setAbgemeldet(boolean abgemeldet) { this.abgemeldet = abgemeldet; }

    public Timestamp getAbmeldezeit() { return abmeldezeit; }
    public void setAbmeldezeit(Timestamp abmeldezeit) { this.abmeldezeit = abmeldezeit; }

    public boolean isAktiv() { return aktiv; }
    public void setAktiv(boolean aktiv) { this.aktiv = aktiv; }

    public String getKommentar() { return kommentar; }
    public void setKommentar(String kommentar) { this.kommentar = kommentar; }

    @Override
    public String toString() {
        return "Kursleitung{" +
                "kursterminID=" + kursterminID +
                ", mitarbeiterID=" + mitarbeiterID +
                ", bestätigt=" + bestätigt +
                ", bestätigungszeit=" + bestätigungszeit +
                ", abgemeldet=" + abgemeldet +
                ", abmeldezeit=" + abmeldezeit +
                ", aktiv=" + aktiv +
                ", kommentar='" + kommentar + '\'' +
                '}';
    }
}

----- Inhalt von: Kursteilnahme.txt -----
package Objekte;

import java.sql.Timestamp;

public class Kursteilnahme {
    
    // Zusammengesetzter Primärschlüssel
    private int mitgliederID;
    private int kursterminID;
    
    // Weitere Felder
    private boolean angemeldet;
    private Timestamp anmeldezeit;
    private boolean abgemeldet;
    private Timestamp abmeldezeit;
    private boolean aktiv;
    private String kommentar;
    
    // Konstruktoren
    public Kursteilnahme() {
    }
    
    public Kursteilnahme(int mitgliederID, int kursterminID) {
        this.mitgliederID = mitgliederID;
        this.kursterminID = kursterminID;
    }
    
    // Getter und Setter
    public int getMitgliederID() {
        return mitgliederID;
    }
    
    public void setMitgliederID(int mitgliederID) {
        this.mitgliederID = mitgliederID;
    }
    
    public int getKursterminID() {
        return kursterminID;
    }
    
    public void setKursterminID(int kursterminID) {
        this.kursterminID = kursterminID;
    }
    
    public boolean isAngemeldet() {
        return angemeldet;
    }
    
    public void setAngemeldet(boolean angemeldet) {
        this.angemeldet = angemeldet;
    }
    
    public Timestamp getAnmeldezeit() {
        return anmeldezeit;
    }
    
    public void setAnmeldezeit(Timestamp anmeldezeit) {
        this.anmeldezeit = anmeldezeit;
    }
    
    public boolean isAbgemeldet() {
        return abgemeldet;
    }
    
    public void setAbgemeldet(boolean abgemeldet) {
        this.abgemeldet = abgemeldet;
    }
    
    public Timestamp getAbmeldezeit() {
        return abmeldezeit;
    }
    
    public void setAbmeldezeit(Timestamp abmeldezeit) {
        this.abmeldezeit = abmeldezeit;
    }
    
    public boolean isAktiv() {
        return aktiv;
    }
    
    public void setAktiv(boolean aktiv) {
        this.aktiv = aktiv;
    }
    
    public String getKommentar() {
        return kommentar;
    }
    
    public void setKommentar(String kommentar) {
        this.kommentar = kommentar;
    }
}

----- Inhalt von: Kurstermin.txt -----
package Objekte;

import java.sql.Timestamp;

public class Kurstermin {
    private int kursterminID;
    private int kursID;
    private Timestamp termin;
    private int teilnehmerfrei;
    private boolean anmeldebar;
    private boolean aktiv;
    private String kommentar;

    // Konstruktoren
    public Kurstermin() {}

    public Kurstermin(int kursterminID, int kursID, Timestamp termin,
                      int teilnehmerfrei, boolean anmeldebar, boolean aktiv, String kommentar) {
        this.kursterminID = kursterminID;
        this.kursID = kursID;
        this.termin = termin;
        this.teilnehmerfrei = teilnehmerfrei;
        this.anmeldebar = anmeldebar;
        this.aktiv = aktiv;
        this.kommentar = kommentar;
    }

    public int getKursterminID() { return kursterminID; }
    public void setKursterminID(int kursterminID) { this.kursterminID = kursterminID; }

    public int getKursID() { return kursID; }
    public void setKursID(int kursID) { this.kursID = kursID; }

    public Timestamp getTermin() { return termin; }
    public void setTermin(Timestamp termin) { this.termin = termin; }

    public int getTeilnehmerfrei() { return teilnehmerfrei; }
    public void setTeilnehmerfrei(int teilnehmerfrei) { this.teilnehmerfrei = teilnehmerfrei; }

    public boolean isAnmeldebar() { return anmeldebar; }
    public void setAnmeldebar(boolean anmeldebar) { this.anmeldebar = anmeldebar; }

    public boolean isAktiv() { return aktiv; }
    public void setAktiv(boolean aktiv) { this.aktiv = aktiv; }

    public String getKommentar() { return kommentar; }
    public void setKommentar(String kommentar) { this.kommentar = kommentar; }

    @Override
    public String toString() {
        return "Kurstermin{" +
                "kursterminID=" + kursterminID +
                ", kursID=" + kursID +
                ", termin=" + termin +
                ", teilnehmerfrei=" + teilnehmerfrei +
                ", anmeldebar=" + anmeldebar +
                ", aktiv=" + aktiv +
                ", kommentar='" + kommentar + '\'' +
                '}';
    }
}

----- Inhalt von: Mitarbeiter.txt -----
package Objekte;

public class Mitarbeiter {
	private int mitarbeiterID;
	private String vorname;
	private String nachname;
	private String geburtsdatum;
	private String straße;
	private String hausnr;
	private String stadt;
	private Ort ort;
	private Zahlungsdaten zahlungsdaten;
	private String mail;
	private Benutzer benutzer;
	private String telefon;
	private boolean aktiv;

	// Standard-Konstruktor
	public Mitarbeiter() {
	}

	// Vollständiger Konstruktor
	public Mitarbeiter(int mitarbeiterID, String vorname, String nachname, String geburtsdatum, String straße,
			String hausnr, String stadt, Ort ort, Zahlungsdaten zahlungsdaten, String telefon, String mail,
			Benutzer benutzer, boolean aktiv) {
		this.mitarbeiterID = mitarbeiterID;
		this.vorname = vorname;
		this.nachname = nachname;
		this.geburtsdatum = geburtsdatum;
		this.straße = straße;
		this.hausnr = hausnr;
		this.stadt = stadt;
		this.ort = ort;
		this.zahlungsdaten = zahlungsdaten;
		this.telefon = telefon;
		this.mail = mail;
		this.benutzer = benutzer;
		this.aktiv = aktiv;
	}

	// Getter und Setter
	public int getMitarbeiterID() {
		return mitarbeiterID;
	}

	public void setMitarbeiterID(int mitarbeiterID) {
		this.mitarbeiterID = mitarbeiterID;
	}

	public String getVorname() {
		return vorname;
	}

	public void setVorname(String vorname) {
		this.vorname = vorname;
	}

	public String getNachname() {
		return nachname;
	}

	public void setNachname(String nachname) {
		this.nachname = nachname;
	}

	public String getGeburtsdatum() {
		return geburtsdatum;
	}

	public void setGeburtsdatum(String geburtsdatum) {
		this.geburtsdatum = geburtsdatum;
	}

	public String getStraße() {
		return straße;
	}

	public void setStraße(String straße) {
		this.straße = straße;
	}

	public String getHausnr() {
		return hausnr;
	}

	public void setHausnr(String hausnr) {
		this.hausnr = hausnr;
	}

	public String getStadt() {
		return stadt;
	}

	public void setStadt(String stadt) {
		this.stadt = stadt;
	}

	public Ort getOrt() {
		return ort;
	}

	public void setOrt(Ort ort) {
		this.ort = ort;
	}

	public Zahlungsdaten getZahlungsdaten() {
		return zahlungsdaten;
	}

	public void setZahlungsdaten(Zahlungsdaten zahlungsdaten) {
		this.zahlungsdaten = zahlungsdaten;
	}

	public String getMail() {
		return mail;
	}

	public void setMail(String mail) {
		this.mail = mail;
	}

	public Benutzer getBenutzer() {
		return benutzer;
	}

	public void setBenutzer(Benutzer benutzer) {
		this.benutzer = benutzer;
	}

	public String getTelefon() {
		return telefon;
	}

	public void setTelefon(String telefon) {
		this.telefon = telefon;
	}

	public boolean isAktiv() {
		return aktiv;
	}

	public void setAktiv(boolean aktiv) {
		this.aktiv = aktiv;
	}

	@Override
	public String toString() {
		return "Mitarbeiter{" + "mitarbeiterID=" + mitarbeiterID + ", vorname='" + vorname + '\'' + ", nachname='"
				+ nachname + '\'' + ", geburtsdatum='" + geburtsdatum + '\'' + ", straße='" + straße + '\''
				+ ", hausnr='" + hausnr + '\'' + ", stadt='" + stadt + '\'' + ", ort="
				+ (ort != null ? ort.getOrt() : "-") + ", zahlungsdaten="
				+ (zahlungsdaten != null ? zahlungsdaten.getName() : "-") + ", mail='" + mail + '\'' + ", telefon='"
				+ telefon + '\'' + ", benutzer=" + (benutzer != null ? benutzer.getBenutzername() : "-") + ", aktiv="
				+ aktiv + '}';
	}
}

----- Inhalt von: Mitglieder.txt -----
package Objekte;

import java.util.Date;
import java.util.Objects;

import Helper.Datum;
import Helper.DatumHelper;

public class Mitglieder extends Interessenten {

	// Attribute

	private Date geburtsdatum;
	private boolean aktiv;
	private String strasse;
	private String hausnr;
	private Ort ort;
	private int ortID;
	private Zahlungsdaten zahlungsdaten;
	private int zahlungsdatenID;
	private String mail;

	// Konstruktor

	public Mitglieder() {
		super();
	}

	public Mitglieder(String vorname, String nachname, String telefon, Date geburtstag, boolean aktiv, String strasse,
			String hausnr, int ortID, int zahlungsdatenID, String mail) {
		super(vorname, nachname, telefon);
		this.geburtsdatum = geburtstag;
		this.aktiv = aktiv;
		this.strasse = strasse;
		this.hausnr = hausnr;
		this.ortID = ortID;
		this.zahlungsdatenID = zahlungsdatenID;
		this.mail = mail;
	}

	// Neuer Konstruktor, der direkt das Zahlungsdaten-Objekt akzeptiert
	public Mitglieder(String vorname, String nachname, String telefon, Date geburtstag, boolean aktiv, String strasse,
			String hausnr, Ort ort, Zahlungsdaten zahlungsdaten, String mail) {
		super(vorname, nachname, telefon);
		this.geburtsdatum = geburtstag;
		this.aktiv = aktiv;
		this.strasse = strasse;
		this.hausnr = hausnr;
		this.ort = ort;
		this.zahlungsdaten = zahlungsdaten;
		this.ortID = ort != null ? ort.getOrtID() : 0;
		this.zahlungsdatenID = zahlungsdaten != null ? zahlungsdaten.getZahlungsdatenID() : 0;
		this.mail = mail;
	}

	public Mitglieder(int mitgliederID, String vorname, String nachname, String telefon, Date geburtstag, boolean aktiv,
			String strasse, String hausnr, Ort ort, Zahlungsdaten zahlungsdaten, String mail) {
		super(mitgliederID, vorname, nachname, telefon);
		this.geburtsdatum = geburtstag;
		this.aktiv = aktiv;
		this.strasse = strasse;
		this.hausnr = hausnr;
		this.ort = ort;
		this.zahlungsdaten = zahlungsdaten;
		this.ortID = ort != null ? ort.getOrtID() : 0;
		this.zahlungsdatenID = zahlungsdaten != null ? zahlungsdaten.getZahlungsdatenID() : 0;
		this.mail = mail;
	}

	// Setter & Getter

	public Date getGeburtsdatum() {
		return geburtsdatum;
	}

	public void setGeburtsdatum(Date geburtstag) {
		this.geburtsdatum = geburtstag;
	}

	public int berechneAlter() {
		if (geburtsdatum == null) return 0;
		Datum heute = DatumHelper.getAktuellesDatum();
		Datum geburt = new Datum(getGeburtsdatum());

		int alter = heute.getJahr() - geburt.getJahr();

		// Prüfe, ob aktuelles Datum vor dem Geburtstag in diesem Jahr liegt
		Datum geburtAktuellesJahr = new Datum(heute.getJahr(), geburt.getMonat(), geburt.getTag());
		if (heute.isBefore(geburtAktuellesJahr)) {
			alter--;
		}
		return alter;
	}

	public boolean isAktiv() {
		return aktiv;
	}

	public void setAktiv(boolean aktiv) {
		this.aktiv = aktiv;
	}

	public String getStrasse() {
		return strasse;
	}

	public void setStrasse(String strasse) {
		this.strasse = strasse;
	}

	public String getHausnr() {
		return hausnr;
	}

	public void setHausnr(String hausnr) {
		this.hausnr = hausnr;
	}

	public String getPLZ() {
		return ort != null ? ort.getPLZ() : null;
	}

	public Ort getOrt() {
		return ort;
	}

	public void setOrt(Ort ort) {
		this.ort = ort;
		this.ortID = ort != null ? ort.getOrtID() : 0;
	}

	public int getOrtID() {
		return ortID;
	}

	public void setOrtID(int ortID) {
		this.ortID = ortID;
	}

	public Zahlungsdaten getZahlungsdaten() {
		return zahlungsdaten;
	}

	public void setZahlungsdaten(Zahlungsdaten zahlungsdaten) {
		this.zahlungsdaten = zahlungsdaten;
		this.zahlungsdatenID = zahlungsdaten != null ? zahlungsdaten.getZahlungsdatenID() : 0;
	}

	public int getZahlungsdatenID() {
		return zahlungsdatenID;
	}

	public void setZahlungsdatenID(int zahlungsdatenID) {
		this.zahlungsdatenID = zahlungsdatenID;
	}

	public String getMail() {
		return mail;
	}

	public void setMail(String mail) {
		this.mail = mail;
	}

	// Override

	@Override
	public String toString() {
	    StringBuilder sb = new StringBuilder();

	    boolean hasGeburtstag = geburtsdatum != null;
	    boolean hasAlter = geburtsdatum != null && berechneAlter() > 0;
	    boolean hasAdresse = (strasse != null && !strasse.isEmpty()) 
	            || (hausnr != null && !hausnr.isEmpty())
	            || (ort != null && (
	                    (ort.getPLZ() != null && !ort.getPLZ().isEmpty()) ||
	                    (ort.getOrt() != null && !ort.getOrt().isEmpty())
	            ));
	    boolean hasMail = mail != null && !mail.isEmpty();

	    if (!hasGeburtstag && !hasAlter && !hasAdresse && !hasMail) {
	        sb.append("Interessent:\n");
	    } else {
	        sb.append("Mitglied:\n");
	    }
	    sb.append("MitgliederID: \t").append(getMitgliederID()).append("\n")
	      .append("Name: \t\t").append(getVorname()).append(" ").append(getNachname()).append("\n");

	    if (hasGeburtstag) {
	        String geburtsStr = new java.text.SimpleDateFormat("dd.MM.yyyy").format(geburtsdatum);
	        sb.append("Geburtstag: \t").append(geburtsStr).append("\n");
	    }
	    if (hasAlter) {
	        sb.append("Alter: \t\t").append(berechneAlter()).append("\n");
	    }
	    sb.append("Aktiv: \t\t").append(aktiv).append("\n");

	    if (hasAdresse) {
	        sb.append("Addresse:\n");
	        if (strasse != null && !strasse.isEmpty()) 
	            sb.append("\t\t").append(strasse);
	        if (hausnr != null && !hausnr.isEmpty())
	            sb.append(" ").append(hausnr);
	        if ((strasse != null && !strasse.isEmpty()) || (hausnr != null && !hausnr.isEmpty()))
	            sb.append("\n");
	        if (ort != null) {
	            if (ort.getPLZ() != null && !ort.getPLZ().isEmpty())
	                sb.append("\t\t").append(ort.getPLZ());
	            if (ort.getOrt() != null && !ort.getOrt().isEmpty())
	                sb.append(" ").append(ort.getOrt());
	            if ((ort.getPLZ() != null && !ort.getPLZ().isEmpty()) 
	                    || (ort.getOrt() != null && !ort.getOrt().isEmpty()))
	                sb.append("\n");
	        }
	    }

	    sb.append("Telefon: \t").append(getTelefon()).append("\n");
	    if (hasMail) {
	        sb.append("Mail: \t\t").append(mail).append("\n");
	    }

	    return sb.toString();
	}

	
	@Override
	public int hashCode() {
		return Objects.hash(getMitgliederID());
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (!(obj instanceof Mitglieder))
			return false;
		Mitglieder other = (Mitglieder) obj;
		return getMitgliederID() == other.getMitgliederID();
	}
}

----- Inhalt von: MitgliederVertrag.txt -----
package Objekte;

import java.util.Date;
import java.util.Objects;

import Helper.Datum;
import Helper.StripEntry;
import OUTDATED.OUT_BooleanValidator;
import OUTDATED.OUT_StringValidator;
import Validator.CurrencyValidator;
import Validator.DiscountValidator;
import Validator.EndDateValidator;
import Validator.PaymentValidator;

public class MitgliederVertrag {
    private int vertragNr;
    private int mitgliederID;
    private int vertragID;
    private Date vertragsbeginn;
    private Date vertragsende;
    private boolean verlängerung;
    private boolean aktiv;
    private boolean gekündigt;
    private Double preisrabatt;
    private int intervallID;
    private int zahlungID;
    private int mitarbeiterID;    // NEU
    private Date trainingsbeginn;
    private String kommentar;

    public MitgliederVertrag() {}

    public MitgliederVertrag(
            int vertragNr, int mitgliederID, int vertragID, Date vertragsbeginn, Date vertragsende,
            boolean verlängerung, boolean aktiv, boolean gekündigt, Double preisrabatt,
            int intervallID, int zahlungID, int mitarbeiterID, Date trainingsbeginn, String kommentar) {
        this.vertragNr = vertragNr;
        this.mitgliederID = mitgliederID;
        this.vertragID = vertragID;
        this.vertragsbeginn = vertragsbeginn;
        this.vertragsende = vertragsende;
        this.verlängerung = verlängerung;
        this.aktiv = aktiv;
        this.gekündigt = gekündigt;
        this.preisrabatt = preisrabatt;
        this.intervallID = intervallID;
        this.zahlungID = zahlungID;
        this.mitarbeiterID = mitarbeiterID;
        this.trainingsbeginn = trainingsbeginn;
        this.kommentar = kommentar;
    }

    // Getter & Setter
    public int getVertragNr() { return vertragNr; }
    public void setVertragNr(int vertragNr) { this.vertragNr = vertragNr; }
    public int getMitgliederID() { return mitgliederID; }
    public void setMitgliederID(int mitgliederID) { this.mitgliederID = mitgliederID; }
    public int getVertragID() { return vertragID; }
    public void setVertragID(int vertragID) { this.vertragID = vertragID; }
    public Date getVertragsbeginn() { return vertragsbeginn; }
    public void setVertragsbeginn(Date vertragsbeginn) { this.vertragsbeginn = vertragsbeginn; }
    public Date getVertragsende() { return vertragsende; }
    public void setVertragsende(Date vertragsende) { this.vertragsende = vertragsende; }
    public boolean isVerlängerung() { return verlängerung; }
    public void setVerlängerung(boolean verlängerung) { this.verlängerung = verlängerung; }
    public boolean isAktiv() { return aktiv; }
    public void setAktiv(boolean aktiv) { this.aktiv = aktiv; }
    public boolean isGekündigt() { return gekündigt; }
    public void setGekündigt(boolean gekündigt) { this.gekündigt = gekündigt; }
    public Double getPreisrabatt() { return preisrabatt; }
    public void setPreisrabatt(Double preisrabatt) { this.preisrabatt = preisrabatt; }
    public int getIntervallID() { return intervallID; }
    public void setIntervallID(int intervallID) { this.intervallID = intervallID; }
    public int getZahlungID() { return zahlungID; }
    public void setZahlungID(int zahlungID) { this.zahlungID = zahlungID; }
    public int getMitarbeiterID() { return mitarbeiterID; }        // NEU
    public void setMitarbeiterID(int mitarbeiterID) { this.mitarbeiterID = mitarbeiterID; } // NEU
    public Date getTrainingsbeginn() { return trainingsbeginn; }
    public void setTrainingsbeginn(Date trainingsbeginn) { this.trainingsbeginn = trainingsbeginn; }
    public String getKommentar() { return kommentar; }
    public void setKommentar(String kommentar) { this.kommentar = kommentar; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof MitgliederVertrag)) return false;
        MitgliederVertrag that = (MitgliederVertrag) o;
        return vertragNr == that.vertragNr;
    }

    @Override
    public int hashCode() {
        return Objects.hash(vertragNr);
    }

    @Override
    public String toString() {
        String vertragsbeginnStr = vertragsbeginn != null ? new Datum(vertragsbeginn).toString() : "-";
        String vertragsendeStr = vertragsende != null ? new Datum(vertragsende).toString() : "-";
        String trainingsbeginnStr = trainingsbeginn != null ? new Datum(trainingsbeginn).toString() : "-";
        String kommentarClean = kommentar != null ? StripEntry.clean(kommentar) : "-";

        String status = verlängerung ? "verlängert" : "nicht verlängert";
        status += aktiv ? ", aktiv" : ", nicht aktiv";
        status += gekündigt ? ", gekündigt" : ", nicht gekündigt";

        return String.format(
            "MitgliederVertrag:\n"
            + "Nr: %d | MitgliedID: %d | VertragID: %d | MitarbeiterID: %d\n"
            + "Vertragsbeginn: %s | Vertragsende: %s\n"
            + "Trainingsbeginn: %s\n"
            + "Status: %s\n"
            + "Preisrabatt: %.2f | IntervallID: %d | ZahlungID: %d\n"
            + "Kommentar: %s",
            vertragNr,
            mitgliederID,
            vertragID,
            mitarbeiterID,
            vertragsbeginnStr,
            vertragsendeStr,
            trainingsbeginnStr,
            status,
            preisrabatt != null ? preisrabatt : 0.0,
            intervallID,
            zahlungID,
            kommentarClean
        );
    }

    public void validateAll(
        Vertrag vertrag,
        Zahlung zahlung,
        Mitglieder mitglied,
        int laufzeitWochen
    ) throws Exception {
        EndDateValidator endDateValidator = new EndDateValidator(laufzeitWochen);
        endDateValidator.validate(this);

        DiscountValidator discountValidator = new DiscountValidator(vertrag);
        discountValidator.validate(this);

        CurrencyValidator currencyValidator = new CurrencyValidator();
        currencyValidator.validate(this.preisrabatt);
        this.preisrabatt = currencyValidator.getValidatedValue();

        PaymentValidator paymentValidator = new PaymentValidator(zahlung, mitglied);
        paymentValidator.validate(this);

        OUT_BooleanValidator boolValidator = new OUT_BooleanValidator();
        boolValidator.validate(this.aktiv);
        boolValidator.validate(this.gekündigt);
        boolValidator.validate(this.verlängerung);

        OUT_StringValidator oUT_StringValidator = new OUT_StringValidator();
        oUT_StringValidator.checkLength(this.kommentar, "Kommentar", 0, 500);
    }
}

----- Inhalt von: Ort.txt -----
package Objekte;

public class Ort {

	// Attribute
	private int ortID;
	private String plz;
	private String name;

	// Konstruktor
	
	public Ort() {
		
	}
	
	public Ort(String plz, String name) {
		this.plz = plz;
		this.name = name;
	}

	// Konstruktor
	public Ort(int ortID, String plz, String name) {
		this.ortID = ortID;
		this.plz = plz;
		this.name = name;
	}

	// Setter & Getter
	public int getOrtID() {
		return ortID;
	}

	public void setOrtID(int ortID) {
		this.ortID = ortID;
	}

	public String getPLZ() {
		return plz;
	}

	public void setPLZ(String plz) {
		this.plz = plz;
	}

	public String getOrt() {
		return name;
	}

	public void setOrt(String name) {
		this.name = name;
	}

	// Override
	@Override
	public boolean equals(Object o) {
		if (this == o)
			return true;
		if (!(o instanceof Ort))
			return false;
		Ort ort = (Ort) o;
		return ortID == ort.ortID && java.util.Objects.equals(plz, ort.plz) && java.util.Objects.equals(name, ort.name);
	}

	@Override
	public int hashCode() {
		return java.util.Objects.hash(ortID, plz, name);
	}

	@Override
	public String toString() {
		return "Ort:\nOrtID: " + ortID + "\nPLZ: " + plz + "\nName: " + name + "\n";
	}
}

----- Inhalt von: Rolle.txt -----
package Objekte;

public class Rolle {
    private int rolleID;
    private String bezeichnung;
    private String kommentar;

    public Rolle() {}

    public Rolle(int rolleID, String bezeichnung, String kommentar) {
        this.rolleID = rolleID;
        this.bezeichnung = bezeichnung;
        this.kommentar = kommentar;
    }

    public int getRolleID() { return rolleID; }
    public void setRolleID(int rolleID) { this.rolleID = rolleID; }

    public String getBezeichnung() { return bezeichnung; }
    public void setBezeichnung(String bezeichnung) { this.bezeichnung = bezeichnung; }

    public String getKommentar() { return kommentar; }
    public void setKommentar(String kommentar) { this.kommentar = kommentar; }

    @Override
    public String toString() {
        return "Rolle{" +
                "rolleID=" + rolleID +
                ", bezeichnung='" + bezeichnung + '\'' +
                ", kommentar='" + kommentar + '\'' +
                '}';
    }
}

----- Inhalt von: Trainer.txt -----
package Objekte;

public class Trainer {
    private int trainerID;
    private String vorname;
    private String nachname;
    private String kommentar;

    // Konstruktoren
    public Trainer() {
    }

    public Trainer(int trainerID, String vorname, String nachname, String kommentar) {
        this.trainerID = trainerID;
        this.vorname = vorname;
        this.nachname = nachname;
        this.kommentar = kommentar;
    }

    // Getter und Setter
    public int getTrainerID() {
        return trainerID;
    }

    public void setTrainerID(int trainerID) {
        this.trainerID = trainerID;
    }

    public String getVorname() {
        return vorname;
    }

    public void setVorname(String vorname) {
        this.vorname = vorname;
    }

    public String getNachname() {
        return nachname;
    }

    public void setNachname(String nachname) {
        this.nachname = nachname;
    }

    public String getKommentar() {
        return kommentar;
    }

    public void setKommentar(String kommentar) {
        this.kommentar = kommentar;
    }

    @Override
    public String toString() {
        return "Trainer{" +
                "trainerID=" + trainerID +
                ", vorname='" + vorname + '\'' +
                ", nachname='" + nachname + '\'' +
                ", kommentar='" + kommentar + '\'' +
                '}';
    }
}

----- Inhalt von: Vertrag.txt -----
package Objekte;

import java.util.Objects;

import OUTDATED.OUT_IntValidator;
import OUTDATED.OUT_StringValidator;

public class Vertrag {
    private int vertragID;
    private String bezeichnung;
    private int laufzeit;
    private double grundpreis;

    public Vertrag() {
    }

    public Vertrag(int vertragID, String bezeichnung, int laufzeit, double grundpreis) {
        this.vertragID = vertragID;
        this.bezeichnung = bezeichnung;
        this.laufzeit = laufzeit;
        this.grundpreis = grundpreis;
    }

    public Vertrag(String bezeichnung, int laufzeit, double grundpreis) {
        this.bezeichnung = bezeichnung;
        this.laufzeit = laufzeit;
        this.grundpreis = grundpreis;
    }

    public int getVertragID() {
        return vertragID;
    }

    public void setVertragID(int vertragID) {
        this.vertragID = vertragID;
    }

    public String getBezeichnung() {
        return bezeichnung;
    }

    public void setBezeichnung(String bezeichnung) {
        this.bezeichnung = bezeichnung;
    }

    public int getLaufzeit() {
        return laufzeit;
    }

    public void setLaufzeit(int laufzeit) {
        this.laufzeit = laufzeit;
    }

    public double getGrundpreis() {
        return grundpreis;
    }

    public void setGrundpreis(double grundpreis) {
        this.grundpreis = grundpreis;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (!(o instanceof Vertrag))
            return false;
        Vertrag that = (Vertrag) o;
        return vertragID == that.vertragID;
    }

    @Override
    public int hashCode() {
        return Objects.hash(vertragID);
    }

    @Override
    public String toString() {
        return String.format(
            "Vertrag:\nVertragID: %d\nBezeichnung: %s\nLaufzeit: %d\nGrundpreis: %.2f €\n",
            vertragID, bezeichnung, laufzeit, grundpreis
        );
    }

    public void validateAll() throws Exception {
        OUT_IntValidator intVal = new OUT_IntValidator();
        intVal.validate(vertragID);
        intVal.validate(laufzeit);

        OUT_StringValidator strVal = new OUT_StringValidator();
        strVal.checkLength(bezeichnung, "Bezeichnung", 1, 100);
    }
}

----- Inhalt von: Zahlung.txt -----
package Objekte;

import java.util.Objects;

import OUTDATED.OUT_IntValidator;
import OUTDATED.OUT_StringValidator;

public class Zahlung {
    private int zahlungID;
    private String zahlungsart;

    public Zahlung() {}

    public Zahlung(int zahlungID, String zahlungsart) {
        this.zahlungID = zahlungID;
        this.zahlungsart = zahlungsart;
    }

    public Zahlung(String zahlungsart) {
        this.zahlungsart = zahlungsart;
    }

    public int getZahlungID() {
        return zahlungID;
    }
    public void setZahlungID(int zahlungID) {
        this.zahlungID = zahlungID;
    }
    public String getZahlungsart() {
        return zahlungsart;
    }
    public void setZahlungsart(String zahlungsart) {
        this.zahlungsart = zahlungsart;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Zahlung)) return false;
        Zahlung that = (Zahlung) o;
        return zahlungID == that.zahlungID;
    }

    @Override
    public int hashCode() {
        return Objects.hash(zahlungID);
    }

    @Override
    public String toString() {
        return String.format("Zahlung:\nID: %d\nArt: %s", zahlungID, zahlungsart);
    }
    
    public void validateAll() throws Exception {
        OUT_IntValidator intVal = new OUT_IntValidator();
        intVal.validate(zahlungID);

        OUT_StringValidator strVal = new OUT_StringValidator();
        strVal.checkLength(zahlungsart, "Zahlungsart", 1, 50);
    }
}

----- Inhalt von: Zahlungsdaten.txt -----
package Objekte;

import java.util.Objects;

public class Zahlungsdaten {

    // Attribute
    private int zahlungsdatenID;
    private String name;
    private String iban;
    private String bic;

    // Konstruktor
    public Zahlungsdaten() {
    }

    public Zahlungsdaten(String name, String iban, String bic) {
        this.name = name;
        this.iban = iban;
        this.bic = bic;
    }

    public Zahlungsdaten(int zahlungsdatenID, String name, String iban, String bic) {
        this.zahlungsdatenID = zahlungsdatenID;
        this.name = name;
        this.iban = iban;
        this.bic = bic;
    }

    // Setter & Getter
    public int getZahlungsdatenID() {
        return zahlungsdatenID;
    }

    public void setZahlungsdatenID(int zahlungsdatenID) {
        this.zahlungsdatenID = zahlungsdatenID;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getIBAN() {
        return iban;
    }

    public void setIBAN(String iban) {
        this.iban = iban;
    }

    public String getBIC() {
        return bic;
    }

    public void setBIC(String bic) {
        this.bic = bic;
    }

    // Override
    @Override
    public String toString() {
        return "Zahlungsdaten:\nZahlungsdatenID: " + zahlungsdatenID +
               "\nName: " + name +
               "\nIBAN: " + iban +
               "\nBIC: " + bic +
               "\n";
    }

    @Override
    public int hashCode() {
        return Objects.hash(zahlungsdatenID, name, iban, bic);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Zahlungsdaten)) return false;
        Zahlungsdaten other = (Zahlungsdaten) obj;
        return zahlungsdatenID == other.zahlungsdatenID &&
               Objects.equals(name, other.name) &&
               Objects.equals(iban, other.iban) &&
               Objects.equals(bic, other.bic);
    }
}

----- Inhalt von: OUT_BasicTypeValidator.txt -----
//package OUTDATED;
//
//import Exception.StringException;
//import Validator.BaseValidator;
//import Exception.IntException;
//import Exception.LongException;
//import Exception.ShortException;
//import Exception.BasicTypeException;
//import Exception.BigDecimalException;
//import Exception.BigIntegerException;
//import Exception.BooleanException;
//import Exception.ByteException;
//import Exception.DataIsNullException;
//import Exception.DoubleException;
//import Exception.FloatException;
//
//import java.math.BigInteger;
//import java.math.BigDecimal;
//
//public class OUT_BasicTypeValidator extends BaseValidator<Object> {
//
//    @Override
//    public void validate(Object obj) throws Exception, BasicTypeException {
//        errors.clear();
//        if (obj == null) {
//            errors.add("Eingabe ist null");
//            throw new DataIsNullException("Eingabe ist null");
//        }
//
//        if (obj instanceof String) {
//            validateString(obj);
//        } else if (obj instanceof Integer) {
//            validateInt(obj);
//        } else if (obj instanceof Boolean) {
//            validateBoolean(obj);
//        } else if (obj instanceof Long) {
//            validateLong(obj);
//        } else if (obj instanceof Double) {
//            validateDouble(obj);
//        } else if (obj instanceof Float) {
//            validateFloat(obj);
//        } else if (obj instanceof Short) {
//            validateShort(obj);
//        } else if (obj instanceof Byte) {
//            validateByte(obj);
//        } else if (obj instanceof Character) {
//            validateCharacter(obj);
//        } else if (obj instanceof BigInteger) {
//            validateBigInteger(obj);
//        } else if (obj instanceof BigDecimal) {
//            validateBigDecimal(obj);
//        } else {
//            String msg = "Unbekannter Typ: " + obj.getClass().getName();
//            errors.add(msg);
//            throw new Exception(msg);
//        }
//    }
//
//    public static void validateString(Object obj) throws StringException {
//        if (!(obj instanceof String)) {
//            throw new StringException("Eingabe ist kein String.");
//        }
//    }
//
//    public static void validateInt(Object obj) throws IntException {
//        if (!(obj instanceof Integer)) {
//            throw new IntException("Eingabe ist keine ganze Zahl.");
//        }
//    }
//
//    public static void validateBoolean(Object obj) throws BooleanException {
//        if (!(obj instanceof Boolean)) {
//            throw new BooleanException("Eingabe ist kein Boolean (true/false).");
//        }
//    }
//
//    public static void validateLong(Object obj) throws LongException {
//        if (!(obj instanceof Long)) {
//            throw new LongException("Eingabe ist kein Long.");
//        }
//    }
//
//    public static void validateDouble(Object obj) throws DoubleException {
//        if (!(obj instanceof Double)) {
//            throw new DoubleException("Eingabe ist kein Double.");
//        }
//    }
//
//    public static void validateFloat(Object obj) throws FloatException {
//        if (!(obj instanceof Float)) {
//            throw new FloatException("Eingabe ist kein Float.");
//        }
//    }
//
//    public static void validateShort(Object obj) throws ShortException {
//        if (!(obj instanceof Short)) {
//            throw new ShortException("Eingabe ist kein Short.");
//        }
//    }
//
//    public static void validateByte(Object obj) throws ByteException {
//        if (!(obj instanceof Byte)) {
//            throw new ByteException("Eingabe ist kein Byte.");
//        }
//    }
//
//    public static void validateCharacter(Object obj) throws OUT_CharException  {
//        if (!(obj instanceof Character)) {
//            throw new OUT_CharException ("Eingabe ist kein Character.");
//        }
//    }
//
//    public static void validateBigInteger(Object obj) throws BigIntegerException {
//        if (!(obj instanceof BigInteger)) {
//            throw new BigIntegerException("Eingabe ist keine BigInteger-Zahl.");
//        }
//    }
//
//    public static void validateBigDecimal(Object obj) throws BigDecimalException {
//        if (!(obj instanceof BigDecimal)) {
//            throw new BigDecimalException("Eingabe ist keine BigDecimal-Zahl.");
//        }
//    }
//}

----- Inhalt von: OUT_BICValidator.txt -----
//package Validator;
//
//import java.util.regex.Pattern;
//
//import Exception.PaymentDetailsException;
//import Exception.StringException;
//
//import java.util.regex.Matcher;
//
//public class OUT_BICValidator extends StringValidator {
//
//    private static final String BIC_REGEX = "^[A-Z]{4}[A-Z]{2}[A-Z0-9]{2}([A-Z0-9]{3})?$";
//    private static final Pattern BIC_PATTERN = Pattern.compile(BIC_REGEX);
//
//    @Override
//    public void validate(Object obj) throws StringException {
//        super.validate(obj);
//        
//        if (isValid()) {
//            String bic = (String) obj;
//            
//            // ========== TEST-BYPASS ==========
//            if (bic.equalsIgnoreCase("TEST")) {
//                // TEST wird akzeptiert - keine Validierung
//                return;
//            }
//            // =================================
//            
//            Matcher matcher = BIC_PATTERN.matcher(bic);
//            if (!matcher.matches()) {
//                String msg = "Eingabe ist kein gültiger BIC.";
//                errors.add(msg);
//                throw new PaymentDetailsException(msg);
//            }
//        }
//    }
//}
package OUTDATED;



----- Inhalt von: OUT_BooleanValidator.txt -----
//package OUTDATED;
//
//import Exception.BooleanException;
//import Validator.BaseValidator;
//
//public class OUT_BooleanValidator extends BaseValidator<Object> {
//
//    @Override
//    public void validate(Object obj) throws BooleanException {
//        errors.clear();
//        if (!(obj instanceof Boolean)) {
//            String msg = "Eingabe ist kein Boolean (true/false).";
//            errors.add(msg);
//            throw new BooleanException(msg);
//        }
//    }
//}

----- Inhalt von: OUT_CharException.txt -----
//package OUTDATED;
//
//public class OUT_CharException extends BasicTypeException {
//	private static final long serialVersionUID = 1L;
//
//	public OUT_CharException() {
//		super();
//	}
//
//	public OUT_CharException(String message) {
//		super(message);
//	}
//
//	public OUT_CharException(String message, Throwable cause) {
//		super(message, cause);
//	}
//
//	public OUT_CharException(Throwable cause) {
//		super(cause);
//	}
//}

----- Inhalt von: OUT_DateTimeValidator.txt -----
//package Validator;
//
//import Exception.DateException;
//import Exception.TimeException;
//import Helper.ZeitHelper;
//
//public class OUT_DateTimeValidator extends DateValidator {
//
//    @Override
//    public void validate(Object obj) throws DateException, TimeException {
//        errors.clear();
//
//        if (!(obj instanceof String)) {
//            String msg = "Eingabe ist kein String.";
//            errors.add(msg);
//            throw new DateException(msg);
//        }
//
//        String input = (String) obj;
//        String[] parts = input.split(" ");
//        if (parts.length != 2) {
//            String msg = "Format muss 'TT.MM.JJJJ HH:mm:ss' sein.";
//            errors.add(msg);
//            throw new DateException(msg);
//        }
//
//     // Datumsteil validieren (mit DateException)
//        try {
//            super.validate(parts[0]);
//        } catch (DateException e) {
//            errors.add(e.getMessage());
//            throw e;
//        }
//
//
//        // Zeitteil validieren
//        String[] timeParts = parts[1].split(":");
//        if (timeParts.length != 3) {
//            String msg = "Uhrzeit muss im Format HH:mm:ss sein.";
//            errors.add(msg);
//            throw new TimeException(msg);
//        }
//
//        try {
//            int stunde = Integer.parseInt(timeParts[0]);
//            int minute = Integer.parseInt(timeParts[1]);
//            int sekunde = Integer.parseInt(timeParts[2]);
//
//            if (!ZeitHelper.istStunde(stunde)) {
//                String msg = "Ungültige Stunde: " + stunde;
//                errors.add(msg);
//                throw new TimeException(msg);
//            }
//            if (!ZeitHelper.istMinute(minute)) {
//                String msg = "Ungültige Minute: " + minute;
//                errors.add(msg);
//                throw new TimeException(msg);
//            }
//            if (!ZeitHelper.istSekunde(sekunde)) {
//                String msg = "Ungültige Sekunde: " + sekunde;
//                errors.add(msg);
//                throw new TimeException(msg);
//            }
//        } catch (NumberFormatException e) {
//            String msg = "Uhrzeit enthält keine gültigen Zahlenwerte.";
//            errors.add(msg);
//            throw new TimeException(msg);
//        }
//    }
//}
package OUTDATED;



----- Inhalt von: OUT_IBANValidator.txt -----
//package Validator;
//
//import java.util.regex.Pattern;
//
//import Exception.PaymentDetailsException;
//import Exception.StringException;
//
//import java.util.regex.Matcher;
//
//public class OUT_IBANValidator extends StringValidator {
//
//    private static final String IBAN_REGEX = "^[A-Z]{2}[0-9A-Z]{13,32}$";
//    private static final Pattern IBAN_PATTERN = Pattern.compile(IBAN_REGEX);
//
//    @Override
//    public void validate(Object obj) throws StringException, PaymentDetailsException {
//        super.validate(obj);
//        
//        if (isValid()) {
//            String iban = ((String) obj).replaceAll("\\s+", "");
//            
//            // ========== TEST-BYPASS ==========
//            if (iban.equalsIgnoreCase("TEST")) {
//                // TEST wird akzeptiert - keine Validierung
//                return;
//            }
//            // =================================
//            
//            // Minimallänge allgemeiner IBAN
//            if (iban.length() < 15 || iban.length() > 34) {
//                String msg = "IBAN muss zwischen 15 und 34 Zeichen lang sein.";
//                errors.add(msg);
//                throw new PaymentDetailsException(msg);
//            }
//            
//            if (iban.startsWith("DE")) {
//                // Für Deutschland: exakt 22 Stellen und Formate
//                if (iban.length() != 22) {
//                    String msg = "Deutsche IBAN muss exakt 22 Zeichen lang sein.";
//                    errors.add(msg);
//                    throw new PaymentDetailsException(msg);
//                }
//                
//                String bankCode = iban.substring(4, 12);
//                String accountNum = iban.substring(12, 22);
//                if (!bankCode.matches("\\d{8}") || !accountNum.matches("\\d{10}")) {
//                    String msg = "BLZ oder Kontonummer hat falsches Format (nur Ziffern, BLZ=8, Kto=10).";
//                    errors.add(msg);
//                    throw new PaymentDetailsException(msg);
//                }
//                
//            } else {
//                // Für alle anderen Länder: maximal 34 Zeichen
//                if (iban.length() > 34) {
//                    String msg = "Internationale IBAN darf maximal 34 Zeichen haben.";
//                    errors.add(msg);
//                    throw new PaymentDetailsException(msg);
//                }
//            }
//            
//            Matcher matcher = IBAN_PATTERN.matcher(iban);
//            if (!matcher.matches()) {
//                String msg = "Eingabe entspricht nicht dem IBAN-Format.";
//                errors.add(msg);
//                throw new PaymentDetailsException(msg);
//            } else if (!isValidIBAN(iban)) {
//                String msg = "IBAN ist ungültig (Prüfziffernfehler).";
//                errors.add(msg);
//                throw new PaymentDetailsException(msg);
//            }
//        }
//    }
//
//    // Prüfziffern-Check nach Modulo 97
//    private boolean isValidIBAN(String iban) {
//        String rearranged = iban.substring(4) + iban.substring(0, 4);
//        StringBuilder numericIBAN = new StringBuilder();
//        
//        for (char ch : rearranged.toCharArray()) {
//            if (Character.isDigit(ch)) {
//                numericIBAN.append(ch);
//            } else {
//                numericIBAN.append(Character.getNumericValue(ch));
//            }
//        }
//        
//        String checkString = numericIBAN.toString();
//        int mod = 0;
//        for (int i = 0; i < checkString.length(); i += 7) {
//            int end = Math.min(i + 7, checkString.length());
//            String part = mod + checkString.substring(i, end);
//            mod = Integer.parseInt(part) % 97;
//        }
//        
//        return mod == 1;
//    }
//}
package OUTDATED;



----- Inhalt von: OUT_IntValidator.txt -----
//package OUTDATED;
//
//import Exception.IntException;
//import Validator.BaseValidator;
//
//public class OUT_IntValidator extends BaseValidator<Object> {
//
//    @Override
//    public void validate(Object obj) throws IntException {
//        errors.clear();
//        if (!(obj instanceof Integer)) {
//            String msg = "Eingabe ist keine ganze Zahl (Integer).";
//            errors.add(msg);
//            throw new IntException(msg);
//        }
//    }
//}

----- Inhalt von: OUT_MailValidator.txt -----
//package Validator;
//
//import java.util.regex.Pattern;
//
//import Exception.MailException;
//import Exception.StringException;
//
//import java.util.regex.Matcher;
//
//public class OUT_MailValidator extends StringValidator {
//
//    // Einfache Regex für E-Mail-Adressen (für Demo-Zwecke)
//    private static final String EMAIL_REGEX = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$";
//    private static final Pattern EMAIL_PATTERN = Pattern.compile(EMAIL_REGEX);
//
//    @Override
//    public void validate(Object obj) throws StringException {
//        super.validate(obj);
//        if (isValid()) {
//            String email = (String) obj;
//            Matcher matcher = EMAIL_PATTERN.matcher(email);
//            if (!matcher.matches()) {
//                String msg = "Eingabe ist keine gültige E-Mail-Adresse.";
//                errors.add(msg);
//                throw new MailException(msg); // Keine Override-Fehler!
//            }
//        }
//    }
//}
//
//
//
////EMailValidator emailValidator = new EmailValidator();
////
////String testEmail = "test@example.com";
////emailValidator.validate(testEmail);
////
////if (!emailValidator.isValid()) {
////    System.out.println("Fehler bei der E-Mail:");
////    for (String err : emailValidator.getErrors()) {
////        System.out.println(err);
////    }
////    emailValidator.saveErrorsToCsv();
////} else {
////    System.out.println("E-Mail ist gültig.");
////}
package OUTDATED;



----- Inhalt von: OUT_StringValidator.txt -----
//package OUTDATED;
//
//import Exception.StringException;
//import Validator.BaseValidator;
//
//public class OUT_StringValidator extends BaseValidator<Object> {
//
//	@Override
//	public void validate(Object obj) throws StringException {
//	    errors.clear();
//	    if (!(obj instanceof String)) {
//	        String msg = "Eingabe ist kein String.";
//	        errors.add(msg);
//	        throw new StringException(msg);
//	    }
//	}
//}

----- Inhalt von: OUT_TelefonValidator.txt -----
//package Validator;
//
//import Exception.StringException;
//import Exception.TelefonException;
//
//import java.util.regex.Pattern;
//import java.util.regex.Matcher;
//import java.util.*;
//
//public class OUT_TelefonValidator extends StringValidator {
//
//	// Land -> {minLänge, maxLänge}
//	private static final Map<String, int[]> COUNTRY_CODES = Map.ofEntries(Map.entry("+49", new int[] { 11, 13 }), // Deutschland
//			Map.entry("+43", new int[] { 11, 13 }), // Österreich
//			Map.entry("+41", new int[] { 11, 12 }), // Schweiz
//			Map.entry("+33", new int[] { 11, 12 }), // Frankreich
//			Map.entry("+32", new int[] { 11, 12 }), // Belgien
//			Map.entry("+31", new int[] { 11, 12 }), // Niederlande
//			Map.entry("+352", new int[] { 11, 13 }), // Luxemburg
//			Map.entry("+39", new int[] { 11, 13 }), // Italien
//			Map.entry("+34", new int[] { 11, 12 }), // Spanien
//			Map.entry("+351", new int[] { 11, 13 }), // Portugal
//			Map.entry("+45", new int[] { 9, 11 }), // Dänemark
//			Map.entry("+46", new int[] { 11, 13 }), // Schweden
//			Map.entry("+47", new int[] { 9, 11 }), // Norwegen
//			Map.entry("+358", new int[] { 11, 13 }), // Finnland
//			Map.entry("+48", new int[] { 11, 12 }), // Polen
//			Map.entry("+420", new int[] { 12, 13 }), // Tschechien
//			Map.entry("+36", new int[] { 11, 12 }), // Ungarn
//			Map.entry("+30", new int[] { 11, 13 }), // Griechenland
//			Map.entry("+421", new int[] { 12, 13 }), // Slowakei
//			Map.entry("+40", new int[] { 11, 12 }), // Rumänien
//			Map.entry("+359", new int[] { 11, 13 }), // Bulgarien
//			Map.entry("+385", new int[] { 11, 13 }), // Kroatien
//			Map.entry("+381", new int[] { 11, 12 }), // Serbien
//			Map.entry("+386", new int[] { 11, 13 }), // Slowenien
//			Map.entry("+387", new int[] { 11, 13 }), // Bosnien und Herzegowina
//			Map.entry("+389", new int[] { 11, 13 }), // Mazedonien
//			Map.entry("+382", new int[] { 11, 13 }), // Montenegro
//			Map.entry("+355", new int[] { 11, 13 }), // Albanien
//			Map.entry("+372", new int[] { 11, 13 }), // Estland
//			Map.entry("+371", new int[] { 11, 13 }), // Lettland
//			Map.entry("+370", new int[] { 11, 13 }), // Litauen
//			Map.entry("+353", new int[] { 11, 13 }), // Irland
//			Map.entry("+44", new int[] { 11, 13 }), // Großbritannien / Vereinigtes Königreich
//			Map.entry("+354", new int[] { 10, 11 }), // Island
//			Map.entry("+423", new int[] { 10, 12 }) // Liechtenstein
//	);
//
//	// Land -> Internationale Schreibweise (Beispiel)
//	private static final Map<String, String> COUNTRY_INTL_FORMATS = Map.ofEntries(Map.entry("+49", "+49 170 1234567"),
//			Map.entry("+43", "+43 660 1234567"), Map.entry("+41", "+41 79 123 45 67"),
//			Map.entry("+33", "+33 1 23 45 67 89"), Map.entry("+32", "+32 12 34 56 78"),
//			Map.entry("+31", "+31 6 12345678"), Map.entry("+352", "+352 26 123456"),
//			Map.entry("+39", "+39 347 1234567"), Map.entry("+34", "+34 612 34 56 78"),
//			Map.entry("+351", "+351 912 345 678"), Map.entry("+45", "+45 12 34 56 78"),
//			Map.entry("+46", "+46 70 123 45 67"), Map.entry("+47", "+47 123 45 678"),
//			Map.entry("+358", "+358 40 1234567"), Map.entry("+48", "+48 123 456 789"),
//			Map.entry("+420", "+420 123 456 789"), Map.entry("+36", "+36 30 123 4567"),
//			Map.entry("+30", "+30 210 1234567"), Map.entry("+421", "+421 901 234 567"),
//			Map.entry("+40", "+40 721 234 567"), Map.entry("+359", "+359 88 123 4567"),
//			Map.entry("+385", "+385 91 234 5678"), Map.entry("+381", "+381 64 1234567"),
//			Map.entry("+386", "+386 40 123 456"), Map.entry("+387", "+387 61 123 456"),
//			Map.entry("+389", "+389 70 123 456"), Map.entry("+382", "+382 67 123 456"),
//			Map.entry("+355", "+355 69 123 4567"), Map.entry("+372", "+372 5123 4567"),
//			Map.entry("+371", "+371 22 123 456"), Map.entry("+370", "+370 612 34567"),
//			Map.entry("+353", "+353 85 123 4567"), Map.entry("+44", "+44 7700 900123"),
//			Map.entry("+354", "+354 660 1234"), Map.entry("+423", "+423 123 4567"));
//
//	private static final String DE_VORWAHL = "+49";
//    private static final String LANDESVORWAHL_REGEX = "^(\\+\\d{1,4}|00\\d{1,4})";
//    private static final Pattern LANDESVORWAHL_PATTERN = Pattern.compile(LANDESVORWAHL_REGEX);
//
//    private static final String NUMMER_REGEX = "^[+]?\\d{1,4}[\\d \\-()/]*$";
//    private static final Pattern NUMMER_PATTERN = Pattern.compile(NUMMER_REGEX);
//
//    public String validateUndFormat(Object obj) throws StringException, TelefonException {
//        super.validate(obj);
//        if (!isValid())
//            throw new TelefonException("Ungültige Eingabe.");
//
//        String rawInput = (String) obj;
//        // Nur Ziffern, +, - und Satzzeichen zulassen
//        String cleaned = rawInput.replaceAll("[^\\d+]", "");
//        Matcher vorwahlMatcher = LANDESVORWAHL_PATTERN.matcher(cleaned);
//
//        String ländervorwahl = null;
//        String restNummer = cleaned;
//
//        // Prüfe, ob Ländervorwahl vorhanden ist und extrahiere sie
//        if (vorwahlMatcher.find()) {
//            ländervorwahl = vorwahlMatcher.group();
//            restNummer = cleaned.substring(vorwahlMatcher.end());
//            if (ländervorwahl.startsWith("00")) {
//                ländervorwahl = "+" + ländervorwahl.substring(2);
//            }
//        } else {
//            // Kein Ländervorwahl -> setze deutsche Ländervorwahl
//            ländervorwahl = DE_VORWAHL;
//            restNummer = cleaned.replaceFirst("^0+", ""); // entferne führende Null(en)
//        }
//
//        String validNummer = ländervorwahl + restNummer;
//
//        // Formatierung und Längenprüfung
//        int gesamtLänge = validNummer.length();
//        int[] lengthRange = COUNTRY_CODES.getOrDefault(ländervorwahl, new int[] { 10, 16 });
//        if (gesamtLänge < lengthRange[0] || gesamtLänge > lengthRange[1]) {
//            throw new TelefonException("Nummer passt nicht zur Ländervorwahl oder ist zu kurz/lang.");
//        }
//
//        Matcher nummerMatcher = NUMMER_PATTERN.matcher(validNummer);
//        if (!nummerMatcher.matches()) {
//            throw new TelefonException("Ungültiges Nummernformat!");
//        }
//
//        // Nummer in die internationale Schreibweise formatieren
//        String intlFormat = COUNTRY_INTL_FORMATS.getOrDefault(ländervorwahl, validNummer);
//
//        // Dynamische Formatierung anhand Beispielnummer
//        return formatTelefonnummer(validNummer, intlFormat);
//    }
//
//
//    /**
//     * Formatiert die Telefonnummer so, dass sie dem Leerzeichen-Muster der Beispielnummer entspricht.
//     * @param rawNumber Rohformatierte Nummer, z.B. "+491701234567"
//     * @param laenderBeispiel z.B. "+49 170 1234567"
//     * @return die formatierte Nummer, z.B. "+49 170 1234567"
//     */
//    public static String formatTelefonnummer(String rawNumber, String laenderBeispiel) {
//        String[] gruppen = laenderBeispiel.split(" ");
//
//        // Rohnummer bereinigen
//        String cleanNumber = rawNumber.replaceAll("[^\\d+]", "");
//
//        // Ländervorwahl entfernen
//        String laenderVorwahl = gruppen[0];
//        String nummerohneVorwahl;
//        if (cleanNumber.startsWith(laenderVorwahl)) {
//            nummerohneVorwahl = cleanNumber.substring(laenderVorwahl.length());
//        } else {
//            nummerohneVorwahl = cleanNumber;
//        }
//
//        // Gruppengröße des Beispiels berechnen
//        List<Integer> gruppenLaenge = new ArrayList<>();
//        for (int i = 1; i < gruppen.length; i++) {
//            gruppenLaenge.add(gruppen[i].length());
//        }
//
//        // Nummer entsprechend zuschneiden
//        List<String> nummerGruppiert = new ArrayList<>();
//        int start = 0;
//        for (int len : gruppenLaenge) {
//            if (start + len <= nummerohneVorwahl.length()) {
//                nummerGruppiert.add(nummerohneVorwahl.substring(start, start + len));
//                start += len;
//            } else {
//                nummerGruppiert.add(nummerohneVorwahl.substring(start));
//                break;
//            }
//        }
//
//        return laenderVorwahl + " " + String.join(" ", nummerGruppiert);
//    }
//}
package OUTDATED;



----- Inhalt von: AdminService.txt -----
package Service;

import java.sql.Connection;
import java.util.*;

import Helper.Formater;
import Manager.KursManager;
import Manager.MitgliederManager;
import Manager.MitarbeiterManager;
import Manager.VerkaufManager;
import Manager.VertragManager;

import Objekte.*;

public class AdminService extends BaseService {

	private VerkaufManager verkaufManager;
	private VertragManager vertragManager;
	private KursManager kursManager;
	private MitgliederManager mitgliederManager;
	private MitarbeiterManager mitarbeiterManager;

	public AdminService(Connection connection, Scanner scanner) {
		super(connection, scanner);
		try {
			this.verkaufManager = new VerkaufManager();
		} catch (Exception e) {
			System.out.println("Fehler beim Initialisieren des VerkaufManagers: " + e.getMessage());
		}
		try {
			this.vertragManager = new VertragManager();
		} catch (Exception e) {
			System.out.println("Fehler beim Initialisieren des VertragManagers: " + e.getMessage());
		}
		try {
			this.kursManager = new KursManager();
		} catch (Exception e) {
			System.out.println("Fehler beim Initialisieren des KursManagers: " + e.getMessage());
		}
		try {
			this.mitgliederManager = new MitgliederManager();
		} catch (Exception e) {
			System.out.println("Fehler beim Initialisieren des MitgliederManagers: " + e.getMessage());
		}
		try {
			this.mitarbeiterManager = new MitarbeiterManager();
		} catch (Exception e) {
			System.out.println("Fehler beim Initialisieren des MitarbeiterManagers: " + e.getMessage());
		}
	}

	public void start() {
		boolean zurueck = false;
		while (!zurueck) {
			System.out.println("==== Admin-Menü ====");
			System.out.println("1 - Verkauf");
			System.out.println("2 - Vertrag");
			System.out.println("3 - Kurs");
			System.out.println("4 - Personen");
			System.out.println("5 - Zurück zum Hauptmenü");
			System.out.print("Bitte wählen: ");
			String eingabe = scanner.nextLine();

			switch (eingabe) {
			case "1":
				verkaufMenue();
				break;
			case "2":
				vertragMenue();
				break;
			case "3":
				kursMenue();
				break;
			case "4":
				personenMenue();
				break;
			case "5":
				zurueck = true;
				break;
			default:
				System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
			}
		}
	}

	private void verkaufMenue() {
		boolean zurueck = false;
		while (!zurueck) {
			System.out.println("==== Verkauf-Menü ====");
			System.out.println("1 - Kategorie");
			System.out.println("2 - Artikel");
			System.out.println("3 - ArtikelBestellung");
			System.out.println("4 - Bestellung");
			System.out.println("5 - Zahlung");
			System.out.println("6 - Zurück");
			System.out.print("Bitte wählen: ");
			String eingabe = scanner.nextLine();

			switch (eingabe) {
			case "1":
				verwalteKategorie();
				break;
			case "2":
				verwalteArtikel();
				break;
			case "3":
				verwalteArtikelBestellung();
				break;
			case "4":
				verwalteBestellung();
				break;
			case "5":
				verwalteZahlung();
				break;
			case "6":
				zurueck = true;
				break;
			default:
				System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
			}
		}
	}

	private void personenMenue() {
		boolean zurueck = false;
		while (!zurueck) {
			System.out.println("==== Personen-Menü ====");
			System.out.println("1 - Mitglieder-Menü");
			System.out.println("2 - Mitarbeiter-Menü");
			System.out.println("3 - Zurück");
			System.out.print("Bitte wählen: ");
			String eingabe = scanner.nextLine();

			switch (eingabe) {
			case "1":
				mitgliederMenue();
				break;
			case "2":
				mitarbeiterMenue();
				break;
			case "3":
				zurueck = true;
				break;
			default:
				System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
			}
		}
	}

	private void mitgliederMenue() {
		boolean zurueck = false;
		while (!zurueck) {
			System.out.println("==== Mitglieder-Menü ====");
			System.out.println("1 - Mitglieder");
			System.out.println("2 - Ort");
			System.out.println("3 - Zahlungsdaten");
			System.out.println("4 - Zurück");
			System.out.print("Bitte wählen: ");
			String eingabe = scanner.nextLine();

			switch (eingabe) {
			case "1":
				verwalteMitglieder();
				break;
			case "2":
				verwalteOrt();
				break;
			case "3":
				verwalteZahlungsdaten();
				break;
			case "4":
				zurueck = true;
				break;
			default:
				System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
			}
		}
	}

	private void mitarbeiterMenue() {
		boolean zurueck = false;
		while (!zurueck) {
			System.out.println("==== Mitarbeiter-Menü ====");
			System.out.println("1 - Mitarbeiter");
			System.out.println("2 - Ort");
			System.out.println("3 - Zahlungsdaten");
			System.out.println("4 - Benutzer");
			System.out.println("5 - Rolle");
			System.out.println("6 - Zurück");
			System.out.print("Bitte wählen: ");
			String eingabe = scanner.nextLine();

			switch (eingabe) {
			case "1":
				verwalteMitarbeiter();
				break;
			case "2":
				verwalteOrt();
				break;
			case "3":
				verwalteZahlungsdaten();
				break;
			case "4":
				verwalteBenutzer();
				break;
			case "5":
				verwalteRolle();
				break;
			case "6":
				zurueck = true;
				break;
			default:
				System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
			}
		}
	}

	private void verwalteKategorie() {
		try {
			var kategorien = verkaufManager.getKategorieDAO().findAll();

			List<String> headers = Arrays.asList("KategorieID", "Bezeichnung");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>(Arrays.asList("KategorieID".length(), "Bezeichnung".length()));

			for (Kategorie k : kategorien) {
				List<String> row = Arrays.asList(String.valueOf(k.getKategorieID()),
						k.getBezeichnung() != null ? k.getBezeichnung() : "-");
				widths.set(0, Math.max(widths.get(0), row.get(0).length()));
				widths.set(1, Math.max(widths.get(1), row.get(1).length()));
				rows.add(row);
			}
			System.out.println("==== Kategorie ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Kategorien: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteArtikel() {
		try {
			var artikelList = verkaufManager.getArtikelDAO().findAll();

			List<String> headers = Arrays.asList("ArtikelID", "Name", "Preis", "Kategorie", "Kommentar");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());

			for (Artikel a : artikelList) {
				String name = a.getName() != null ? a.getName() : "-";
				String preis = String.format("%.2f", a.getEinzelpreis());
				String kategorie = (a.getKategorie() != null ? a.getKategorie().getBezeichnung() : "-");
				String kommentar = a.getKommentar() != null ? a.getKommentar() : "-";
				List<String> row = Arrays.asList(String.valueOf(a.getArtikelID()), name, preis, kategorie, kommentar);
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Artikel ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Artikel: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteArtikelBestellung() {
		try {
			var list = verkaufManager.getArtikelBestellungDAO().findAll();
			List<String> headers = Arrays.asList("BestellungID", "ArtikelID", "Menge", "Aufaddiert");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());

			for (ArtikelBestellung ab : list) {
				List<String> row = Arrays.asList(String.valueOf(ab.getBestellungID()),
						String.valueOf(ab.getArtikelID()), String.valueOf(ab.getMenge()),
						String.format("%.2f", ab.getAufaddiert()));
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== ArtikelBestellung ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der ArtikelBestellungen: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteBestellung() {
		try {
			var bestellungen = verkaufManager.getBestellungDAO().findAll();
			List<String> headers = Arrays.asList("BestellungID", "MitgliedID", "Bestelldatum", "ZahlungID",
					"MitarbeiterID", "Gesamtpreis");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());

			for (Bestellung b : bestellungen) {
				List<String> row = Arrays.asList(Formater.printID(b.getBestellungID(), 5),
						String.valueOf(b.getMitgliederID()), Formater.printDatum(b.getBestelldatum()), // neues Feld
						String.valueOf(b.getZahlungID()), // neues Feld
						String.valueOf(b.getMitarbeiterID()), // neues Feld
						Formater.printWährung(b.getGesamtpreis(), 12));
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Bestellung ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Bestellungen: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteZahlung() {
		try {
			var zahlungen = verkaufManager.getZahlungDAO().findAll();
			List<String> headers = Arrays.asList("ZahlungID", "Zahlungsart");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());

			for (Zahlung z : zahlungen) {
				List<String> row = Arrays.asList(String.valueOf(z.getZahlungID()),
						z.getZahlungsart() != null ? z.getZahlungsart() : "-");
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Zahlung ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Zahlungen: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void kursMenue() {
		boolean zurueck = false;
		while (!zurueck) {
			System.out.println("==== Kurs-Menü ====");
			System.out.println("1 - Kurs");
			System.out.println("2 - Kurstermin");
			System.out.println("3 - Kursteilnahme");
			System.out.println("4 - Kursleitung");
			System.out.println("5 - Zurück");
			System.out.print("Bitte wählen: ");
			String eingabe = scanner.nextLine();

			switch (eingabe) {
			case "1":
				verwalteKurs();
				break;
			case "2":
				verwalteKurstermin();
				break;
			case "3":
				verwalteKursteilnahme();
				break;
			case "4":
				verwalteKursleitung();
				break;
			case "5":
				zurueck = true;
				break;
			default:
				System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
			}
		}
	}

	private void verwalteKurs() {
		try {
			var kurse = kursManager.getKursDAO().findAll();
			List<String> headers = Arrays.asList("KursID", "Bezeichnung", "Kostenfrei", "Aktiv", "Teilnehmerzahl",
					"Preis", "AnzahlTermine", "Kommentar");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (Kurs k : kurse) {
			    List<String> row = Arrays.asList(
			        Formater.printID(k.getKursID(), 5),
			        k.getBezeichnung() != null ? k.getBezeichnung() : "-",
			        k.isKostenfrei() ? "Ja" : "Nein",
			        k.isAktiv() ? "Ja" : "Nein",
			        String.valueOf(k.getTeilnehmerzahl()),
			        Formater.printWährung(k.getPreis(), 12),
			        String.valueOf(k.getAnzahlTermine()),
			        k.getKommentar() != null ? k.getKommentar() : "-"
			    );
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Kurse ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Kurse: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteKurstermin() {
		try {
			var termine = kursManager.getKursterminDAO().findAll();
			List<String> headers = Arrays.asList("KursterminID", "KursID", "Termin", "Teilnehmerfrei",
				    "Anmeldebar", "Aktiv", "Kommentar");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (Kurstermin kt : termine) {
			    List<String> row = Arrays.asList(
			        Formater.printID(kt.getKursterminID(), 5),
			        Formater.printID(kt.getKursID(), 5),
			        kt.getTermin() != null ? Formater.printDatum(kt.getTermin()) : "-",
			        kt.getTeilnehmerfrei()> 0 ? "Ja" : "Nein",
			        kt.isAnmeldebar() ? "Ja" : "Nein",
			        kt.isAktiv() ? "Ja" : "Nein",
			        kt.getKommentar() != null ? kt.getKommentar() : "-"
			    );
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Kurstermine ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Kurstermine: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteKursteilnahme() {
		try {
			var teilnahmen = kursManager.getKursteilnahmeDAO().findAll();
			List<String> headers = Arrays.asList("MitgliederID", "KursterminID", "Angemeldet", "Anmeldezeit",
				    "Abgemeldet", "Abmeldezeit", "Aktiv", "Kommentar");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (Kursteilnahme kt : teilnahmen) {
			    List<String> row = Arrays.asList(
			        Formater.printID(kt.getMitgliederID(), 5),
			        Formater.printID(kt.getKursterminID(), 5),
			        kt.isAngemeldet() ? "Ja" : "Nein",
			        kt.getAnmeldezeit() != null ? Formater.printDatum(kt.getAnmeldezeit()) : "-",
			        kt.isAbgemeldet() ? "Ja" : "Nein",
			        kt.getAbmeldezeit() != null ? Formater.printDatum(kt.getAbmeldezeit()) : "-",
			        kt.isAktiv() ? "Ja" : "Nein",
			        kt.getKommentar() != null ? kt.getKommentar() : "-"
			    );
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Kursteilnahmen ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Kursteilnahmen: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteKursleitung() {
		try {
			var leitungen = kursManager.getKursleitungDAO().findAll();
			List<String> headers = Arrays.asList("KursterminID", "MitarbeiterID", "Bestaetigt", "Bestaetigungszeit",
				    "Abgemeldet", "Abmeldezeit", "Aktiv", "Kommentar");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (Kursleitung kl : leitungen) {
			    List<String> row = Arrays.asList(
			        Formater.printID(kl.getKursterminID(), 5),
			        Formater.printID(kl.getMitarbeiterID(), 5),
			        kl.isBestätigt() ? "Ja" : "Nein",
			        kl.getBestätigungszeit() != null ? Formater.printDatum(kl.getBestätigungszeit()) : "-",
			        kl.isAbgemeldet() ? "Ja" : "Nein",
			        kl.getAbmeldezeit() != null ? Formater.printDatum(kl.getAbmeldezeit()) : "-",
			        kl.isAktiv() ? "Ja" : "Nein",
			        kl.getKommentar() != null ? kl.getKommentar() : "-"
			    );
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Kursleitungen ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Kursleitungen: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void vertragMenue() {
		boolean zurueck = false;
		while (!zurueck) {
			System.out.println("==== Vertrag-Menü ====");
			System.out.println("1 - Vertrag");
			System.out.println("2 - Intervall");
			System.out.println("3 - MitgliederVertrag");
			System.out.println("4 - Zahlung");
			System.out.println("6 - Zurück");
			System.out.print("Bitte wählen: ");
			String eingabe = scanner.nextLine();

			switch (eingabe) {
			case "1":
				verwalteVertrag();
				break;
			case "2":
				verwalteIntervall();
				break;
			case "3":
				verwalteMitgliederVertrag();
				break;
			case "4":
				verwalteZahlung();
				break;
			case "6":
				zurueck = true;
				break;
			default:
				System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
			}
		}
	}

	private void verwalteVertrag() {
		try {
			var vertragListe = vertragManager.getVertragDAO().findAll();
			List<String> headers = Arrays.asList("VertragID", "Bezeichnung", "Laufzeit", "Grundpreis");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (Vertrag v : vertragListe) {
				List<String> row = Arrays.asList(Formater.printID(v.getVertragID(), 5),
						v.getBezeichnung() != null ? v.getBezeichnung() : "-",
						v.getLaufzeit() != 0 ? Integer.toString(v.getLaufzeit()) : "-", // neues Feld
						Formater.printWährung(v.getGrundpreis(), 10) // neues Feld
				);
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Vertrag ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Verträge: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteIntervall() {
		try {
			var intervallListe = vertragManager.getIntervallDAO().findAll();
			List<String> headers = Arrays.asList("IntervallID", "Beschreibung", "Zahlungsintervall");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (Intervall i : intervallListe) {
				List<String> row = Arrays.asList(Formater.printID(i.getIntervallID(), 5),
						i.getBezeichnung() != null ? i.getBezeichnung() : "-",
						i.getZahlungsintervall() != null ? i.getZahlungsintervall().toString() : "-" // neues Feld
				);
				for (int j = 0; j < headers.size(); j++)
					widths.set(j, Math.max(widths.get(j), row.get(j).length()));
				rows.add(row);
			}
			System.out.println("==== Intervall ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Intervalle: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteMitgliederVertrag() {
		try {
			var mitgliederVertragListe = vertragManager.getMitgliederVertragDAO().findAll();
			List<String> headers = Arrays.asList("MitgliedID", "VertragID", "VertragNr", "Vertragsbeginn",
					"Vertragsende", "Verlaengerung", "Aktiv", "Gekuendigt", "Preisrabatt", "IntervallID", "ZahlungID",
					"Trainingsbeginn", "MitarbeiterID", "Kommentar");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (MitgliederVertrag mv : mitgliederVertragListe) {
				List<String> row = Arrays.asList(Formater.printID(mv.getMitgliederID(), 5),
						Formater.printID(mv.getVertragID(), 5),
						mv.getVertragNr() != 0 ? Integer.toString(mv.getVertragNr()) : "-",
						Formater.printDatum(mv.getVertragsbeginn()), Formater.printDatum(mv.getVertragsende()),
						mv.isVerlängerung() ? "Ja" : "Nein", mv.isAktiv() ? "Ja" : "Nein",
						mv.isGekündigt() ? "Ja" : "Nein", String.format("%.2f", mv.getPreisrabatt()),
						Formater.printID(mv.getIntervallID(), 5), Formater.printID(mv.getZahlungID(), 5),
						Formater.printDatum(mv.getTrainingsbeginn()), Formater.printID(mv.getMitarbeiterID(), 5),
						mv.getKommentar() != null ? mv.getKommentar() : "-");
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== MitgliederVertrag ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der MitgliederVerträge: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteOrt() {
		try {
			var orte = mitarbeiterManager.getOrtDAO().findAll();
			List<String> headers = Arrays.asList("OrtID", "PLZ", "Ort");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (Ort o : orte) {
				List<String> row = Arrays.asList(String.valueOf(o.getOrtID()), o.getPLZ() != null ? o.getPLZ() : "-",
						o.getOrt() != null ? o.getOrt() : "-");
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Orte ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Orte: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteZahlungsdaten() {
		try {
			var zahlungen = mitarbeiterManager.getZahlungsdatenDAO().findAll();
			List<String> headers = Arrays.asList("ZahlungsdatenID", "Name", "IBAN", "BIC");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (Zahlungsdaten z : zahlungen) {
				List<String> row = Arrays.asList(String.valueOf(z.getZahlungsdatenID()),
						z.getName() != null ? z.getName() : "-", z.getIBAN() != null ? z.getIBAN() : "-",
						z.getBIC() != null ? z.getBIC() : "-");
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Zahlungsdaten ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Zahlungsdaten: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteBenutzer() {
		try {
			var benutzer = mitarbeiterManager.getBenutzerDAO().findAll();
			List<String> headers = Arrays.asList("BenutzerID", "Benutzername", "Passwort", "RolleID");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (Benutzer b : benutzer) {
			    List<String> row = Arrays.asList(
			        Formater.printID(b.getBenutzerID(), 5),
			        b.getBenutzername() != null ? b.getBenutzername() : "-",
			        "******",                                     // maskiertes Passwort
			        Formater.printID(b.getRolleID(), 5)
			    );
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Benutzer ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Benutzer: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteMitglieder() {
		try {
			var mitglieder = mitgliederManager.getMitgliederDAO().findAll();

			List<String> headers = Arrays.asList("MitgliedID", "Vorname", "Nachname", "Geburtsdatum", "Aktiv",
					"Strasse", "Hausnr", "OrtID", "ZahlungsdatenID", "Telefon", "Mail");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>(headers.size());
			for (String h : headers)
				widths.add(h.length());

			for (Mitglieder m : mitglieder) {
				List<String> row = Arrays.asList(String.valueOf(m.getMitgliederID()),
						m.getVorname() != null ? m.getVorname() : "-", m.getNachname() != null ? m.getNachname() : "-",
						m.getGeburtsdatum() != null ? m.getGeburtsdatum().toString() : "-", String.valueOf(m.isAktiv()),
						m.getStrasse() != null ? m.getStrasse() : "-", m.getHausnr() != null ? m.getHausnr() : "-",
						String.valueOf(m.getOrtID()), String.valueOf(m.getZahlungsdatenID()),
						m.getTelefon() != null ? m.getTelefon() : "-", m.getMail() != null ? m.getMail() : "-");
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}

			System.out.println("==== Mitglieder ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Mitglieder: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteMitarbeiter() {
		try {
			var mitarbeiter = mitarbeiterManager.getMitarbeiterDAO().findAll();
			List<String> headers = Arrays.asList("MitarbeiterID", "Vorname", "Nachname", "Geburtsdatum", "Aktiv",
					"Strasse", "Hausnr", "OrtID", "ZahlungsdatenID", "Telefon", "Mail");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>(headers.size());
			for (String h : headers)
				widths.add(h.length());

			for (Mitarbeiter m : mitarbeiter) {
				List<String> row = Arrays.asList(String.valueOf(m.getMitarbeiterID()),
						m.getVorname() != null ? m.getVorname() : "-", m.getNachname() != null ? m.getNachname() : "-",
						m.getGeburtsdatum() != null ? m.getGeburtsdatum().toString() : "-", String.valueOf(m.isAktiv()),
						m.getStraße() != null ? m.getStraße() : "-", m.getHausnr() != null ? m.getHausnr() : "-",
						m.getOrt() != null ? String.valueOf(m.getOrt().getOrtID()) : "-",
						m.getZahlungsdaten() != null ? String.valueOf(m.getZahlungsdaten().getZahlungsdatenID()) : "-",
						m.getTelefon() != null ? m.getTelefon() : "-", m.getMail() != null ? m.getMail() : "-");
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}

			System.out.println("==== Mitarbeiter ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Mitarbeiter: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

	private void verwalteRolle() {
		try {
			var rollen = mitarbeiterManager.getRolleDAO().findAll();
			List<String> headers = Arrays.asList("RolleID", "Bezeichnung", "Kommentar");
			List<List<String>> rows = new ArrayList<>();
			List<Integer> widths = new ArrayList<>();
			for (String header : headers)
				widths.add(header.length());
			for (Rolle r : rollen) {
			    List<String> row = Arrays.asList(
			        Formater.printID(r.getRolleID(), 5),
			        r.getBezeichnung() != null ? r.getBezeichnung() : "-",
			        r.getKommentar() != null ? r.getKommentar() : "-"
			    );
				for (int i = 0; i < headers.size(); i++)
					widths.set(i, Math.max(widths.get(i), row.get(i).length()));
				rows.add(row);
			}
			System.out.println("==== Rollen ====");
			Formater.printTabelle(widths, headers, rows);
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Rollen: " + e.getMessage());
		}
		System.out.println("1 Einfügen | 2 Ändern | 3 Löschen | 4 Zurück");
	}

}

----- Inhalt von: BaseService.txt -----
package Service;

import java.sql.Connection;
import java.util.Scanner;

public abstract class BaseService {
    protected Connection connection;
    protected Scanner scanner;
    protected boolean exitToMainMenu = false;

    public BaseService(Connection connection, Scanner scanner) {
        this.connection = connection;
        this.scanner = scanner;
    }

    public abstract void start();
    
    public boolean shouldExitToMainMenu() { 
        return exitToMainMenu;
    }
    
    public void resetExitFlag() { 
        exitToMainMenu = false;
    }
}

----- Inhalt von: HauptmenüService.txt -----
package Service;

import java.sql.Connection;
import java.util.Scanner;

public class HauptmenüService extends BaseService {

    private final MitgliederService mitgliederService;
    private final VerkaufService verkaufService;
    private final KursService kursService;
    private final VertragService vertragService;
    private final ÜbersichtService übersichtService;
    private final SucheService sucheService;
    private final AdminService adminService;   // wieder aktiviert!

    public HauptmenüService(Connection connection, Scanner scanner,
                           MitgliederService mitgliederService,
                           VerkaufService verkaufService,
                           KursService kursService,
                           VertragService vertragService,
                           ÜbersichtService übersichtService,
                           SucheService sucheService,
                           AdminService adminService   // wieder aktiviert!
                           ) {
        super(connection, scanner);
        this.mitgliederService = mitgliederService;
        this.verkaufService = verkaufService;
        this.kursService = kursService;
        this.vertragService = vertragService;
        this.übersichtService = übersichtService;
        this.sucheService = sucheService;
        this.adminService = adminService;   // wieder aktiviert!
    }

    public void start() {
        boolean weiter = true;

        while (weiter) {
            System.out.println();
            System.out.println("==== Hauptmenü ====");
            System.out.println("1 - Übersicht");
            System.out.println("2 - Mitglieder");
            System.out.println("3 - Verkauf");
            System.out.println("4 - Kurse");
            System.out.println("5 - Verträge");
            System.out.println("6 - Admin");  // wieder aktiviert!
            System.out.println("7 - Suche");
            System.out.println("0 - Programm beenden");
            System.out.print("Bitte eine Zahl eingeben: ");

            String eingabe = scanner.nextLine();

            switch (eingabe) {
                case "1":
                    übersichtService.start();
                    break;
                case "2":
                    mitgliederService.start();
                    break;
                case "3":
                    verkaufService.start();
                    break;
                case "4":
                    kursService.start();
                    break;
                case "5":
                    vertragService.start();
                    break;
                case "6":    // wieder aktiviert!
                    adminService.start();
                    break;
                case "7":
                    sucheService.start();
                    break;
                case "0":
                    System.out.println("Programm wird beendet.");
                    weiter = false;
                    break;
                default:
                    System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
            }

            System.out.println();
        }
    }
}

----- Inhalt von: KursService.txt -----
package Service;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Calendar;
import java.util.List;
import java.util.Scanner;

import Exception.ConnectionException;
import Exception.IntException;
import Exception.NotFoundException;
import Manager.KursManager;
import OUTDATED.OUT_IntValidator;
import Objekte.Kurs;
import Objekte.Kurstermin;
import Objekte.Mitarbeiter;

public class KursService extends BaseService {

    private KursManager kursManager;

    public KursService(Connection connection, Scanner scanner) {
        super(connection, scanner);
        try {
            this.kursManager = new KursManager();
        } catch (ConnectionException | SQLException e) {
            System.out.println("Fehler beim Initialisieren des KursManagers: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void start() {
        boolean running = true;
        while (running && !exitToMainMenu) {
            System.out.println("\n=== Kursverwaltung ===");
            System.out.println("1. Alle Kurse anzeigen");
            System.out.println("2. Alle Kurstermine anzeigen");
            System.out.println("3. Kurstermine eines Kurses anzeigen");
            System.out.println("4. Für Kurs anmelden");
            System.out.println("5. Von Kurs abmelden");
            System.out.println("6. Teilnehmerliste anzeigen");
            System.out.println("0. Zurück zum Hauptmenü");
            System.out.print("\nBitte wählen Sie: ");
            String eingabe = scanner.nextLine();

            try {
                switch (eingabe) {
                    case "1":
                        alleKurseAnzeigen();
                        break;
                    case "2":
                        alleKurstermineAnzeigen();
                        break;
                    case "3":
                        kurstermineAnzeigen();
                        break;
                    case "4":
                        fuerKursAnmelden();
                        break;
                    case "5":
                        vonKursAbmelden();
                        break;
                    case "6":
                        teilnehmerlisteAnzeigen();
                        break;
                    case "0":
                        running = false;
                        break;
                    default:
                        System.out.println("Ungültige Eingabe!");
                }
            } catch (Exception e) {
                System.out.println("Fehler: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    /**
     * Zeigt alle verfügbaren Kurse an
     */
    private void alleKurseAnzeigen() throws SQLException {
        List<Kurs> kurse = kursManager.getKursDAO().findAll();

        if (kurse.isEmpty()) {
            System.out.println("\nKeine Kurse vorhanden.");
            return;
        }

        System.out.println("\n=== Alle Kurse ===");
        System.out.printf("%-8s | %-30s | %-8s | %10s%n", "KursID", "Bezeichnung", "Termine", "Preis");
        System.out.println("=".repeat(70));

        for (Kurs kurs : kurse) {
            System.out.printf("%-8d | %-30s | %-8d | %9.2f €%n",
                kurs.getKursID(),
                kurs.getBezeichnung(),
                kurs.getAnzahlTermine(),
                kurs.getPreis()
            );
        }
    }

    /**
     * Zeigt alle Kurstermine an
     */
    private void alleKurstermineAnzeigen() throws SQLException, IntException, NotFoundException {
        List<Kurstermin> termine = kursManager.getKursterminDAO().findAll();

        if (termine.isEmpty()) {
            System.out.println("\nKeine Kurstermine vorhanden.");
            return;
        }

        System.out.println("\n=== Alle Kurstermine ===");
        System.out.printf("%-13s | %-16s | %-20s | %-30s%n", 
            "TerminID", "Datum/Zeit", "Trainer", "Kurs");
        System.out.println("=".repeat(90));

        for (Kurstermin termin : termine) {
            // Hole Trainer-Daten aus Kursleitung/Mitarbeiter
            Mitarbeiter trainer = kursManager.findeTrainerFürKurstermin(termin.getKursterminID());
            String trainerName = trainer != null ? trainer.getVorname() + " " + trainer.getNachname() : "-";

            // Hole Kurs-Daten
            Kurs kurs = null;
            String kursName = "-";
            try {
                kurs = kursManager.getKursDAO().findById(termin.getKursID());
                if (kurs != null) {
                    kursName = kurs.getBezeichnung();
                }
            } catch (NotFoundException e) {
                // Kurs nicht gefunden - zeige "-"
            }

            System.out.printf("%-13d | %-16s | %-20s | %-30s%n",
                termin.getKursterminID(),
                formatiereDatumZeit(termin.getTermin()),
                trainerName,
                kursName
            );
        }
    }

    /**
     * Zeigt alle Termine eines Kurses an
     */
    private void kurstermineAnzeigen() throws SQLException, IntException, NotFoundException {
        int kursID = 0;

        // KursID validieren
        while (true) {
            try {
                System.out.print("KursID eingeben: ");
                String kursIDStr = scanner.nextLine();
                kursID = validateInt(kursIDStr, "KursID");
                break;
            } catch (IntException e) {
                System.out.println(e.getMessage());
            }
        }

        Kurs kurs = kursManager.getKursDAO().findById(kursID);
        if (kurs == null) {
            System.out.println("Kurs nicht gefunden!");
            return;
        }

        List<Kurstermin> termine = kursManager.findTermineByKursId(kursID);

        if (termine.isEmpty()) {
            System.out.println("\nKeine Termine für diesen Kurs vorhanden.");
            return;
        }

        System.out.println("\n=== Kurstermine für: " + kurs.getBezeichnung() + " ===");
        System.out.printf("%-12s | %-16s | %-20s | %-6s%n", "TerminID", "Datum/Zeit", "Trainer", "Aktiv");
        System.out.println("=".repeat(70));

        for (Kurstermin termin : termine) {
            Mitarbeiter trainer = kursManager.findeTrainerFürKurstermin(termin.getKursterminID());
            String trainerName = trainer != null ? trainer.getVorname() + " " + trainer.getNachname() : "-";

            System.out.printf("%-12d | %-16s | %-20s | %-6s%n",
                termin.getKursterminID(),
                formatiereDatumZeit(termin.getTermin()),
                trainerName,
                termin.isAktiv() ? "X" : ""
            );
        }
    }

    private void fuerKursAnmelden() throws SQLException, IntException, NotFoundException {
        int mitgliederID = 0;
        int kursterminID = 0;

        // Mitglieder-ID validieren
        while (true) {
            try {
                System.out.print("MitgliederID eingeben: ");
                String mitgliederIDStr = scanner.nextLine();
                mitgliederID = validateInt(mitgliederIDStr, "MitgliederID");
                break;
            } catch (IntException e) {
                System.out.println(e.getMessage());
            }
        }

        // Kurstermin-ID validieren
        while (true) {
            try {
                System.out.print("KursterminID eingeben: ");
                String kursterminIDStr = scanner.nextLine();
                kursterminID = validateInt(kursterminIDStr, "KursterminID");
                break;
            } catch (IntException e) {
                System.out.println(e.getMessage());
            }
        }

        kursManager.meldeAnFuerKurs(mitgliederID, kursterminID);
        System.out.println("\nErfolgreich für Kurs angemeldet!");
    }

    private void vonKursAbmelden() throws SQLException, IntException, NotFoundException {
        int mitgliederID = 0;
        int kursterminID = 0;

        // Mitglieder-ID validieren
        while (true) {
            try {
                System.out.print("MitgliederID eingeben: ");
                String mitgliederIDStr = scanner.nextLine();
                mitgliederID = validateInt(mitgliederIDStr, "MitgliederID");
                break;
            } catch (IntException e) {
                System.out.println(e.getMessage());
            }
        }

        // Kurstermin-ID validieren
        while (true) {
            try {
                System.out.print("KursterminID eingeben: ");
                String kursterminIDStr = scanner.nextLine();
                kursterminID = validateInt(kursterminIDStr, "KursterminID");
                break;
            } catch (IntException e) {
                System.out.println(e.getMessage());
            }
        }

        kursManager.meldeAbVonKurs(mitgliederID, kursterminID);
        System.out.println("\nErfolgreich von Kurs abgemeldet!");
    }

    private void teilnehmerlisteAnzeigen() throws SQLException, IntException, NotFoundException {
        int kursterminID = 0;

        while (true) {
            try {
                System.out.print("KursterminID eingeben: ");
                String kursterminIDStr = scanner.nextLine();
                kursterminID = validateInt(kursterminIDStr, "KursterminID");
                break;
            } catch (IntException e) {
                System.out.println(e.getMessage());
            }
        }

        kursManager.zeigeKursteilnehmer(kursterminID);
    }

    private int validateInt(String eingabe, String feldname) throws IntException {
        try {
            int wert = Integer.parseInt(eingabe);
            OUT_IntValidator validator = new OUT_IntValidator();
            validator.validate(wert);
            return wert;
        } catch (NumberFormatException e) {
            throw new IntException(feldname + " muss eine ganze Zahl sein!");
        }
    }

    private String formatiereDatumZeit(Timestamp timestamp) {
        if (timestamp == null) {
            return "-";
        }

        Calendar cal = Calendar.getInstance();
        cal.setTime(timestamp);

        int tag = cal.get(Calendar.DAY_OF_MONTH);
        int monat = cal.get(Calendar.MONTH) + 1;
        int jahr = cal.get(Calendar.YEAR);
        int stunde = cal.get(Calendar.HOUR_OF_DAY);
        int minute = cal.get(Calendar.MINUTE);

        // Format: dd.MM.yyyy HH:mm
        return String.format("%02d.%02d.%4d %02d:%02d", tag, monat, jahr, stunde, minute);
    }
}

----- Inhalt von: MitgliederService.txt -----
package Service;

import java.sql.Connection;
import java.util.Scanner;

import DAOs.OrtDAO;
import DAOs.ZahlungsdatenDAO;
import Exception.StringException;
import Helper.IO;
import Manager.MitgliederManager;
import OUTDATED.OUT_StringValidator;
import Objekte.Mitglieder;
import Objekte.Ort;
import Objekte.Zahlungsdaten;
import Validator.ContactValidator;
import Validator.PaymentDetailsValidator;

public class MitgliederService extends BaseService {

    public MitgliederService(Connection connection, Scanner scanner) {
        super(connection, scanner);
    }

    public void start() {
        boolean zurueck = false;
        while (!zurueck) {
            System.out.println("==== Mitgliederverwaltung ====");
            System.out.println("1 - Interessenten erstellen");
            System.out.println("2 - Mitglieder erstellen");
            System.out.println("3 - Zurück zum Hauptmenü");
            System.out.print("Bitte wählen: ");
            String eingabe = scanner.nextLine();

            switch (eingabe) {
                case "1":
                    interessentErstellen();
                    break;
                case "2":
                    mitgliedErstellen();
                    break;
                case "3":
                    zurueck = true;
                    break;
                default:
                    System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
            }
        }
    }

    private void interessentErstellen() {
        System.out.println("Interessentenerstellung ausgewählt");
        try {
            MitgliederManager manager = new MitgliederManager();
            String vorname = IO.readString("Vorname: ");
            String nachname = IO.readString("Nachname: ");
            String telefon = IO.readString("Telefon: ");
            int id = manager.createInteressent(vorname, nachname, telefon);
            System.out.println("Interessent erfolgreich erstellt mit ID: " + id);
        } catch (Exception e) {
            System.out.println("Fehler bei der Interessentenerstellung: " + e.getMessage());
        }
    }

    private void mitgliedErstellen() {
        System.out.println("Mitgliedererstellung ausgewählt");
        try {
            MitgliederManager manager = new MitgliederManager();

            String vorname = IO.readString("Vorname: ");
            String nachname = IO.readString("Nachname: ");

            // ContactValidator für Telefon und Mail initialisieren
            ContactValidator contactValidator = new ContactValidator();

            // Telefon validieren und formatieren
            String telefon = "";
            while (true) {
                telefon = IO.readString("Telefon: ");
                if (telefon.isEmpty()) break;
                try {
                    telefon = contactValidator.validateUndFormatTelefon(telefon);
                    break;
                } catch (Exception e) {
                    System.out.println("Ungültige Telefonnummer: " + e.getMessage());
                }
            }

            // Geburtsdatum mit Validierungs-Schleife
            java.util.Date geburtstag = null;
            while (true) {
                String geburtsdatumStr = IO.readString("Geburtsdatum (dd.MM.yyyy): ");
                if (geburtsdatumStr.isEmpty())
                    break;
                try {
                    geburtstag = new java.text.SimpleDateFormat("dd.MM.yyyy").parse(geburtsdatumStr);
                    break;
                } catch (Exception e) {
                    System.out.println("Ungültiges Datum: " + e.getMessage());
                }
            }

            boolean aktiv = false;

            String strasse = IO.readString("Straße: ");
            String hausnr = IO.readString("Hausnummer: ");

            // PLZ Validator & Schleife
            String plz = "";
            OUT_StringValidator plzValidator = new OUT_StringValidator() {
                @Override
                public void validate(Object obj) throws StringException {
                    super.validate(obj);
                    String input = (String) obj;
                    if (input.length() != 5 || !input.matches("\\d{5}")) {
                        errors.add("PLZ muss genau 5 Ziffern haben.");
                        throw new StringException("PLZ muss genau 5 Ziffern haben.");
                    }
                }
            };
            while (true) {
                plz = IO.readString("PLZ: ");
                if (plz.isEmpty())
                    break;
                try {
                    plzValidator.validate(plz);
                    break;
                } catch (Exception e) {
                    System.out.println("Ungültige PLZ: " + e.getMessage());
                }
            }

            String ortname = IO.readString("Ort: ");

            // Mail Validator & Schleife
            String mail = "";
            while (true) {
                mail = IO.readString("Mail: ");
                if (mail.isEmpty())
                    break;
                try {
                    contactValidator.validateEmail(mail);
                    break;
                } catch (Exception e) {
                    System.out.println("Ungültige Mailadresse: " + e.getMessage());
                }
            }

            // Ort ggf. in DB finden/erstellen
            int ortID = 0;
            Ort ortObj = null;
            if (!plz.isEmpty() && !ortname.isEmpty()) {
                OrtDAO ortDAO = manager.getOrtDAO();
                ortID = ortDAO.findOrCreateOrt(plz, ortname);
                ortObj = ortDAO.findById(ortID);
            }

            // PaymentDetailsValidator für IBAN und BIC initialisieren
            PaymentDetailsValidator paymentValidator = new PaymentDetailsValidator();

            String zahlungsName = IO.readString("Zahlungsdaten - Name: ");
            String iban = "";
            while (true) {
                iban = IO.readString("IBAN: ");
                if (iban.isEmpty())
                    break;
                try {
                    iban = paymentValidator.validateIBAN(iban);
                    break;
                } catch (Exception e) {
                    System.out.println("Ungültige IBAN: " + e.getMessage());
                }
            }

            String bic = "";
            while (true) {
                bic = IO.readString("BIC: ");
                if (bic.isEmpty())
                    break;
                try {
                    paymentValidator.validateBIC(bic);
                    break;
                } catch (Exception e) {
                    System.out.println("Ungültiger BIC: " + e.getMessage());
                }
            }

            int zahlungsdatenID = 0;
            Zahlungsdaten zahlungsdaten = null;
            if (!iban.isEmpty() && !bic.isEmpty()) {
                ZahlungsdatenDAO zahlungsdatenDAO = manager.getZahlungsdatenDAO();
                zahlungsdatenID = zahlungsdatenDAO.findOrCreateZahlungsdaten(zahlungsName, iban, bic);
                zahlungsdaten = zahlungsdatenDAO.findById(zahlungsdatenID);
            }

            Mitglieder mitglied = new Mitglieder(vorname, nachname, telefon, geburtstag, aktiv, strasse, hausnr, ortObj, zahlungsdaten, mail);
            manager.getMitgliederDAO().insert(mitglied);

            System.out.println("Mitglied erfolgreich erstellt:\n" + mitglied);

        } catch (Exception e) {
            System.out.println("Fehler bei der Mitgliedererstellung: " + e.getMessage());
            e.printStackTrace();
        }
    }

}

----- Inhalt von: SucheService.txt -----
package Service;

import java.sql.Connection;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;

import Helper.Datum;
import Helper.DatumHelper;
import Manager.KursManager;
import Manager.MitgliederManager;
import Manager.VerkaufManager;
import Manager.VertragManager;
import Objekte.Artikel;
import Objekte.ArtikelBestellung;
import Objekte.Bestellung;
import Objekte.Intervall;
import Objekte.Kurs;
import Objekte.Kursleitung;
import Objekte.Kursteilnahme;
import Objekte.Kurstermin;
import Objekte.Mitarbeiter;
import Objekte.Mitglieder;
import Objekte.MitgliederVertrag;
import Objekte.Ort;
import Objekte.Vertrag;

public class SucheService extends BaseService {

	public SucheService(Connection connection, Scanner scanner) {
		super(connection, scanner);
	}

	public void start() {
		System.out.print("Bitte Suchbegriff eingeben: ");
		String suchbegriff = scanner.nextLine();
		try {
			// Manager initialisieren
			MitgliederManager mitgliederManager = new MitgliederManager();
			VertragManager vertragManager = new VertragManager();
			VerkaufManager verkaufManager = new VerkaufManager();
			KursManager kursManager = new KursManager();

			// Suche in allen Bereichen
			List<Mitglieder> mitgliederErgebnis = mitgliederManager.search(suchbegriff);
			List<MitgliederVertrag> vertragErgebnis = vertragManager.search(suchbegriff);

			// Suche in Verkaufsdaten (Bestellung, Artikel, ArtikelBestellung)
			List<Bestellung> bestellungErgebnis = verkaufManager.getBestellungDAO().searchAllAttributes(suchbegriff);
			List<Artikel> artikelErgebnis = verkaufManager.getArtikelDAO().searchAllAttributes(suchbegriff);

			// Suche in Kursdaten (Kurs, Kurstermin, Kursteilnahme, Kursleitung,
			// Mitarbeiter)
			List<Kurs> kursErgebnis = kursManager.search(suchbegriff);
			List<Kurstermin> kursterminErgebnis = kursManager.getKursterminDAO().searchAllAttributes(suchbegriff);
			List<Kursteilnahme> kursteilnahmeErgebnis = kursManager.getKursteilnahmeDAO()
					.searchAllAttributes(suchbegriff);
			List<Kursleitung> kursleitungErgebnis = kursManager.getKursleitungDAO().searchAllAttributes(suchbegriff);
			List<Mitarbeiter> mitarbeiterErgebnis = kursManager.getMitarbeiterDAO().searchAllAttributes(suchbegriff);

			// Kombiniere Ergebnisse: alle Mitglieder-IDs sammeln
			Set<Integer> mitgliederIDs = new HashSet<>();

			// Von Mitglieder-Suche
			for (Mitglieder m : mitgliederErgebnis) {
				mitgliederIDs.add(m.getMitgliederID());
			}

			// Von Vertrag-Suche
			for (MitgliederVertrag mv : vertragErgebnis) {
				mitgliederIDs.add(mv.getMitgliederID());
			}

			// Von Bestellung-Suche
			for (Bestellung b : bestellungErgebnis) {
				mitgliederIDs.add(b.getMitgliederID());
			}

			// Von Artikel-Suche (über ArtikelBestellung zu Bestellung zu Mitglied)
			for (Artikel artikel : artikelErgebnis) {
				List<ArtikelBestellung> artikelBestellungen = verkaufManager.getArtikelBestellungDAO()
						.findByArtikelId(artikel.getArtikelID());
				for (ArtikelBestellung ab : artikelBestellungen) {
					Bestellung bestellung = verkaufManager.getBestellungDAO().findById(ab.getBestellungID());
					if (bestellung != null) {
						mitgliederIDs.add(bestellung.getMitgliederID());
					}
				}
			}

			// Von Kurs-Suche (über Kurstermin zu Kursteilnahme zu Mitglied)
			for (Kurs kurs : kursErgebnis) {
				List<Kurstermin> termine = kursManager.findTermineByKursId(kurs.getKursID());
				for (Kurstermin termin : termine) {
					List<Kursteilnahme> teilnahmen = kursManager.findTeilnahmenByKursterminId(termin.getKursterminID());
					for (Kursteilnahme teilnahme : teilnahmen) {
						mitgliederIDs.add(teilnahme.getMitgliederID());
					}
				}
			}

			// Von Kurstermin-Suche (zu Kursteilnahme zu Mitglied)
			for (Kurstermin termin : kursterminErgebnis) {
				List<Kursteilnahme> teilnahmen = kursManager.findTeilnahmenByKursterminId(termin.getKursterminID());
				for (Kursteilnahme teilnahme : teilnahmen) {
					mitgliederIDs.add(teilnahme.getMitgliederID());
				}
			}

			// Von Kursteilnahme-Suche
			for (Kursteilnahme teilnahme : kursteilnahmeErgebnis) {
				mitgliederIDs.add(teilnahme.getMitgliederID());
			}

			// Von Kursleitung-Suche (zu Mitarbeiter zu Mitglied, falls Mitarbeiter auch
			// Mitglied ist)
			for (Kursleitung leitung : kursleitungErgebnis) {
				Mitarbeiter mitarbeiter = kursManager.getMitarbeiterDAO().findById(leitung.getMitarbeiterID());
				if (mitarbeiter != null) {
					// Falls Mitarbeiter auch Mitglied ist (z.B. über MitgliederID = MitarbeiterID
					// oder Verknüpfungstabelle)
					// Beispiel: MitgliederID = MitarbeiterID (anpassen nach DB-Modell)
					// Oder: MitgliederID aus Verknüpfungstabelle holen
					// Hier angenommen: MitgliederID = MitarbeiterID
					mitgliederIDs.add(mitarbeiter.getMitarbeiterID());
				}
			}

			// Von Mitarbeiter-Suche (falls Mitarbeiter auch Mitglied ist)
			for (Mitarbeiter mitarbeiter : mitarbeiterErgebnis) {
				// Beispiel: MitgliederID = MitarbeiterID
				mitgliederIDs.add(mitarbeiter.getMitarbeiterID());
			}

			if (mitgliederIDs.isEmpty()) {
				System.out.println("Keine Einträge gefunden.");
				return;
			}

			// Sortierte Liste erstellen
			List<Integer> sortierteIDs = new ArrayList<>(mitgliederIDs);
			sortierteIDs.sort(Integer::compareTo);

			// Ausgabe
			System.out.printf("%-8s| %-15s| %-15s| %-12s| %-6s%n", "Mitgl.ID", "Vorname", "Nachname", "Geburtsdatum",
					"Aktiv");
			System.out.println("---------------------------------------------------------------");
			SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
			Date heute = new Date();

			for (Integer mitgliedID : sortierteIDs) {
				Mitglieder mitglied = mitgliederManager.getMitgliederDAO().findById(mitgliedID);
				if (mitglied == null)
					continue;

				String gebDatum = "-";
				if (mitglied.getGeburtsdatum() != null) {
					gebDatum = sdf.format(mitglied.getGeburtsdatum());
				}

				// Prüfe aktiven Vertrag
				List<MitgliederVertrag> vertraege = vertragManager.getMitgliederVertragDAO()
						.findByMitgliedId(mitgliedID);
				boolean hatAktivenVertrag = false;
				for (MitgliederVertrag v : vertraege) {
					if (v.getVertragsbeginn() != null && v.getVertragsende() != null
							&& heute.compareTo(v.getVertragsbeginn()) >= 0
							&& heute.compareTo(v.getVertragsende()) <= 0) {
						hatAktivenVertrag = true;
						break;
					}
				}

				// Aktualisiere Aktiv-Status
				if (hatAktivenVertrag && !mitglied.isAktiv()) {
					mitglied.setAktiv(true);
					mitgliederManager.getMitgliederDAO().update(mitglied);
				} else if (!hatAktivenVertrag && mitglied.isAktiv()) {
					mitglied.setAktiv(false);
					mitgliederManager.getMitgliederDAO().update(mitglied);
				}

				System.out.printf("%-8d| %-15s| %-15s| %-12s| %-6s%n", mitglied.getMitgliederID(),
						mitglied.getVorname(), mitglied.getNachname(), gebDatum, hatAktivenVertrag ? "X" : "");
			}

			// Detail-Auswahl
			System.out
					.println("\nBitte die MitgliederID des gewünschten Eintrags eingeben (oder Enter zum Abbrechen):");
			String auswahl = scanner.nextLine();
			if (!auswahl.isBlank()) {
				try {
					int mitgliederID = Integer.parseInt(auswahl);
					if (mitgliederIDs.contains(mitgliederID)) {
						Mitglieder ausgewählt = mitgliederManager.getMitgliederDAO().findById(mitgliederID);
						if (ausgewählt != null) {
							zeigeDetail(ausgewählt, mitgliederManager, vertragManager, verkaufManager, kursManager);
						}
					} else {
						System.out.println("Kein Mitglied mit der eingegebenen MitgliederID gefunden.");
					}
				} catch (NumberFormatException e) {
					System.out.println("Bitte eine gültige MitgliederID eingeben!");
				}
			}
		} catch (Exception e) {
			System.out.println("Fehler bei der Suche: " + (e.getMessage() != null ? e.getMessage() : e));
			e.printStackTrace();
		}
	}

	private void zeigeDetail(Mitglieder ausgewählt, MitgliederManager mitgliederManager, VertragManager vertragManager,
			VerkaufManager verkaufManager, KursManager kursManager) throws Exception {
		boolean exitDetail = false;
		int tab = 1;

		while (!exitDetail) {
			System.out.println("\n1 Stammdaten | 2 Mitgliedschaft | 3 Zahlungsdaten | 4 Kurse | 5 Verkauf");
			switch (tab) {
			case 1:
				showStammdaten(ausgewählt);
				break;
			case 2:
				showMitgliedschaft(ausgewählt, vertragManager);
				break;
			case 3:
				showZahlungsdaten(ausgewählt);
				break;
			case 4: // NEU: Tab 4 - Kurse
				showKurse(ausgewählt, kursManager);
				break;
			case 5:
				showVerkauf(ausgewählt, verkaufManager);
				break;
			default:
				System.out.println("(Tab nicht belegt)");
			}
			System.out.print("\nTab auswählen (1-5), 6: Hauptmenü\n");
			String tabEingabe = scanner.nextLine();
			if (tabEingabe.isBlank())
				continue;
			if (tabEingabe.equals("6")) {
				exitToMainMenu = true;
				return;
			} else {
				try {
					int tabWahl = Integer.parseInt(tabEingabe);
					if (tabWahl >= 1 && tabWahl <= 5) {
						tab = tabWahl;
					}
				} catch (NumberFormatException ex) {
					System.out.println("Ungültige Tab-Nummer!");
				}
			}
		}
	}

	// ---- Gemeinsame Hilfsmethoden ----
	public void showStammdaten(Mitglieder ausgewaehlt) {
		String vorname = ausgewaehlt.getVorname() != null ? ausgewaehlt.getVorname() : "-";
		String nachname = ausgewaehlt.getNachname() != null ? ausgewaehlt.getNachname() : "-";
		SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
		String geburtsdatum = (ausgewaehlt.getGeburtsdatum() != null) ? sdf.format(ausgewaehlt.getGeburtsdatum()) : "-";
		int alterJahre = ausgewaehlt.getGeburtsdatum() != null ? ausgewaehlt.berechneAlter() : 0;
		boolean istGeburtstag = false;
		if (ausgewaehlt.getGeburtsdatum() != null) {
			java.time.LocalDate birthDate;
			if (ausgewaehlt.getGeburtsdatum() instanceof java.sql.Date) {
				birthDate = ((java.sql.Date) ausgewaehlt.getGeburtsdatum()).toLocalDate();
			} else {
				birthDate = new java.sql.Date(ausgewaehlt.getGeburtsdatum().getTime()).toLocalDate();
			}
			java.time.LocalDate today = java.time.LocalDate.now();
			istGeburtstag = today.getMonthValue() == birthDate.getMonthValue()
					&& today.getDayOfMonth() == birthDate.getDayOfMonth();
		}
		String geburtstagInfo = istGeburtstag ? "Geburtstag!" : "";
		String strasse = ausgewaehlt.getStrasse() != null ? ausgewaehlt.getStrasse() : "-";
		String hausnr = ausgewaehlt.getHausnr() != null ? ausgewaehlt.getHausnr() : "-";
		Ort ortObj = ausgewaehlt.getOrt();
		String plz = ortObj != null && ortObj.getPLZ() != null ? ortObj.getPLZ() : "-";
		String ort = ortObj != null && ortObj.getOrt() != null ? ortObj.getOrt() : "-";
		String tel = ausgewaehlt.getTelefon() != null ? ausgewaehlt.getTelefon() : "-";
		String mail = ausgewaehlt.getMail() != null ? ausgewaehlt.getMail() : "-";

		System.out.printf(
				"\nName:\t\t%s %s\nGeburtsdatum:\t%s\tAlter: %d Jahre %s\nAdresse:\t%s %s\n\t\t%s %s\nTelefon:\t%s\nMail:\t\t%s\n",
				vorname, nachname, geburtsdatum, alterJahre, geburtstagInfo, strasse, hausnr, plz, ort, tel, mail);
	}

	public void showMitgliedschaft(Mitglieder ausgewaehlt, VertragManager manager) throws Exception {
		List<MitgliederVertrag> vertraege = manager.getMitgliederVertragDAO()
				.findByMitgliedId(ausgewaehlt.getMitgliederID());
		if (vertraege == null || vertraege.isEmpty()) {
			System.out.println("\nDas Mitglied hat keine Verträge.");
			return;
		}
		SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
		Date heute = new Date();
		for (MitgliederVertrag mv : vertraege) {
			Vertrag v = manager.getVertragDAO().findById(mv.getVertragID());
			Intervall intervall = manager.getIntervallDAO().findById(mv.getIntervallID());
			double grundpreis = v.getGrundpreis();
			double preisrabatt = mv.getPreisrabatt();
			double wochenpreis = grundpreis - preisrabatt;
			int laufzeit = v.getLaufzeit();
			double gesamtwert = laufzeit * grundpreis;
			int wochenSeitVertragsstart = (int) ((heute.getTime() - mv.getVertragsbeginn().getTime())
					/ (1000 * 60 * 60 * 24 * 7));
			double gezahlt = 0;
			switch (mv.getIntervallID()) {
			case 1:
				gezahlt = getWochenBisErster(heute, mv) * wochenpreis;
				break;
			case 2:
				gezahlt = getWochenBisLetzterVormonat(mv) * wochenpreis;
				break;
			case 3:
				gezahlt = wochenSeitVertragsstart * wochenpreis;
				break;
			case 4:
				gezahlt = ((wochenSeitVertragsstart % 2 == 0) ? wochenSeitVertragsstart : (wochenSeitVertragsstart - 1))
						* wochenpreis;
				break;
			}
			double restwert = gesamtwert - gezahlt;
			double jeZahlungsintervall = 0;
			switch (mv.getIntervallID()) {
			case 1:
			case 2:
				jeZahlungsintervall = wochenpreis * 52.14 / 12.0;
				break;
			case 3:
				jeZahlungsintervall = wochenpreis;
				break;
			case 4:
				jeZahlungsintervall = wochenpreis * 2;
				break;
			}
			Date kuendbarBis = new Date(mv.getVertragsende().getTime() - 5L * 7L * 24L * 60L * 60L * 1000L);

			System.out.printf("\nVertragNr.:\t%d\t%s\n", mv.getVertragID(), v.getBezeichnung());
			System.out.printf("Laufzeit:\t%d Wochen Zahlungsintervall: %s\n", laufzeit, intervall.getBezeichnung());
			System.out.println("---------------------------------------------------------");
			System.out.println("Trainingsbeginn\t| Vertragsbeginn | Vertragsende |  Aktiv");
			System.out.printf("%s\t| %s     | %s   |    %s\n",
					mv.getTrainingsbeginn() != null ? sdf.format(mv.getTrainingsbeginn()) : "-",
					mv.getVertragsbeginn() != null ? sdf.format(mv.getVertragsbeginn()) : "-",
					mv.getVertragsende() != null ? sdf.format(mv.getVertragsende()) : "-",
					(heute.compareTo(mv.getVertragsbeginn()) >= 0 && heute.compareTo(mv.getVertragsende()) <= 0) ? "X"
							: "");
			System.out.println("---------------------------------------------------------");
			System.out.printf("Grundpreis:\t\t%5.2f €\t| Gesamtwert:\t%7.2f €\n", grundpreis, gesamtwert);
			System.out.printf("Sonder-Rabatt:\t\t%5.2f €\t| Gezahlt:\t%7.2f €\n", preisrabatt, gezahlt);
			System.out.printf("Wochenpreis:\t\t%5.2f €\t| Restwert:\t%7.2f €\n", wochenpreis, restwert);
			System.out.println("---------------------------------------------------------");
			System.out.printf("Je Zahlungsintervall: \t%5.2f €\t| Kündbar bis: %s %s %s\n", jeZahlungsintervall,
					sdf.format(kuendbarBis), mv.isGekündigt() ? "Künd.: X" : "", mv.isVerlängerung() ? "Verl.: X" : "");
		}
	}

	public void showZahlungsdaten(Mitglieder ausgewaehlt) {
		Objekte.Zahlungsdaten zahlungsdaten = ausgewaehlt.getZahlungsdaten();

		if (zahlungsdaten == null) {
			System.out.println("\nKeine Zahlungsdaten vorhanden.");
			return;
		}

		String vorname = ausgewaehlt.getVorname() != null ? ausgewaehlt.getVorname() : "-";
		String nachname = ausgewaehlt.getNachname() != null ? ausgewaehlt.getNachname() : "-";
		String iban = zahlungsdaten.getIBAN() != null ? zahlungsdaten.getIBAN() : "-";
		String bic = zahlungsdaten.getBIC() != null ? zahlungsdaten.getBIC() : "-";

		System.out.printf("\nName:\t%s %s\nIBAN:\t%s\nBIC:\t%s\n", vorname, nachname, iban, bic);
	}

	// NEU: Tab 4 - Kurse mit sauberer Tabellenformatierung
	public void showKurse(Mitglieder ausgewaehlt, KursManager manager) throws Exception {
		List<Kursteilnahme> teilnahmen = manager.findTeilnahmenByMitgliedId(ausgewaehlt.getMitgliederID());

		if (teilnahmen == null || teilnahmen.isEmpty()) {
			System.out.println("\nDas Mitglied hat keine Kursteilnahmen.");
			return;
		}

		SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy HH:mm");

		System.out.println("\n=== Kursteilnahmen ===");
		System.out.printf("%-30s | %-20s | %-20s | %-6s%n", "Kurs", "Trainer", "Termin", "Aktiv");
		System.out.println("=".repeat(90));

		for (Kursteilnahme teilnahme : teilnahmen) {
			Kurstermin termin = manager.getKursterminDAO().findById(teilnahme.getKursterminID());

			if (termin != null) {
				Kurs kurs = manager.getKursDAO().findById(termin.getKursID());
				Mitarbeiter trainer = manager.findeTrainerFürKurstermin(termin.getKursterminID());

				String kursName = kurs != null ? kurs.getBezeichnung() : "-";
				String trainerName = trainer != null ? trainer.getVorname() + " " + trainer.getNachname() : "-";
				String terminZeit = termin.getTermin() != null ? sdf.format(termin.getTermin()) : "-";

				// Name auf maximal 30 Zeichen begrenzen
				if (kursName.length() > 30) {
					kursName = kursName.substring(0, 27) + "...";
				}
				if (trainerName.length() > 20) {
					trainerName = trainerName.substring(0, 17) + "...";
				}

				System.out.printf("%-30s | %-20s | %-20s | %-6s%n", kursName, trainerName, terminZeit,
						teilnahme.isAktiv() ? "X" : "");
			}
		}

		System.out.println("=".repeat(90));
	}

	// Tab 5 - Verkauf mit sauberer Tabellenformatierung
	public void showVerkauf(Mitglieder ausgewaehlt, VerkaufManager manager) throws Exception {
		List<Bestellung> bestellungen = manager.findByMitgliederId(ausgewaehlt.getMitgliederID());

		if (bestellungen == null || bestellungen.isEmpty()) {
			System.out.println("\nDas Mitglied hat keine Bestellungen.");
			return;
		}

		SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy HH:mm");

		for (Bestellung bestellung : bestellungen) {
			System.out.printf("\n--- Bestellung ID: %d ---\n", bestellung.getBestellungID());
			System.out.printf("Datum:\t\t%s\n",
					bestellung.getBestelldatum() != null ? sdf.format(bestellung.getBestelldatum()) : "-");
			System.out.printf("Gesamtpreis:\t%.2f €\n\n", bestellung.getGesamtpreis());

			// Artikel in dieser Bestellung
			List<ArtikelBestellung> artikelBestellungen = manager.findArtikelBestellungen(bestellung.getBestellungID());

			if (!artikelBestellungen.isEmpty()) {
				System.out.println("Artikel:");
				System.out.printf("%-30s | %5s | %12s | %12s%n", "Name", "Menge", "Einzelpreis", "Summe");
				System.out.println("=".repeat(70));

				for (ArtikelBestellung ab : artikelBestellungen) {
					Artikel artikel = manager.getArtikelDAO().findById(ab.getArtikelID());
					if (artikel != null) {
						String name = artikel.getName() != null ? artikel.getName() : "-";

						// Name auf maximal 30 Zeichen begrenzen
						if (name.length() > 30) {
							name = name.substring(0, 27) + "...";
						}

						// Einzelpreis berechnen
						double einzelpreis = ab.getMenge() > 0 ? ab.getAufaddiert() / ab.getMenge() : 0;

						System.out.printf("%-30s | %5d | %12s | %12s%n", name, ab.getMenge(),
								String.format("%,.2f €", einzelpreis), String.format("%,.2f €", ab.getAufaddiert()));
					}
				}

				System.out.println("=".repeat(70));
			}
		}
	}

	public int getWochenBisErster(Date today, MitgliederVertrag mv) {
		Datum beginn = new Datum(mv.getVertragsbeginn());
		Datum bis = new Datum(today);
		Datum erster = new Datum(bis.getJahr(), bis.getMonat(), 1);
		if (beginn.isBefore(erster)) {
			long millisekunden = ersterZuDate(erster).getTime() - mv.getVertragsbeginn().getTime();
			int tage = (int) (millisekunden / (1000 * 60 * 60 * 24));
			return Math.max(0, tage / 7);
		} else {
			return 0;
		}
	}

	public int getWochenBisLetzterVormonat(MitgliederVertrag mv) {
		Datum beginn = new Datum(mv.getVertragsbeginn());
		Datum heute = DatumHelper.getAktuellesDatum();
		int jahr = heute.getMonat() == 1 ? heute.getJahr() - 1 : heute.getJahr();
		int monat = heute.getMonat() == 1 ? 12 : heute.getMonat() - 1;
		Calendar cal = Calendar.getInstance();
		cal.set(jahr, monat - 1, 1);
		cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
		Datum letzter = new Datum(cal.get(Calendar.YEAR), cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH));
		if (beginn.isBefore(letzter)) {
			long millisekunden = letzterZuDate(letzter).getTime() - mv.getVertragsbeginn().getTime();
			int tage = (int) (millisekunden / (1000 * 60 * 60 * 24));
			return Math.max(0, tage / 7);
		} else {
			return 0;
		}
	}

	private Date ersterZuDate(Datum d) {
		Calendar cal = Calendar.getInstance();
		cal.set(d.getJahr(), d.getMonat() - 1, d.getTag(), 0, 0, 0);
		cal.set(Calendar.MILLISECOND, 0);
		return cal.getTime();
	}

	private Date letzterZuDate(Datum d) {
		Calendar cal = Calendar.getInstance();
		cal.set(d.getJahr(), d.getMonat() - 1, d.getTag(), 23, 59, 59);
		cal.set(Calendar.MILLISECOND, 999);
		return cal.getTime();
	}
}

----- Inhalt von: VerkaufService.txt -----
package Service;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import Exception.IntException;
import Exception.NotFoundException;
import Manager.VerkaufManager;
import Objekte.Artikel;
import Objekte.ArtikelBestellung;
import Objekte.Bestellung;
import Objekte.Mitglieder;
import Objekte.Zahlung;

public class VerkaufService extends BaseService {

	private Map<Integer, Integer> warenkorb;
	private VerkaufManager verkaufManager;

	public VerkaufService(Connection connection, Scanner scanner) {
		super(connection, scanner);
		this.warenkorb = new HashMap<>();
		try {
			this.verkaufManager = new VerkaufManager();
		} catch (Exception e) {
			System.out.println("Fehler beim Initialisieren des VerkaufManagers: " + e.getMessage());
		}
	}

	public void start() {
		boolean zurueck = false;
		while (!zurueck) {
			System.out.println("==== Verkaufsverwaltung ====");
			System.out.println("1 - Verkauf starten");
			System.out.println("2 - Zurück zum Hauptmenü");
			System.out.print("Bitte wählen: ");
			String eingabe = scanner.nextLine();

			switch (eingabe) {
			case "1":
				starteVerkaufsprozess();
				break;
			case "2":
				zurueck = true;
				break;
			default:
				System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
			}
		}
	}

	private void starteVerkaufsprozess() {
		warenkorb.clear();

		boolean exitVerkauf = false;
		int tab = 1;

		while (!exitVerkauf) {
			switch (tab) {
			case 1:
				zeigeWarenkorb();
				break;
			case 2:
				zeigeKategorie("Getränke");
				break;
			case 3:
				zeigeKategorie("Shakes");
				break;
			case 4:
				zeigeKategorie("NEM");
				break;
			case 5:
				zeigeKategorie("Non food");
				break;
			default:
				System.out.println("(Tab nicht belegt)");
			}

			if (tab == 1 && !warenkorb.isEmpty()) {
				System.out.print("\nTab auswählen (1-5), 6: Abschluss, 7: Abbrechen, 0: Artikel entfernen\n");
			} else {
				System.out.print("\nTab auswählen (1-5), 6: Abschluss, 7: Abbrechen\n");
			}

			String tabEingabe = scanner.nextLine();

			if (tabEingabe.isBlank())
				continue;

			if (tabEingabe.equals("0") && tab == 1 && !warenkorb.isEmpty()) {
				artikelEntfernen();
			} else if (tabEingabe.equals("6")) {
				if (verkaufAbschliessen()) {
					exitVerkauf = true;
				}
			} else if (tabEingabe.equals("7")) {
				System.out.println("Verkauf abgebrochen.");
				warenkorb.clear();
				exitVerkauf = true;
			} else {
				try {
					int tabWahl = Integer.parseInt(tabEingabe);
					if (tabWahl >= 1 && tabWahl <= 5) {
						tab = tabWahl;
					}
				} catch (NumberFormatException ex) {
					System.out.println("Ungültige Tab-Nummer!");
				}
			}
		}
	}

	private void zeigeWarenkorb() {
		zeigeTabMenu("Warenkorb");

		if (warenkorb.isEmpty()) {
			System.out.println("\nWarenkorb ist leer.");
			return;
		}

		System.out.printf("%-10s | %-30s | %5s | %12s | %12s%n", "ArtikelID", "Name", "Menge", "Einzelpreis", "Summe");
		System.out.println("=".repeat(85));

		double gesamtsumme = 0.0;

		try {
			for (Map.Entry<Integer, Integer> entry : warenkorb.entrySet()) {
				Artikel artikel = verkaufManager.getArtikelDAO().findById(entry.getKey());
				if (artikel != null) {
					int menge = entry.getValue();
					double summe = artikel.getEinzelpreis() * menge;
					gesamtsumme += summe;

					String name = artikel.getName() != null ? artikel.getName() : "-";
					if (name.length() > 30) {
						name = name.substring(0, 27) + "...";
					}

					System.out.printf("%-10d | %-30s | %5d | %12s | %12s%n", artikel.getArtikelID(), name, menge,
							String.format("%,.2f €", artikel.getEinzelpreis()), String.format("%,.2f €", summe));
				}
			}

			System.out.println("=".repeat(85));
			System.out.printf("%-10s   %-30s   %5s   %12s   %12s%n", "", "", "", "Gesamtsumme:",
					String.format("%,.2f €", gesamtsumme));
		} catch (Exception e) {
			System.out.println("Fehler beim Anzeigen des Warenkorbs: " + e.getMessage());
		}
	}

	private void zeigeTabMenu(String aktiveKategorie) {
		System.out.print("1 ");
		if (aktiveKategorie.equals("Warenkorb")) {
			System.out.print("=== Warenkorb === ");
		} else {
			System.out.print("Warenkorb ");
		}
		System.out.print("| 2 ");

		if (aktiveKategorie.equalsIgnoreCase("Getränke")) {
			System.out.print("=== Getränke === ");
		} else {
			System.out.print("Getränke ");
		}
		System.out.print("| 3 ");

		if (aktiveKategorie.equalsIgnoreCase("Shakes")) {
			System.out.print("=== Shakes === ");
		} else {
			System.out.print("Shakes ");
		}
		System.out.print("| 4 ");

		if (aktiveKategorie.equalsIgnoreCase("NEM")) {
			System.out.print("=== NEM === ");
		} else {
			System.out.print("NEM ");
		}
		System.out.print("| 5 ");

		if (aktiveKategorie.equalsIgnoreCase("Non food")) {
			System.out.println("=== Non food ===");
		} else {
			System.out.println("Non food");
		}
	}

	private void zeigeKategorie(String kategorie) {
		try {
			List<Artikel> alleArtikel = verkaufManager.getArtikelDAO().findAll();

			List<Artikel> kategorieArtikel = new ArrayList<>();
			for (Artikel artikel : alleArtikel) {
				if (artikel.getKategorie() != null
						&& artikel.getKategorie().getBezeichnung().equalsIgnoreCase(kategorie)) {
					kategorieArtikel.add(artikel);
				}
			}

			if (kategorieArtikel.isEmpty()) {
				System.out.println("Keine Artikel in dieser Kategorie vorhanden.");
				System.out.println("\nEnter drücken zum Fortfahren...");
				scanner.nextLine();
				return;
			}

			boolean bleibenInKategorie = true;

			while (bleibenInKategorie) {
				zeigeTabMenu(kategorie);

				System.out.printf("%-10s | %-30s | %12s | %-40s%n", "ArtikelID", "Name", "Einzelpreis", "Kommentar");
				System.out.println("=".repeat(100));

				for (Artikel artikel : kategorieArtikel) {
					String name = artikel.getName() != null ? artikel.getName() : "-";
					String kommentar = artikel.getKommentar() != null ? artikel.getKommentar() : "-";

					if (name.length() > 30) {
						name = name.substring(0, 27) + "...";
					}
					if (kommentar.length() > 40) {
						kommentar = kommentar.substring(0, 37) + "...";
					}

					System.out.printf("%-10d | %-30s | %12s | %-40s%n", artikel.getArtikelID(), name,
							String.format("%,.2f €", artikel.getEinzelpreis()), kommentar);
				}

				System.out.println("=".repeat(100));

				System.out.print("\nArtikel hinzufügen? (ArtikelID oder 0 zum Verlassen): ");
				String eingabe = scanner.nextLine();

				if (eingabe.equals("0")) {
					bleibenInKategorie = false;
				} else if (!eingabe.isBlank()) {
					try {
						int artikelID = Integer.parseInt(eingabe);

						Artikel gewählterArtikel = null;
						for (Artikel artikel : kategorieArtikel) {
							if (artikel.getArtikelID() == artikelID) {
								gewählterArtikel = artikel;
								break;
							}
						}

						if (gewählterArtikel != null) {
							int menge = 1;
							int neueGesamtanzahl = warenkorb.getOrDefault(gewählterArtikel.getArtikelID(), 0) + menge;
							warenkorb.put(gewählterArtikel.getArtikelID(), neueGesamtanzahl);

							if (neueGesamtanzahl > 1) {
								System.out.println("✓ 1x " + gewählterArtikel.getName()
										+ " zum Warenkorb hinzugefügt! (Gesamt: " + neueGesamtanzahl + "x)");
							} else {
								System.out
										.println("✓ 1x " + gewählterArtikel.getName() + " zum Warenkorb hinzugefügt!");
							}
							System.out.println();
						} else {
							System.out.println("✗ ArtikelID nicht in dieser Kategorie gefunden!");
							System.out.println();
						}
					} catch (NumberFormatException e) {
						System.out.println("✗ Ungültige Eingabe!");
						System.out.println();
					}
				}
			}

		} catch (Exception e) {
			System.out.println("Fehler beim Anzeigen der Kategorie: " + e.getMessage());
			e.printStackTrace();
		}
	}

	private void artikelEntfernen() {
		System.out.print("\nArtikel entfernen (ArtikelID eingeben oder Enter zum Abbrechen): ");
		String eingabe = scanner.nextLine();

		if (!eingabe.isBlank()) {
			try {
				int artikelID = Integer.parseInt(eingabe);

				if (warenkorb.containsKey(artikelID)) {
					int aktuelleAnzahl = warenkorb.get(artikelID);

					if (aktuelleAnzahl > 1) {
						warenkorb.put(artikelID, aktuelleAnzahl - 1);
						System.out.println("✓ Anzahl um 1 reduziert. Neue Anzahl: " + (aktuelleAnzahl - 1));
					} else {
						warenkorb.remove(artikelID);
						System.out.println("✓ Artikel komplett entfernt.");
					}
				} else {
					System.out.println("✗ ArtikelID nicht im Warenkorb!");
				}
			} catch (NumberFormatException e) {
				System.out.println("✗ Ungültige Eingabe.");
			}
		}
	}

	private boolean verkaufAbschliessen() {
		if (warenkorb.isEmpty()) {
			System.out.println("Warenkorb ist leer. Verkauf kann nicht abgeschlossen werden.");
			return false;
		}

		zeigeTabMenu("Warenkorb");
		System.out.println();

		try {
			int zahlungsID = wähleZahlungsart();
			if (zahlungsID == -1) {
				System.out.println("Verkauf abgebrochen.");
				return false;
			}

			Object kunde = sucheKunde();
			if (kunde == null) {
				System.out.println("Verkauf abgebrochen.");
				return false;
			}

			boolean istMitglied = kunde instanceof Mitglieder;
			String zahlungsart = getZahlungsartName(zahlungsID);

			if (!istMitglied) {
				System.out.println("✗ Nur Mitglieder können Bestellungen aufgeben!");
				return false;
			}

			if (!zahlungsart.equalsIgnoreCase("Barzahlung") && !zahlungsart.equalsIgnoreCase("Abbuchung")
					&& !zahlungsart.equalsIgnoreCase("SEPA-Lastschrift")) {
				System.out.println("✗ Ungültige Zahlungsart!");
				return false;
			}

			Mitglieder mitglied = (Mitglieder) kunde;

			double gesamtpreis = 0.0;
			for (Map.Entry<Integer, Integer> entry : warenkorb.entrySet()) {
				Artikel artikel = verkaufManager.getArtikelDAO().findById(entry.getKey());
				if (artikel != null) {
					gesamtpreis += artikel.getEinzelpreis() * entry.getValue();
				}
			}

			System.out.println("\n=== Verkaufsübersicht ===");
			System.out.println("Kunde: " + mitglied.getVorname() + " " + mitglied.getNachname() + " (Mitglied-ID: "
					+ mitglied.getMitgliederID() + ")");
			System.out.println("Zahlungsart: " + zahlungsart);
			System.out.println();

			zeigeWarenkorb();

			System.out.print("\nVerkauf wirklich abschließen? (ja/nein): ");
			String bestaetigung = scanner.nextLine();

			if (bestaetigung.equalsIgnoreCase("ja")) {
				int mitarbeiterID = wähleMitarbeiter();
				if (mitarbeiterID == -1) {
					System.out.println("Verkauf abgebrochen.");
					return false;
				}
				speichereBestellung(mitglied, zahlungsID, gesamtpreis, mitarbeiterID);

				System.out.println("\n✓ Verkauf erfolgreich abgeschlossen und in Datenbank gespeichert!");
				warenkorb.clear();
				return true;
			} else {
				System.out.println("Verkauf wurde nicht abgeschlossen.");
				return false;
			}

		} catch (Exception e) {
			System.out.println("✗ Fehler beim Verkaufsabschluss: " + e.getMessage());
			e.printStackTrace();
		}

		return false;
	}

	private int wähleZahlungsart() {
		System.out.println("\n=== Zahlungsart wählen ===");

		try {
			List<Zahlung> zahlungsarten = verkaufManager.getZahlungDAO().findAll();

			if (zahlungsarten.isEmpty()) {
				System.out.println("Keine Zahlungsarten verfügbar!");
				return -1;
			}

			System.out.println("ZahlungsID | Bezeichnung");
			System.out.println("-----------------------------");
			for (Zahlung zahlung : zahlungsarten) {
				System.out.printf("%-10d | %s%n", zahlung.getZahlungID(), zahlung.getZahlungsart());
			}
			System.out.println("-----------------------------");

			System.out.print("\nZahlungsart auswählen (ZahlungsID oder 0 zum Abbrechen): ");
			String eingabe = scanner.nextLine();

			if (eingabe.equals("0")) {
				return -1;
			}

			int zahlungID = Integer.parseInt(eingabe);

			for (Zahlung zahlung : zahlungsarten) {
				if (zahlung.getZahlungID() == zahlungID) {
					return zahlungID;
				}
			}

			System.out.println("✗ Ungültige ZahlungsID!");
			return -1;

		} catch (NumberFormatException e) {
			System.out.println("✗ Ungültige Eingabe!");
			return -1;
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Zahlungsarten: " + e.getMessage());
			return -1;
		}
	}

	private Object sucheKunde() {
		System.out.println("\n=== Kunde suchen ===");
		System.out.println("1 - Nach MitgliederID suchen");
		System.out.println("2 - Nach Vorname und Nachname suchen");
		System.out.print("Bitte wählen (oder 0 zum Abbrechen): ");

		String auswahl = scanner.nextLine();

		if (auswahl.equals("0")) {
			return null;
		}

		try {
			if (auswahl.equals("1")) {
				System.out.print("MitgliederID eingeben: ");
				String idStr = scanner.nextLine();
				int mitgliederID = Integer.parseInt(idStr);

				Mitglieder mitglied = verkaufManager.getMitgliederDAO().findById(mitgliederID);

				if (mitglied != null) {
					zeigeMitgliedDetails(mitglied);
					System.out.print("\nDiesen Kunden verwenden? (ja/nein): ");
					if (scanner.nextLine().equalsIgnoreCase("ja")) {
						return mitglied;
					}
				} else {
					System.out.println("✗ Kein Mitglied mit dieser ID gefunden!");
				}

			} else if (auswahl.equals("2")) {
				System.out.print("Vorname eingeben: ");
				String vorname = scanner.nextLine();

				System.out.print("Nachname eingeben: ");
				String nachname = scanner.nextLine();

				List<Mitglieder> mitglieder = verkaufManager.getMitgliederDAO().searchByName(vorname, nachname);

				if (mitglieder.isEmpty()) {
					System.out.println("✗ Keine Ergebnisse gefunden!");
					return null;
				}

				System.out.println("\n=== Suchergebnisse ===");
				System.out.println("MitgliederID | Vorname           | Nachname          | Typ");
				System.out.println("-------------------------------------------------------------------");

				System.out.print("\nMitgliederID auswählen (oder 0 zum Abbrechen): ");
				String idStr = scanner.nextLine();

				if (idStr.equals("0")) {
					return null;
				}

				int ausgewählteID = Integer.parseInt(idStr);

				for (Mitglieder m : mitglieder) {
					if (m.getMitgliederID() == ausgewählteID) {
						return m;
					}
				}

				System.out.println("✗ Ungültige Auswahl!");
			}

		} catch (NumberFormatException e) {
			System.out.println("✗ Ungültige Eingabe!");
		} catch (Exception e) {
			System.out.println("Fehler bei der Kundensuche: " + e.getMessage());
			e.printStackTrace();
		}

		return null;
	}

	private int wähleMitarbeiter() {
		System.out.println("\n=== Mitarbeiter wählen ===");
		try {
			List<Objekte.Mitarbeiter> mitarbeiterListe = verkaufManager.getMitarbeiterDAO().findAll();
			if (mitarbeiterListe.isEmpty()) {
				System.out.println("Keine Mitarbeiter vorhanden!");
				return -1;
			}

			System.out.println("MitarbeiterID | Vorname | Nachname");
			System.out.println("-----------------------------------");
			for (Objekte.Mitarbeiter m : mitarbeiterListe) {
				System.out.printf("%-12d | %-7s | %-9s%n", m.getMitarbeiterID(), m.getVorname(), m.getNachname());
			}
			System.out.println("-----------------------------------");

			System.out.print("\nMitarbeiterID eingeben (oder 0 zum Abbrechen): ");
			String eingabe = scanner.nextLine();
			if (eingabe.equals("0")) {
				return -1;
			}

			int mitarbeiterID = Integer.parseInt(eingabe);
			for (Objekte.Mitarbeiter m : mitarbeiterListe) {
				if (m.getMitarbeiterID() == mitarbeiterID) {
					return mitarbeiterID;
				}
			}
			System.out.println("✗ Ungültige MitarbeiterID!");
			return -1;
		} catch (NumberFormatException e) {
			System.out.println("✗ Ungültige Eingabe!");
			return -1;
		} catch (Exception e) {
			System.out.println("Fehler beim Laden der Mitarbeiter: " + e.getMessage());
			return -1;
		}
	}

	/**
	 * Speichert eine Bestellung in der Datenbank
	 */
	private void speichereBestellung(Mitglieder mitglied, int zahlungID, double gesamtpreis, int mitarbeiterID)
			throws SQLException, IntException, NotFoundException {
		try {
			// 1. Bestellung-Objekt erstellen
			Bestellung bestellung = new Bestellung();
			bestellung.setMitgliederID(mitglied.getMitgliederID());
			bestellung.setZahlungID(zahlungID);
			bestellung.setGesamtpreis(gesamtpreis);
			bestellung.setMitarbeiterID(mitarbeiterID);
			bestellung.setBestelldatum(new java.sql.Timestamp(System.currentTimeMillis()));

			// 2. Bestellung in DB einfügen (BestellungID wird automatisch generiert)
			verkaufManager.getBestellungDAO().insert(bestellung);

			int bestellungID = bestellung.getBestellungID();
			System.out.println("✓ Bestellung gespeichert (BestellungID: " + bestellungID + ")");

			// 3. Alle Artikel der Bestellung speichern
			for (Map.Entry<Integer, Integer> entry : warenkorb.entrySet()) {
				int artikelID = entry.getKey();
				int menge = entry.getValue();

				// Artikel-Objekt holen für Einzelpreis
				Artikel artikel = verkaufManager.getArtikelDAO().findById(artikelID);
				if (artikel != null) {
					double aufaddiert = artikel.getEinzelpreis() * menge;

					// ArtikelBestellung-Objekt erstellen
					ArtikelBestellung artikelBestellung = new ArtikelBestellung(bestellungID, artikelID, menge,
							aufaddiert);

					// ArtikelBestellung in DB einfügen
					verkaufManager.getArtikelBestellungDAO().insert(artikelBestellung);
				}
			}

			System.out.println("✓ " + warenkorb.size() + " Artikel zur Bestellung hinzugefügt");

			// ✅ Quittung drucken
			verkaufManager.druckeBestellungsQuittung(bestellungID);

		} catch (SQLException e) {
			System.out.println("✗ Fehler beim Speichern der Bestellung: " + e.getMessage());
			throw e;
		}
	}

	private void zeigeMitgliedDetails(Mitglieder mitglied) {
		System.out.println("\n=== Kunde gefunden ===");
		System.out.println("MitgliederID: " + mitglied.getMitgliederID());
		System.out.println("Name: " + mitglied.getVorname() + " " + mitglied.getNachname());
		System.out.println("E-Mail: " + (mitglied.getMail() != null ? mitglied.getMail() : "-"));
		System.out.println("Telefon: " + (mitglied.getTelefon() != null ? mitglied.getTelefon() : "-"));
	}

	private String getZahlungsartName(int zahlungsID) {
		try {
			Zahlung zahlung = verkaufManager.getZahlungDAO().findById(zahlungsID);
			return zahlung != null ? zahlung.getZahlungsart() : "Unbekannt";
		} catch (Exception e) {
			return "Unbekannt";
		}
	}
}

----- Inhalt von: VertragService.txt -----
package Service;

import java.sql.Connection;
import java.sql.SQLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Scanner;

import DAOs.IntervallDAO;
import DAOs.MitarbeiterDAO;
import DAOs.MitgliederDAO;
import DAOs.MitgliederVertragDAO;
import DAOs.OrtDAO;
import DAOs.VertragDAO;
import DAOs.ZahlungDAO;
import DAOs.ZahlungsdatenDAO;
import Exception.IntException;
import Exception.StringException;
import Exception.TooLongException;
import Exception.TooShortException;
import Objekte.Intervall;
import Objekte.Mitarbeiter;
import Objekte.Mitglieder;
import Objekte.MitgliederVertrag;
import Objekte.Ort;
import Objekte.Vertrag;
import Objekte.Zahlung;
import Objekte.Zahlungsdaten;

public class VertragService extends BaseService {

	// ========== DAOs ==========
	private final OrtDAO ortDAO;
	private final ZahlungsdatenDAO zahlungsdatenDAO;
	private final MitgliederDAO mitgliederDAO;
	private final VertragDAO vertragDAO;
	private final IntervallDAO intervallDAO;
	private final MitgliederVertragDAO mitgliederVertragDAO;
	private final ZahlungDAO zahlungDAO;

	// ========== KONSTRUKTOR ==========
	public VertragService(Connection connection, Scanner scanner) {
		super(connection, scanner);
		this.ortDAO = new OrtDAO(connection);
		this.zahlungsdatenDAO = new ZahlungsdatenDAO(connection);
		this.mitgliederDAO = new MitgliederDAO(connection);
		this.vertragDAO = new VertragDAO(connection);
		this.intervallDAO = new IntervallDAO(connection);
		this.mitgliederVertragDAO = new MitgliederVertragDAO(connection);
		this.zahlungDAO = new ZahlungDAO(connection);
	}
	// ========================
	// Start Methoden
	// ========================

	public void start() {
		boolean exit = false;
		while (!exit) {
			System.out.println("==== Vertragsverwaltung ====");
			System.out.println("1 - Neukunde anlegen");
			System.out.println("2 - Vertrag verlängern");
			System.out.println("3 - Vertrag kündigen");
			System.out.println("4 - Zurück zum Hauptmenü");
			System.out.print("Bitte wählen: ");
			String eingabe = scanner.nextLine();

			switch (eingabe) {
			case "1":
				try {
					neukundeAnlegen();
					break;
				} catch (TooLongException | IntException | SQLException | TooShortException | StringException e) {
					e.printStackTrace();
				}
			case "2":
			case "3":
				System.out.println("WIP");
				break;
			case "4":
				exit = true;
				break;
			default:
				System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
			}
		}
	}

	public double berechneBetragJeIntervall(Vertrag vertrag, MitgliederVertrag mv, int IntervallID) {
		double basis = vertrag.getGrundpreis() - mv.getPreisrabatt();
		switch (IntervallID) {
		case 3:
			return basis;
		case 4:
			return basis * 2;
		case 1:
		case 2:
			return basis * 53.0 / 12.0;
		default:
			return 0;
		}
	}

	public Date berechneZahlungsbeginn(Date vertragsbeginn, int IntervallID) {
		Calendar cal = Calendar.getInstance();
		cal.setTime(vertragsbeginn);
		switch (IntervallID) {
		case 3:
			cal.add(Calendar.DAY_OF_MONTH, 7);
			break;
		case 4:
			cal.add(Calendar.DAY_OF_MONTH, 14);
			break;
		case 1:
			cal.add(Calendar.MONTH, 1);
			cal.set(Calendar.DAY_OF_MONTH, 1);
			break;
		case 2:
			cal.add(Calendar.MONTH, 1);
			cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));
			break;
		default:
			return null;
		}
		return cal.getTime();
	}

	// ========================
	// Neukunde Anlegen Methode
	// ========================

	private void neukundeAnlegen()
	        throws SQLException, StringException, IntException, TooShortException, TooLongException {
	    Mitglieder mitglied = new Mitglieder();
	    System.out.println("==== Neukunde anlegen ====");

	    // --- Stammdaten erfassen ---
	    System.out.print("Vorname: ");
	    mitglied.setVorname(scanner.nextLine());
	    System.out.print("Nachname: ");
	    mitglied.setNachname(scanner.nextLine());
	    System.out.print("Straße: ");
	    mitglied.setStrasse(scanner.nextLine());
	    System.out.print("Hausnummer: ");
	    mitglied.setHausnr(scanner.nextLine());
	    System.out.print("PLZ (5-stellig): ");
	    String plz = scanner.nextLine();
	    while (plz.length() != 5) {
	        System.out.println("✗ PLZ muss genau 5 Zeichen lang sein.");
	        System.out.print("PLZ (5-stellig): ");
	        plz = scanner.nextLine();
	    }
	    System.out.print("Ort: ");
	    String ortName = scanner.nextLine();
	    int ortId = ortDAO.findOrCreateOrt(plz, ortName);
	    Ort ortObjekt = ortDAO.findById(ortId);
	    mitglied.setOrt(ortObjekt);
	    System.out.print("Geburtsdatum (TT.MM.JJJJ): ");
	    String geburtsdatumString = scanner.nextLine();
	    SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy"), sdfView = new SimpleDateFormat("dd.MM.yyyy");
	    try {
	        Date geburtsdatum = sdf.parse(geburtsdatumString);
	        mitglied.setGeburtsdatum(geburtsdatum);
	    } catch (ParseException e) {
	        System.out.println("Ungültiges Datumsformat! Bitte TT.MM.JJJJ eingeben.");
	    }
	    System.out.print("Telefon: ");
	    mitglied.setTelefon(scanner.nextLine());
	    System.out.print("E-Mail: ");
	    mitglied.setMail(scanner.nextLine());

	    boolean bearbeiten = true;
	    while (bearbeiten) {
	        System.out.println("==== Abfrage Stammdaten ====");
	        System.out.println("1 Vorname:\t\t" + mitglied.getVorname());
	        System.out.println("2 Nachname:\t\t" + mitglied.getNachname());
	        System.out.println("3 Straße:\t\t" + mitglied.getStrasse() + " " + mitglied.getHausnr());
	        System.out.println("4 Ort:\t\t\t" + (mitglied.getOrt() != null ? mitglied.getOrt().getPLZ() : "-") + " "
	                + (mitglied.getOrt() != null ? mitglied.getOrt().getOrt() : "-"));
	        System.out.println("5 Geburtsdatum:\t\t" + (mitglied.getGeburtsdatum() != null ? sdfView.format(mitglied.getGeburtsdatum()) : "-"));
	        System.out.println("6 Telefon:\t\t" + mitglied.getTelefon());
	        System.out.println("7 Mail:\t\t\t" + mitglied.getMail());
	        System.out.println("Eingabe bestätigen? (Enter) oder Nummer zum Bearbeiten: ");
	        String eingabe = scanner.nextLine();
	        if (eingabe.isEmpty()) {
	            bearbeiten = false;
	        } else {
	            int nummer = Integer.parseInt(eingabe);
	            switch (nummer) {
	                case 1:
	                    System.out.print("Vorname: ");
	                    mitglied.setVorname(scanner.nextLine());
	                    break;
	                case 2:
	                    System.out.print("Nachname: ");
	                    mitglied.setNachname(scanner.nextLine());
	                    break;
	                case 3:
	                    System.out.print("Straße: ");
	                    mitglied.setStrasse(scanner.nextLine());
	                    System.out.print("Hausnummer: ");
	                    mitglied.setHausnr(scanner.nextLine());
	                    break;
	                case 4:
	                    System.out.print("PLZ (5-stellig): ");
	                    plz = scanner.nextLine();
	                    while (plz.length() != 5) {
	                        System.out.println("✗ PLZ muss genau 5 Zeichen lang sein.");
	                        System.out.print("PLZ (5-stellig): ");
	                        plz = scanner.nextLine();
	                    }
	                    System.out.print("Ort: ");
	                    ortName = scanner.nextLine();
	                    ortId = ortDAO.findOrCreateOrt(plz, ortName);
	                    ortObjekt = ortDAO.findById(ortId);
	                    mitglied.setOrt(ortObjekt);
	                    break;
	                case 5:
	                    System.out.print("Geburtsdatum (TT.MM.JJJJ): ");
	                    geburtsdatumString = scanner.nextLine();
	                    try {
	                        Date geburtsdatum = sdf.parse(geburtsdatumString);
	                        mitglied.setGeburtsdatum(geburtsdatum);
	                    } catch (ParseException e) {
	                        System.out.println("Ungültiges Datum! Bitte TT.MM.JJJJ.");
	                    }
	                    break;
	                case 6:
	                    System.out.print("Telefon: ");
	                    mitglied.setTelefon(scanner.nextLine());
	                    break;
	                case 7:
	                    System.out.print("E-Mail: ");
	                    mitglied.setMail(scanner.nextLine());
	                    break;
	                default:
	                    System.out.println("Ungültige Auswahl!");
	            }
	        }
	    }
	    System.out.println("✓ Kundendaten erfasst. Weiter zu Vertragsdaten...");

	    // --- Vertragsdaten erfassen ---
	    Vertrag vertrag = null;
	    MitgliederVertrag mv = new MitgliederVertrag();
	    System.out.println("==== Vertragsdaten ====");
	    System.out.println("==== Verträge Übersicht ====");
	    List<Vertrag> vertragListe = vertragDAO.findAll();
	    System.out.printf("%-5s %-20s %-10s %-12s\n", "ID", "Bezeichnung", "Preis", "Laufzeit");
	    for (Vertrag v : vertragListe) {
	        System.out.printf("%-5d %-20s %-10.2f %-12d\n",
	        v.getVertragID(), v.getBezeichnung(), v.getGrundpreis(), v.getLaufzeit());
	    }
	    System.out.print("VertragID auswählen: ");
	    int ausgewaehlteVertragID = Integer.parseInt(scanner.nextLine());
	    vertrag = vertragDAO.findById(ausgewaehlteVertragID);
	    if (vertrag == null) {
	        System.out.println("Ungültige VertragID! Prozess abgebrochen.");
	        return;
	    }
	    System.out.print("Vertragsbeginn (TT.MM.JJJJ): ");
	    String vertragsbeginnString = scanner.nextLine();
	    try {
	        Date vertragsbeginn = sdf.parse(vertragsbeginnString);
	        mv.setVertragsbeginn(vertragsbeginn);
	        if (vertrag != null && vertragsbeginn != null) {
	            Calendar cal = Calendar.getInstance();
	            cal.setTime(vertragsbeginn);
	            cal.add(Calendar.WEEK_OF_YEAR, vertrag.getLaufzeit());
	            mv.setVertragsende(cal.getTime());
	        }
	    } catch (ParseException e) {
	        System.out.println("Ungültiges Format! Bitte TT.MM.JJJJ verwenden.");
	    }
	    System.out.print("Preisrabatt (€): ");
	    String rabattEingabe = scanner.nextLine().replace(',', '.');
	    try {
	        mv.setPreisrabatt(Double.parseDouble(rabattEingabe));
	    } catch (NumberFormatException e) {
	        System.out.println("✗ Ungültiges Format! Bitte mit Punkt oder Komma schreiben, z.B. 5.20 oder 5,20");
	        mv.setPreisrabatt(0.0);
	    }
	    System.out.print("Kommentar: ");
	    mv.setKommentar(scanner.nextLine());

	    System.out.println("==== Intervall Übersicht ====");
	    List<Intervall> intervallListe = intervallDAO.findAll();
	    System.out.printf("%-5s %-20s\n", "ID", "Bezeichnung");
	    for (Intervall intervall : intervallListe) {
	        System.out.printf("%-5d %-20s\n", intervall.getIntervallID(), intervall.getBezeichnung());
	    }
	    System.out.print("IntervallID auswählen: ");
	    int ausgewaehlteIntervallID = Integer.parseInt(scanner.nextLine());
	    mv.setIntervallID(ausgewaehlteIntervallID);

	    System.out.print("Trainingsbeginn (TT.MM.JJJJ): ");
	    String trainingsbeginnString = scanner.nextLine();
	    try {
	        Date trainingsbeginn = sdf.parse(trainingsbeginnString);
	        mv.setTrainingsbeginn(trainingsbeginn);
	    } catch (ParseException e) {
	        System.out.println("Ungültiges Format! Bitte TT.MM.JJJJ verwenden.");
	    }

	    boolean vertragsdatenBearbeiten = true;
	    while (vertragsdatenBearbeiten) {
	        System.out.println("==== Abfrage Vertragsdaten ====");
	        System.out.println("1 Vertragsart:\t\t" + vertrag.getBezeichnung());
	        System.out.println("2 Laufzeit (Wochen):\t" + vertrag.getLaufzeit());
	        System.out.println("3 Vertragsbeginn:\t"
	                + (mv.getVertragsbeginn() != null ? sdfView.format(mv.getVertragsbeginn()) : "-"));
	        System.out.println("4 Vertragsende:\t\t"
	                + (mv.getVertragsende() != null ? sdfView.format(mv.getVertragsende()) : "-"));
	        System.out.println("5 Preisrabatt (€):\t" + String.format("%.2f", mv.getPreisrabatt()));
	        System.out.println("6 Kommentar:\t\t" + mv.getKommentar());
	        String intervallBezeichnung = "-";
	        if (mv.getIntervallID() > 0) {
	            Intervall intervallObjekt = intervallDAO.findById(mv.getIntervallID());
	            if (intervallObjekt != null) {
	                intervallBezeichnung = intervallObjekt.getBezeichnung();
	            }
	        }
	        System.out.println("7 Zahlungsintervall:\t" + intervallBezeichnung);
	        System.out.println("8 Trainingsbeginn:\t"
	                + (mv.getTrainingsbeginn() != null ? sdfView.format(mv.getTrainingsbeginn()) : "-"));
	        System.out.println("Eingabe bestätigen? (Enter) oder Nummer zum Bearbeiten: ");
	        String eingabe = scanner.nextLine();
	        if (eingabe.isEmpty()) {
	            vertragsdatenBearbeiten = false;
	        } else {
	            int nummer = Integer.parseInt(eingabe);
	            switch (nummer) {
	                case 3:
	                    System.out.print("Vertragsbeginn (TT.MM.JJJJ): ");
	                    vertragsbeginnString = scanner.nextLine();
	                    try {
	                        Date vertragsbeginn = sdfView.parse(vertragsbeginnString);
	                        mv.setVertragsbeginn(vertragsbeginn);
	                        if (vertrag != null && vertragsbeginn != null) {
	                            Calendar cal = Calendar.getInstance();
	                            cal.setTime(vertragsbeginn);
	                            cal.add(Calendar.WEEK_OF_YEAR, vertrag.getLaufzeit());
	                            mv.setVertragsende(cal.getTime());
	                        }
	                    } catch (ParseException e) {
	                        System.out.println("Ungültiges Format!");
	                    }
	                    break;
	                case 2:
	                    System.out.print("Laufzeit (Wochen): ");
	                    int neueLaufzeit = Integer.parseInt(scanner.nextLine());
	                    vertrag.setLaufzeit(neueLaufzeit);
	                    if (mv.getVertragsbeginn() != null) {
	                        Calendar cal = Calendar.getInstance();
	                        cal.setTime(mv.getVertragsbeginn());
	                        cal.add(Calendar.WEEK_OF_YEAR, vertrag.getLaufzeit());
	                        mv.setVertragsende(cal.getTime());
	                    }
	                    break;
	                case 5:
	                    System.out.print("Preisrabatt (€): ");
	                    rabattEingabe = scanner.nextLine().replace(',', '.');
	                    try {
	                        mv.setPreisrabatt(Double.parseDouble(rabattEingabe));
	                    } catch (NumberFormatException e) {
	                        System.out.println("Ungültiges Format!");
	                    }
	                    break;
	                case 6:
	                    System.out.print("Kommentar: ");
	                    mv.setKommentar(scanner.nextLine());
	                    break;
	                case 7:
	                    System.out.println("==== Intervall Übersicht ====");
	                    intervallListe = intervallDAO.findAll();
	                    System.out.printf("%-5s %-20s\n", "ID", "Bezeichnung");
	                    for (Intervall intervall : intervallListe) {
	                        System.out.printf("%-5d %-20s\n", intervall.getIntervallID(), intervall.getBezeichnung());
	                    }
	                    System.out.print("IntervallID auswählen: ");
	                    mv.setIntervallID(Integer.parseInt(scanner.nextLine()));
	                    break;
	                case 8:
	                    System.out.print("Trainingsbeginn (TT.MM.JJJJ): ");
	                    trainingsbeginnString = scanner.nextLine();
	                    try {
	                        Date trainingsbeginn = sdfView.parse(trainingsbeginnString);
	                        mv.setTrainingsbeginn(trainingsbeginn);
	                    } catch (ParseException e) {
	                        System.out.println("Ungültiges Format!");
	                    }
	                    break;
	                default:
	                    System.out.println("Nicht bearbeitbar oder ungültige Auswahl!");
	            }
	        }
	    }

	    // --- Zahlungsdaten erfassen und im Methodenscope deklarieren ---
	    System.out.println("==== Zahlungsdaten ====");
	    String name, iban, bic;
	    do {
	        System.out.print("Kontoinhaber: ");
	        name = scanner.nextLine().trim();
	        if (name.isEmpty())
	            System.out.println("✗ Kontoinhaber darf nicht leer sein.");
	    } while (name.isEmpty());
	    do {
	        System.out.print("IBAN: ");
	        iban = scanner.nextLine().trim();
	        if (iban.isEmpty())
	            System.out.println("✗ IBAN darf nicht leer sein.");
	    } while (iban.isEmpty());
	    do {
	        System.out.print("BIC: ");
	        bic = scanner.nextLine().trim();
	        if (bic.isEmpty())
	            System.out.println("✗ BIC darf nicht leer sein.");
	    } while (bic.isEmpty());

	    int zahlungsdatenID = zahlungsdatenDAO.findOrCreateZahlungsdaten(name, iban, bic);
	    mitglied.setZahlungsdatenID(zahlungsdatenID);
	    Zahlungsdaten check = zahlungsdatenDAO.findById(zahlungsdatenID);  // EINMAL ANLEGEN UND ÜBERALL NUTZEN

	    System.out.print("MitarbeiterID: ");
	    int mitarbeiterID = Integer.parseInt(scanner.nextLine());

	    // --- Übersicht anzeigen (check wird genutzt!) ---
	    zeigeFinaleUebersicht(
	        mitglied.getVorname(), mitglied.getNachname(), mitglied.getStrasse(), mitglied.getHausnr(),
	        mitglied.getOrt() != null ? mitglied.getOrt().getPLZ() : "-",
	        mitglied.getOrt() != null ? mitglied.getOrt().getOrt() : "-",
	        mitglied.getGeburtsdatum() != null ? sdf.format(mitglied.getGeburtsdatum()) : "-",
	        mitglied.getTelefon(), mitglied.getMail(), vertrag.getBezeichnung(), vertrag.getLaufzeit(),
	        mv.getVertragsbeginn() != null ? sdf.format(mv.getVertragsbeginn()) : "-",
	        mv.getVertragsende() != null ? sdf.format(mv.getVertragsende()) : "-",
	        intervallDAO.findById(mv.getIntervallID()).getBezeichnung(), vertrag.getGrundpreis(),
	        mv.getPreisrabatt(), (vertrag.getGrundpreis() - mv.getPreisrabatt()), mv.getKommentar(),
	        mv.getTrainingsbeginn() != null ? sdf.format(mv.getTrainingsbeginn()) : "-",
	        berechneBetragJeIntervall(vertrag, mv, mv.getIntervallID()),
	        berechneZahlungsbeginn(mv.getVertragsbeginn(), mv.getIntervallID()) != null
	            ? sdf.format(berechneZahlungsbeginn(mv.getVertragsbeginn(), mv.getIntervallID())) : "-",
	        check != null ? check.getName() : "",
	        check != null ? check.getIBAN() : "",
	        check != null ? check.getBIC() : "",
	        mitarbeiterID
	    );

	    // --- Bestätigung und Mitglied+Vertrag speichern ---
	    System.out.print("Vertrag speichern? (ja/nein): ");
	    String bestaetigung = scanner.nextLine();
	    if (bestaetigung.equalsIgnoreCase("ja")) {
	        try {
	            mitgliederDAO.insert(mitglied);
	            Mitglieder geladenesMitglied = mitgliederDAO.findById(mitglied.getMitgliederID());
	            Zahlungsdaten checkFinal = geladenesMitglied != null
	                ? zahlungsdatenDAO.findById(geladenesMitglied.getZahlungsdatenID())
	                : null;

	            if (geladenesMitglied == null) {
	                System.out.println("Fehler: Mitglied nicht gefunden nach Insert!");
	                return;
	            }
	            if (checkFinal == null || checkFinal.getName().isEmpty() || checkFinal.getIBAN().isEmpty() || checkFinal.getBIC().isEmpty()) {
	                System.out.println("✗ Die Zahlungsdaten in der Datenbank sind nicht vollständig für Mitglied (" +
	                        geladenesMitglied.getMitgliederID() + ")!");
	                return;
	            }
	            mv.setMitgliederID(geladenesMitglied.getMitgliederID());
	            mv.setVertragID(vertrag.getVertragID());
	            mv.setVertragsbeginn(mv.getVertragsbeginn());
	            mv.setVertragsende(mv.getVertragsende());
	            mv.setVerlängerung(mv.isVerlängerung());
	            mv.setAktiv(mv.isAktiv());
	            mv.setGekündigt(mv.isGekündigt());
	            mv.setPreisrabatt(mv.getPreisrabatt());
	            mv.setIntervallID(mv.getIntervallID());
	            mv.setZahlungID(3); // z.B. SEPA-Lastschrift
	            Zahlung zahlung = zahlungDAO.findById(mv.getZahlungID());
	            if (zahlung == null) zahlung = new Zahlung();
	            zahlung.setZahlungID(3);
	            zahlung.setZahlungsart("SEPA-Lastschrift");
	            mv.setMitarbeiterID(mitarbeiterID);
	            mv.setTrainingsbeginn(mv.getTrainingsbeginn());
	            mv.setKommentar(mv.getKommentar());

	            mitgliederVertragDAO.insert(mv, vertrag, zahlung, geladenesMitglied, vertrag.getLaufzeit());
	            System.out.println("✓ Vertrag erfolgreich gespeichert.");
	        } catch (Exception e) {
	            System.out.println("Fehler beim Speichern: " + e.getMessage());
	        }
	    } else {
	        System.out.println("Vertrag wurde nicht gespeichert.");
	    }
	}


	// ========================
	// Finale Übersicht anzeigen
	// ========================

	private void zeigeFinaleUebersicht(String vorname, String nachname, String strasse, String hausnr, String plz,
			String ort, String geburtsdatum, String telefon, String mail, String bezeichnung, int laufzeit,
			String vertragsbeginn, String vertragsende, String intervallBezeichnung, double grundpreis,
			double preisrabatt, double wochenpreis, String kommentar, String trainingsbeginn, double betragJeIntervall,
			String zahlungsbeginn, String kontoinhaber, String iban, String bic, int mitarbeiterID)
			throws SQLException {

		MitarbeiterDAO mitarbeiterDAO = new MitarbeiterDAO(connection);
		String mitarbeiterName = "Unbekannt";
		try {
			Mitarbeiter m = mitarbeiterDAO.findById(mitarbeiterID);
			if (m != null) {
				mitarbeiterName = m.getVorname() + " " + m.getNachname();
			}
		} catch (Exception e) {
			System.out.println("Fehler beim Laden des Mitarbeiters: " + e.getMessage());
		}

		System.out.println("==================================================");
		System.out.println("          Gesamtübersicht - Vertragsdaten");
		System.out.println("==================================================");
		System.out.println("\nKundendaten:");
		System.out.println("   Vorname:\t\t" + vorname);
		System.out.println("   Nachname:\t\t" + nachname);
		System.out.println("   Geburtstag:\t\t" + geburtsdatum);
		System.out.println("   Telefon:\t\t" + telefon);
		System.out.println("   E-Mail:\t\t" + mail);
		System.out.println("   Adresse:\t\t" + strasse + " " + hausnr);
		System.out.println("   Ort:\t\t\t" + plz + " " + ort);
		System.out.println("---------------------------------------------------");
		System.out.println("\nVertragsdaten:");
		System.out.println("   Vertragsart:\t\t" + bezeichnung);
		System.out.println("   Laufzeit:\t\t" + laufzeit + " Wochen");
		System.out.println("   Vertragsbeginn:\t" + vertragsbeginn);
		System.out.println("   Vertragsende:\t" + vertragsende);
		System.out.println("   Zahlungsintervall:\t" + intervallBezeichnung);
		System.out.println("   Grundpreis:\t\t" + String.format("%.2f €", grundpreis));
		System.out.println("   Sonder-Rabatt:\t" + String.format("%.2f €", preisrabatt));
		System.out.println("   Wochenpreis:\t\t" + String.format("%.2f €", wochenpreis));
		System.out.println("   Kommentar:\t\t" + (kommentar.isEmpty() ? "kein Kommentar" : kommentar));
		System.out.println("   Trainingsbeginn:\t" + trainingsbeginn);
		System.out.println("   Je Zahlungsintervall:" + String.format("%.2f €", betragJeIntervall));
		System.out.println("   Zahlungsbeginn:\t" + zahlungsbeginn);
		System.out.println("---------------------------------------------------");
		System.out.println("\nZahlungsdaten:");
		System.out.println("   Kontoinhaber:\t" + kontoinhaber);
		System.out.println("   IBAN:\t\t" + iban);
		System.out.println("   BIC:\t\t\t" + bic);

		System.out.println("\nMitarbeiter:");
		System.out.println("   " + mitarbeiterName);
		System.out.println("==================================================");
	}
	// ========================
	// Hilfsmethoden
	// ========================

}

----- Inhalt von: ÜbersichtService.txt -----
package Service;

import java.sql.Connection;
import java.util.Scanner;

public class ÜbersichtService extends BaseService {

    public ÜbersichtService(Connection connection, Scanner scanner) {
        super(connection, scanner);
    }

    public void start() {
        boolean zurueck = false;
        while (!zurueck) {
            System.out.println("==== Übersicht ====");
            System.out.println("1 - Zurück zum Hauptmenü");
            System.out.print("Bitte wählen: ");
            String eingabe = scanner.nextLine();
            if ("1".equals(eingabe)) {
                zurueck = true;
            } else {
                System.out.println("Ungültige Eingabe! Bitte erneut versuchen.");
            }
        }
    }
}

----- Inhalt von: BaseValidator.txt -----
package Validator;

import java.util.ArrayList;
import java.util.List;

import Exception.StringException;
import Exception.IntException;
import Exception.DateException;
import Exception.TimeException;
import Exception.DiscountException;
import Exception.BooleanException;

public abstract class BaseValidator<T> {
    // Liste, um Fehler zu speichern
    protected List<String> errors = new ArrayList<>();

    // Validierungsmethode, kann beliebige Exceptions werfen
    public abstract void validate(T obj) throws Exception, StringException, IntException, DateException, TimeException, DiscountException, BooleanException;

    // Ist die Eingabe gültig?
    public boolean isValid() {
        return errors.isEmpty();
    }

    // Fehler ausgeben
    public List<String> getErrors() {
        return errors;
    }

    // Entfernte Methode checkNotNull
    // Falls benötigt, kann sie wie folgt aussehen:
    // protected void checkNotNull(Object value, String fieldName) throws DataIsNullException {
    //     if (value == null) {
    //         String msg = fieldName + " darf nicht null sein.";
    //         errors.add(msg);
    //         throw new DataIsNullException(msg);
    //     }
    // }

    // Wenn ein String leer oder null ist, Fehlermeldung und Exception
    protected void checkNotEmptyString(String value, String fieldName) throws Exception {
        if (value == null || value.trim().isEmpty()) {
            String msg = fieldName + " darf nicht leer sein.";
            errors.add(msg);
            throw new Exception(msg);
        }
    }

    // Wenn die Länge nicht passt, Fehlermeldung und Exception
    public void checkLength(String value, String fieldName, int min, int max) throws Exception {
        if (value != null) {
            int length = value.length();
            if (length < min) {
                String msg = fieldName + " ist zu kurz. Minimum: " + min;
                errors.add(msg);
                throw new Exception(msg);
            }
            if (length > max) {
                String msg = fieldName + " ist zu lang. Maximum: " + max;
                errors.add(msg);
                throw new Exception(msg);
            }
        }
    }
}

----- Inhalt von: BigDecimalValidator.txt -----
package Validator;

import java.math.BigDecimal;

import Exception.BigDecimalException;

public class BigDecimalValidator {

    public void validate(BigDecimal value) throws BigDecimalException {
        if (value == null) {
            throw new BigDecimalException("BigDecimal-Wert darf nicht null sein.");
        }
        if (value.compareTo(BigDecimal.ZERO) < 0) {
            throw new BigDecimalException("BigDecimal-Wert darf nicht negativ sein.");
        }
    }
}

----- Inhalt von: BooleanValidator.txt -----
package Validator;

import Exception.BooleanException;

public class BooleanValidator extends BaseValidator<Boolean> {

    @Override
    public void validate(Boolean value) throws BooleanException {
        errors.clear();
        if (value == null) {
            throw new BooleanException("Boolean-Wert darf nicht null sein.");
        }
    }
}

----- Inhalt von: ComplexFieldValidator.txt -----
package Validator;

import Exception.StringException;
import Objekte.Mitglieder;
import Objekte.Mitarbeiter;
import Objekte.Ort;

import java.util.regex.Pattern;

public class ComplexFieldValidator {

    private static final Pattern PLZ_PATTERN = Pattern.compile("\\d{5}"); // 5-stellige PLZ

    /**
     * Validiert Adresse von Mitgliedern
     */
    public void validate(Mitglieder mitglied) throws StringException {
        if (mitglied == null) {
            throw new StringException("Mitglied darf nicht null sein.");
        }
        validateStrasseHausnr(mitglied.getStrasse(), mitglied.getHausnr());
        validateOrt(mitglied.getOrt());
    }

    /**
     * Validiert Adresse von Mitarbeitern
     */
    public void validate(Mitarbeiter mitarbeiter) throws StringException {
        if (mitarbeiter == null) {
            throw new StringException("Mitarbeiter darf nicht null sein.");
        }
        validateStrasseHausnr(mitarbeiter.getStraße(), mitarbeiter.getHausnr());
        validateOrt(mitarbeiter.getOrt());
    }

    private void validateStrasseHausnr(String strasse, String hausnr) throws StringException {
        if (strasse == null || strasse.trim().isEmpty()) {
            throw new StringException("Straße darf nicht leer sein.");
        }
        if (strasse.length() > 100) {
            throw new StringException("Straße ist zu lang (maximal 100 Zeichen).");
        }
        if (hausnr == null || hausnr.trim().isEmpty()) {
            throw new StringException("Hausnummer darf nicht leer sein.");
        }
        if (hausnr.length() > 10) {
            throw new StringException("Hausnummer ist zu lang (maximal 10 Zeichen).");
        }
    }

    private void validateOrt(Ort ort) throws StringException {
        if (ort == null) {
            throw new StringException("Ort darf nicht null sein.");
        }
        if (ort.getPLZ() == null || !PLZ_PATTERN.matcher(ort.getPLZ()).matches()) {
            throw new StringException("PLZ ist ungültig. Erwartet wird eine 5-stellige Zahl.");
        }
        if (ort.getOrt() == null || ort.getOrt().trim().isEmpty()) {
            throw new StringException("Ort darf nicht leer sein.");
        }
        if (ort.getOrt().length() > 50) {
            throw new StringException("Ort ist zu lang (maximal 50 Zeichen).");
        }
    }
}

----- Inhalt von: ContactValidator.txt -----
package Validator;

import Exception.StringException;
import Exception.MailException;
import Exception.TelefonException;
import OUTDATED.OUT_BasicTypeValidator;

import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.*;

public class ContactValidator extends OUT_BasicTypeValidator {

	// Regex für E-Mail
	private static final String EMAIL_REGEX = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$";
	private static final Pattern EMAIL_PATTERN = Pattern.compile(EMAIL_REGEX);

	// Land -> {minLänge, maxLänge}
	private static final Map<String, int[]> COUNTRY_CODES = Map.ofEntries(Map.entry("+49", new int[] { 11, 13 }), // Deutschland
			Map.entry("+43", new int[] { 11, 13 }), // Österreich
			Map.entry("+41", new int[] { 11, 12 }), // Schweiz
			Map.entry("+33", new int[] { 11, 12 }), // Frankreich
			Map.entry("+32", new int[] { 11, 12 }), // Belgien
			Map.entry("+31", new int[] { 11, 12 }), // Niederlande
			Map.entry("+352", new int[] { 11, 13 }), // Luxemburg
			Map.entry("+39", new int[] { 11, 13 }), // Italien
			Map.entry("+34", new int[] { 11, 12 }), // Spanien
			Map.entry("+351", new int[] { 11, 13 }), // Portugal
			Map.entry("+45", new int[] { 9, 11 }), // Dänemark
			Map.entry("+46", new int[] { 11, 13 }), // Schweden
			Map.entry("+47", new int[] { 9, 11 }), // Norwegen
			Map.entry("+358", new int[] { 11, 13 }), // Finnland
			Map.entry("+48", new int[] { 11, 12 }), // Polen
			Map.entry("+420", new int[] { 12, 13 }), // Tschechien
			Map.entry("+36", new int[] { 11, 12 }), // Ungarn
			Map.entry("+30", new int[] { 11, 13 }), // Griechenland
			Map.entry("+421", new int[] { 12, 13 }), // Slowakei
			Map.entry("+40", new int[] { 11, 12 }), // Rumänien
			Map.entry("+359", new int[] { 11, 13 }), // Bulgarien
			Map.entry("+385", new int[] { 11, 13 }), // Kroatien
			Map.entry("+381", new int[] { 11, 12 }), // Serbien
			Map.entry("+386", new int[] { 11, 13 }), // Slowenien
			Map.entry("+387", new int[] { 11, 13 }), // Bosnien und Herzegowina
			Map.entry("+389", new int[] { 11, 13 }), // Mazedonien
			Map.entry("+382", new int[] { 11, 13 }), // Montenegro
			Map.entry("+355", new int[] { 11, 13 }), // Albanien
			Map.entry("+372", new int[] { 11, 13 }), // Estland
			Map.entry("+371", new int[] { 11, 13 }), // Lettland
			Map.entry("+370", new int[] { 11, 13 }), // Litauen
			Map.entry("+353", new int[] { 11, 13 }), // Irland
			Map.entry("+44", new int[] { 11, 13 }), // Großbritannien / Vereinigtes Königreich
			Map.entry("+354", new int[] { 10, 11 }), // Island
			Map.entry("+423", new int[] { 10, 12 }) // Liechtenstein
	);

	// Land -> Internationale Beispielnummer
	private static final Map<String, String> COUNTRY_INTL_FORMATS = Map.ofEntries(Map.entry("+49", "+49 170 1234567"),
			Map.entry("+43", "+43 660 1234567"), Map.entry("+41", "+41 79 123 45 67"),
			Map.entry("+33", "+33 1 23 45 67 89"), Map.entry("+32", "+32 12 34 56 78"),
			Map.entry("+31", "+31 6 12345678"), Map.entry("+352", "+352 26 123456"),
			Map.entry("+39", "+39 347 1234567"), Map.entry("+34", "+34 612 34 56 78"),
			Map.entry("+351", "+351 912 345 678"), Map.entry("+45", "+45 12 34 56 78"),
			Map.entry("+46", "+46 70 123 45 67"), Map.entry("+47", "+47 123 45 678"),
			Map.entry("+358", "+358 40 1234567"), Map.entry("+48", "+48 123 456 789"),
			Map.entry("+420", "+420 123 456 789"), Map.entry("+36", "+36 30 123 4567"),
			Map.entry("+30", "+30 210 1234567"), Map.entry("+421", "+421 901 234 567"),
			Map.entry("+40", "+40 721 234 567"), Map.entry("+359", "+359 88 123 4567"),
			Map.entry("+385", "+385 91 234 5678"), Map.entry("+381", "+381 64 1234567"),
			Map.entry("+386", "+386 40 123 456"), Map.entry("+387", "+387 61 123 456"),
			Map.entry("+389", "+389 70 123 456"), Map.entry("+382", "+382 67 123 456"),
			Map.entry("+355", "+355 69 123 4567"), Map.entry("+372", "+372 5123 4567"),
			Map.entry("+371", "+371 22 123 456"), Map.entry("+370", "+370 612 34567"),
			Map.entry("+353", "+353 85 123 4567"), Map.entry("+44", "+44 7700 900123"),
			Map.entry("+354", "+354 660 1234"), Map.entry("+423", "+423 123 4567"));

	private static final String DE_VORWAHL = "+49";
	private static final String LANDESVORWAHL_REGEX = "^(\\+\\d{1,4}|00\\d{1,4})";
	private static final Pattern LANDESVORWAHL_PATTERN = Pattern.compile(LANDESVORWAHL_REGEX);

	private static final String NUMMER_REGEX = "^[+]?\\d{1,4}[\\d \\-()/]*$";
	private static final Pattern NUMMER_PATTERN = Pattern.compile(NUMMER_REGEX);

	/**
	 * Validiert eine E-Mail-Adresse.
	 * 
	 * @param obj Eingabe (String)
	 * @throws MailException bei ungültiger E-Mail-Adresse
	 */
	public void validateEmail(Object obj) throws Exception, StringException, MailException {
		super.validate(obj);
		if (isValid()) {
			String email = (String) obj;
			Matcher matcher = EMAIL_PATTERN.matcher(email);
			if (!matcher.matches()) {
				throw new MailException("Ungültige E-Mail-Adresse.");
			}
		}
	}

	/**
	 * Validiert und formatiert eine Telefonnummer.
	 * 
	 * @param obj Eingabe (String)
	 * @return formatierte Telefonnummer im internationalen Format
	 * @throws TelefonException bei ungültiger Telefonnummer
	 */
	public String validateUndFormatTelefon(Object obj) throws Exception, StringException, TelefonException {
		super.validate(obj);
		if (!isValid()) {
			throw new TelefonException("Ungültige Eingabe.");
		}

		String rawInput = (String) obj;
		String cleaned = rawInput.replaceAll("[^\\d+]", "");
		Matcher vorwahlMatcher = LANDESVORWAHL_PATTERN.matcher(cleaned);

		String ländervorwahl;
		String restNummer;

		if (vorwahlMatcher.find()) {
			ländervorwahl = vorwahlMatcher.group();
			restNummer = cleaned.substring(vorwahlMatcher.end());
			if (ländervorwahl.startsWith("00")) {
				ländervorwahl = "+" + ländervorwahl.substring(2);
			}
		} else {
			ländervorwahl = DE_VORWAHL;
			restNummer = cleaned.replaceFirst("^0+", "");
		}

		String validNummer = ländervorwahl + restNummer;

		int gesamtLänge = validNummer.length();
		int[] lengthRange = COUNTRY_CODES.getOrDefault(ländervorwahl, new int[] { 10, 16 });
		if (gesamtLänge < lengthRange[0] || gesamtLänge > lengthRange[1]) {
			throw new TelefonException("Nummer passt nicht zur Ländervorwahl oder ist zu kurz/lang.");
		}

		Matcher nummerMatcher = NUMMER_PATTERN.matcher(validNummer);
		if (!nummerMatcher.matches()) {
			throw new TelefonException("Ungültiges Nummernformat!");
		}

		String intlFormat = COUNTRY_INTL_FORMATS.getOrDefault(ländervorwahl, validNummer);
		return formatTelefonnummer(validNummer, intlFormat);
	}

	/**
	 * Formatiert die Telefonnummer anhand eines Beispielmusters (mit Leerzeichen).
	 */
	public static String formatTelefonnummer(String rawNumber, String laenderBeispiel) {
		String[] gruppen = laenderBeispiel.split(" ");
		String cleanNumber = rawNumber.replaceAll("[^\\d+]", "");
		String laenderVorwahl = gruppen[0];
		String nummerohneVorwahl;
		if (cleanNumber.startsWith(laenderVorwahl)) {
			nummerohneVorwahl = cleanNumber.substring(laenderVorwahl.length());
		} else {
			nummerohneVorwahl = cleanNumber;
		}

		List<Integer> gruppenLaenge = new ArrayList<>();
		for (int i = 1; i < gruppen.length; i++) {
			gruppenLaenge.add(gruppen[i].length());
		}

		List<String> nummerGruppiert = new ArrayList<>();
		int start = 0;
		for (int len : gruppenLaenge) {
			if (start + len <= nummerohneVorwahl.length()) {
				nummerGruppiert.add(nummerohneVorwahl.substring(start, start + len));
				start += len;
			} else {
				nummerGruppiert.add(nummerohneVorwahl.substring(start));
				break;
			}
		}

		return laenderVorwahl + " " + String.join(" ", nummerGruppiert);
	}

}

----- Inhalt von: CurrencyValidator.txt -----
package Validator;

import Exception.CurrencyException;
import OUTDATED.OUT_BasicTypeValidator;

public class CurrencyValidator extends OUT_BasicTypeValidator {

    private double result;

    @Override
    public void validate(Object value) throws Exception, CurrencyException {
        errors.clear();

        Double doubleValue = null;

        // Nutze BasicTypeValidator um Double typische Typen zu prüfen
        if (value instanceof Double || value instanceof Float || value instanceof Integer || value instanceof Long) {
            doubleValue = ((Number) value).doubleValue();
        } else {
            try {
                doubleValue = Double.parseDouble(value.toString().replace(",", "."));
            } catch (Exception e) {
                String msg = "Der Wert '" + value + "' ist keine gültige Währungsangabe.";
                errors.add(msg);
                throw new CurrencyException(msg);
            }
        }
        // Abrunden auf 2 Dezimalstellen
        doubleValue = Math.floor(doubleValue * 100) / 100.0;
        this.result = doubleValue;
    }

    public double getValidatedValue() {
        return result;
    }
}

----- Inhalt von: DateValidator.txt -----
package Validator;

import Exception.DateException;

public class DateValidator extends BaseValidator<String> {

	@Override
	public void validate(String obj) throws DateException {
		errors.clear();
		if (obj == null) {
			String msg = "Eingabe ist null.";
			errors.add(msg);
			throw new DateException(msg);
		}
		String dateStr = obj.trim();

		// Überprüfen, ob das Format dd.mm.yyyy eingehalten wird (z.B. 2 Ziffern, Punkt,
		// 2 Ziffern, Punkt, 4 Ziffern)
		if (!dateStr.matches("^\\d{2}\\.\\d{2}\\.\\d{4}$")) {
			String msg = "Datum muss im Format dd.mm.yyyy sein.";
			errors.add(msg);
			throw new DateException(msg);
		}

	}

}

----- Inhalt von: DiscountValidator.txt -----
package Validator;

import Exception.DiscountException;
import Objekte.MitgliederVertrag;
import Objekte.Vertrag;

public class DiscountValidator extends BaseValidator<MitgliederVertrag> {

    private Vertrag vertrag;

    public DiscountValidator(Vertrag vertrag) {
        this.vertrag = vertrag;
    }

    @Override
    public void validate(MitgliederVertrag mv) throws DiscountException {
        Double rabatt = mv.getPreisrabatt();
        Double grundpreis = vertrag.getGrundpreis();
        if (rabatt == null) rabatt = 0.0;
//        if (grundpreis == null) grundpreis = 0.0;
        if (rabatt > grundpreis) {
            String msg = "Der Rabatt (" + rabatt + ") ist größer als der Grundpreis (" + grundpreis + ")!";
            errors.add(msg);
            throw new DiscountException(msg);
        }
    }
}

----- Inhalt von: EndDateValidator.txt -----
package Validator;

import java.util.Calendar;
import java.util.Date;

import Exception.DataIsNullException;
import Exception.EndDateException;
import Objekte.MitgliederVertrag;

public class EndDateValidator extends BaseValidator<MitgliederVertrag> {

    private int laufzeitWochen = 0;

    public EndDateValidator(int laufzeitWochen) {
        this.laufzeitWochen = laufzeitWochen;
    }

    @Override
    public void validate(MitgliederVertrag mv) throws Exception {
        checkNotNull(mv.getVertragsbeginn(), "Vertragsbeginn");
        if (laufzeitWochen <= 0) {
            String msg = "Laufzeit muss größer 0 sein!";
            errors.add(msg);
            throw new DataIsNullException(msg);
        }
        Calendar cal = Calendar.getInstance();
        cal.setTime(mv.getVertragsbeginn());
        cal.add(Calendar.WEEK_OF_YEAR, laufzeitWochen);
        Date autoEndDate = cal.getTime();

        if (mv.getVertragsende() != null && !mv.getVertragsende().equals(autoEndDate)) {
            String msg = "Das Vertragsende wurde manuell gesetzt und stimmt nicht mit berechnetem Termin überein!";
            errors.add(msg);
            throw new EndDateException(msg);
        }
        mv.setVertragsende(autoEndDate);
    }

    public Date calculateEndDate(MitgliederVertrag mv) throws Exception {
        validate(mv);
        return mv.getVertragsende();
    }
}

----- Inhalt von: IntValidator.txt -----
package Validator;

import Exception.IntException;

public class IntValidator {

    public void validateObject(Object obj) throws IntException {
        if (!(obj instanceof Integer)) {
            throw new IntException("Eingabe ist keine ganze Zahl.");
        }
    }

    // Alternativ eine statische Methode zu Validierung
    public static void validateInt(Object obj) throws IntException {
        if (!(obj instanceof Integer)) {
            throw new IntException("Eingabe ist keine ganze Zahl.");
        }
    }
}

----- Inhalt von: LongValidator.txt -----
package Validator;

import Exception.LongException;

public class LongValidator {

    public void validate(Long value) throws LongException {
        if (value == null) {
            throw new LongException("Long-Wert darf nicht null sein.");
        }
        if (value < Long.MIN_VALUE || value > Long.MAX_VALUE) {
            throw new LongException("Long-Wert liegt außerhalb des gültigen Bereichs.");
        }
    }
}

----- Inhalt von: NotNullValidator.txt -----
package Validator;

import Exception.DataIsNullException;

public class NotNullValidator<T> extends BaseValidator<T> {

    @Override
    public void validate(T obj) throws DataIsNullException {
        errors.clear();
        if (obj == null) {
            String msg = "Eingabe darf nicht null sein.";
            errors.add(msg);
            throw new DataIsNullException(msg);
        }
    }
}

----- Inhalt von: PaymentDetailsValidator.txt -----
package Validator;

import Exception.PaymentDetailsException;
import Exception.StringException;
import OUTDATED.OUT_BasicTypeValidator;

import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class PaymentDetailsValidator extends OUT_BasicTypeValidator {

    private static final String IBAN_REGEX = "^[A-Z]{2}[0-9A-Z]{13,32}$";
    private static final Pattern IBAN_PATTERN = Pattern.compile(IBAN_REGEX);
    private static final String BIC_REGEX = "^[A-Z]{4}[A-Z]{2}[A-Z0-9]{2}([A-Z0-9]{3})?$";
    private static final Pattern BIC_PATTERN = Pattern.compile(BIC_REGEX);

    // IBAN Validierung mit Formatierung
    public String validateIBAN(Object obj) throws Exception, StringException, PaymentDetailsException {
        super.validate(obj);
        if (isValid()) {
            String iban = ((String) obj).replaceAll("\\s+", "");
            if (iban.equalsIgnoreCase("TEST")) {
                return formatIbanGroups(iban);
            }
            if (iban.length() < 15 || iban.length() > 34) {
                String msg = "IBAN muss zwischen 15 und 34 Zeichen lang sein.";
                errors.add(msg);
                throw new PaymentDetailsException(msg);
            }
            if (iban.startsWith("DE")) {
                if (iban.length() != 22) {
                    String msg = "Deutsche IBAN muss exakt 22 Zeichen lang sein.";
                    errors.add(msg);
                    throw new PaymentDetailsException(msg);
                }
                String bankCode = iban.substring(4, 12);
                String accountNum = iban.substring(12, 22);
                if (!bankCode.matches("\\d{8}") || !accountNum.matches("\\d{10}")) {
                    String msg = "BLZ oder Kontonummer hat falsches Format (BLZ=8, Kto=10 Ziffern).";
                    errors.add(msg);
                    throw new PaymentDetailsException(msg);
                }
            }
            Matcher matcher = IBAN_PATTERN.matcher(iban);
            if (!matcher.matches()) {
                String msg = "Eingabe entspricht nicht dem IBAN-Format.";
                errors.add(msg);
                throw new PaymentDetailsException(msg);
            } else if (!isValidIBAN(iban)) {
                String msg = "IBAN ist ungültig (Prüfziffernfehler).";
                errors.add(msg);
                throw new PaymentDetailsException(msg);
            }
            // Nach erfolgreicher Validierung Rückgabe als formatierter String
            return formatIbanGroups(iban);
        }
        return null;
    }

    // Fügt nach je vier Zeichen ein Leerzeichen ein
    private String formatIbanGroups(String iban) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < iban.length(); i++) {
            if (i > 0 && i % 4 == 0) sb.append(' ');
            sb.append(iban.charAt(i));
        }
        return sb.toString();
    }

    private boolean isValidIBAN(String iban) {
        String rearranged = iban.substring(4) + iban.substring(0, 4);
        StringBuilder numericIBAN = new StringBuilder();
        for (char ch : rearranged.toCharArray()) {
            if (Character.isDigit(ch)) {
                numericIBAN.append(ch);
            } else {
                numericIBAN.append(Character.getNumericValue(ch));
            }
        }
        String checkString = numericIBAN.toString();
        int mod = 0;
        for (int i = 0; i < checkString.length(); i += 7) {
            int end = Math.min(i + 7, checkString.length());
            String part = mod + checkString.substring(i, end);
            mod = Integer.parseInt(part) % 97;
        }
        return mod == 1;
    }

    // BIC Validierung
    public void validateBIC(Object obj) throws StringException, PaymentDetailsException {
        super.validate(obj);
        if (isValid()) {
            String bic = (String) obj;
            if (bic.equalsIgnoreCase("TEST")) {
                return;
            }
            Matcher matcher = BIC_PATTERN.matcher(bic);
            if (!matcher.matches()) {
                String msg = "Eingabe ist kein gültiger BIC.";
                errors.add(msg);
                throw new PaymentDetailsException(msg);
            }
        }
    }
}

----- Inhalt von: PaymentValidator.txt -----
package Validator;

import Exception.PayException;
import Exception.PaymentDetailsException;
import Objekte.Mitglieder;
import Objekte.MitgliederVertrag;
import Objekte.Zahlung;
import Objekte.Zahlungsdaten;

public class PaymentValidator extends BaseValidator<MitgliederVertrag> {

    private Zahlung zahlung;
    private Mitglieder mitglied;

    public PaymentValidator(Zahlung zahlung, Mitglieder mitglied) {
        this.zahlung = zahlung;
        this.mitglied = mitglied;
    }

    @Override
    public void validate(MitgliederVertrag mv) throws Exception {
        // Prüfe Zahlungsart "Abbuchung" ODER "SEPA-Lastschrift"
        String zahlungsart = zahlung.getZahlungsart();
        if (zahlungsart == null || 
            (!zahlungsart.equalsIgnoreCase("Überweisung") && 
             !zahlungsart.equalsIgnoreCase("SEPA-Lastschrift"))) {
            String msg = "Zahlungsart muss 'Überweisung' oder 'SEPA-Lastschrift' sein, ist aber '" + zahlungsart + "'";
            errors.add(msg);
            throw new PayException(msg);
        }

        // Prüfe Zahlungsdaten
        Zahlungsdaten zahlungsdaten = mitglied.getZahlungsdaten();
        if (zahlungsdaten == null
                || zahlungsdaten.getName() == null || zahlungsdaten.getName().trim().isEmpty()
                || zahlungsdaten.getIBAN() == null || zahlungsdaten.getIBAN().trim().isEmpty()
                || zahlungsdaten.getBIC() == null || zahlungsdaten.getBIC().trim().isEmpty()) {
            String msg = "Zahlungsdaten unvollständig für Mitglied (" + mitglied.getMitgliederID() + ")";
            errors.add(msg);
            throw new PaymentDetailsException(msg);
        }
    }
}

----- Inhalt von: RangeValidator.txt -----
package Validator;

public class RangeValidator<T> extends BaseValidator<T> {
    
    private Comparable<T> min;
    private Comparable<T> max;

    public RangeValidator(Comparable<T> min, Comparable<T> max) {
        this.min = min;
        this.max = max;
    }

    @Override
    @SuppressWarnings("unchecked")
    public void validate(T value) throws Exception {
        errors.clear();
        if (value == null) {
            String msg = "Wert darf nicht null sein.";
            errors.add(msg);
            throw new Exception(msg);
        }

        if (!(value instanceof Comparable)) {
            String msg = "Wert ist nicht vergleichbar.";
            errors.add(msg);
            throw new Exception(msg);
        }

        Comparable<T> compValue = (Comparable<T>) value;

        if (min != null && compValue.compareTo((T) min) < 0) {
            String msg = "Wert ist kleiner als das Minimum: " + min;
            errors.add(msg);
            throw new Exception(msg);
        }

        if (max != null && compValue.compareTo((T) max) > 0) {
            String msg = "Wert ist größer als das Maximum: " + max;
            errors.add(msg);
            throw new Exception(msg);
        }
    }
}

----- Inhalt von: StringValidator.txt -----
package Validator;

import Exception.StringException;

public class StringValidator extends BaseValidator<String> {

    @Override
    public void validate(String value) throws StringException {
        errors.clear();
        if (value == null || value.trim().isEmpty()) {
            String msg = "Der String darf nicht null oder leer sein.";
            errors.add(msg);
            throw new StringException(msg);
        }
        if (value.length() > 255) {
            String msg = "Der String ist zu lang (maximal 255 Zeichen).";
            errors.add(msg);
            throw new StringException(msg);
        }
    }
}

